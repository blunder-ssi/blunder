Each value is a pin x:<i>, a law x:{n a b}, an app x:(f g), or a nat x:@.

Treat this as a combinator system, and normalize using normal-order
evaluation.

    (0 n a b)            = {N(n) N(a) force(body)}
    (1 p _ _ _ <x>)      = (p x)
    (1 _ l _ _ {n a b})  = (l n a b)
    (1 _ _ a _ (f x))    = (a f x)
    (1 _ _ _ n x:@)      = (n x)
    (2 z p x)            = n=N(x); if n=0 then z else p (n-1)
    (3 x)                = N(x)+1
    (4 x)                = <force(x)>
    (f:{n a b} x0..xn)   = R([f x0..xn], b)
    (f:<{n a b}> x0..xn) = R([f x0..xn], b)
    (<i> ..)             = (i ..)

    N(x:@) = x
    N(_)   = 0

    R(e, n:@)     = e[n] or n if n>=len(e)
    R(e, (0 x y)) = (R(x), R(y))
    R(e, (1 v b)) = R(f,b) where f = e ++ [R(f,v)]
    R(e, (2 x))   = x
    R(e, x)       = x

This informal specification glosses over details, but is otherwise correct.
