; Copyright 2023 The Plunder Authors
; Use of this source code is governed by a BSD-style license that can be
; found in the LICENSE file.

### 10_str <- 09_chr

;;;; Strings
;;;; =======
;;;;
;;;; A `Str` is a utf8 string represented as a natural number.


;;; Imports ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

/+  01_fan
/+  02_bit  [if ifNot and or not]
/+  03_nat  [add sub lsh roundUp met mul rsh mod div]
/+  05_row  []
/+  04_cmp  [eql neq gth]
/+  05_row  [foldl]
/+  06_rex  []
/+  07_dat  [CONS NIL listFoldl listToRow listDrop listMap listLen listAll]
/+  07_dat  [{,} {>}]
/+  08_sci  []
/+  09_chr  [isDigit isHexDigit isUpper toUpper toLower ord]


;;; Definitions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(strWeld x y)=(| add x | lsh y | roundUp met-x 8)
(strCat vs)=(foldl strWeld 0 vs)

= (strToList s)
| ifNot s NIL
| CONS (mod s 256)
| strToList (div s 256)

(strFromList cs)=(listFoldl strWeld 0 cs)
(explode str)=(listToRow strToList-str)
(implode cs)=(strCat cs)

= (strLen s)       | listLen (strToList s)
= (strMap f str)   | strFromList | listMap f | strToList str
= (strToUpper str) | strMap toUpper str
= (strToLower str) | strMap toLower str

= (strCapitalize str)
@ hed (mod str 256)
@ cap (toUpper hed)
| add cap (sub str hed)

(strIsCapitalized str)=(isUpper (mod str 256))

;; {loadDecimal} parses a decimal number without validating, instead
;; assuming that each character is in the appropriate range.

> Str > Nat
= (loadDecimal n)
^ listFoldl _ 0 (strToList n)
& (acc c)
| if (eql c {_}) acc
| add (mul 10 acc) (ord c)

;; {loadHexLit} does the same, but for hexidecimal literals (which are
;; expected to start with {0x}).

> Str > Nat
= (loadHexLit n)
^ listFoldl _ 0 (listDrop 2 | strToList n)
& (acc c)
| if (eql {_} c) acc
| add (mul 16 acc)
| if isDigit-c (sub c {0})
| add 10
| sub toLower-c {a}

!!= 255 | loadHexLit {0xff}
!!= 255 | loadHexLit {0x_f_f_}
!!= 14  | loadHexLit {0x0e}
!!= 15  | loadHexLit {0x0f}
!!= 15  | loadHexLit {0xf}
!!= 240 | loadHexLit {0xf0}
!!= 0   | loadHexLit {0x}

;; {loadKeyWord} parses something that is either a decimal literal or
;; a string.  It either parses the decimal number or casts the input string
;; to a number.

= (isDecimalLit str)
| and str
| listAll x&(or eql-x-{_} isDigit-x)
| strToList str

= (isHexLit str)
| and (gth str {0x})
| and (eql {0x} | mod str 65536)
| listAll c&(or (eql c {_}) isHexDigit-c)
| listDrop 2 strToList-str

!!= 1 | isHexLit {0xff}
!!= 1 | isHexLit {0x0e}
!!= 1 | isHexLit {0x0f}
!!= 1 | isHexLit {0xF0}
!!= 0 | isHexLit {0x}
!!= 0 | isHexLit {0xg}

> Str > Nat
= (loadKeyWord str)
| if isDecimalLit-str | loadDecimal str
| if isHexLit-str     | loadHexLit str
| str


;;; Tests ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

!!= {fdsa} (strWeld {} {fdsa})
!!= {fdsa} (strWeld {f} {dsa})

; TODO: Why the fuck does this crash?  It makes no sense!  It's doing
; the same things as the other things??
!!= {fdsa} (strWeld {f} {dsa})

!!= [{f}]     (explode {f})
!!= [255]     (explode 255)
!!= [{f} {d}] (explode {fd})

!!= 0 (strLen {})
!!= 1 (strLen {a})
!!= 2 (strLen {ab})
!!= 3 (strLen {abc})


;;; Exports ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

^-^
^-^  strLen
^-^  strWeld strCat
^-^  strToList strFromList
^-^  explode implode
^-^  strToUpper strToLower strCapitalize strIsCapitalized
^-^  strMap
^-^
^-^  isDecimalLit loadDecimal
^-^  isHexLit     loadHexLit
^-^  loadKeyWord
^-^
