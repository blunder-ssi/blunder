;;; Copyright 2023 The Plunder Authors
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.

### sire <- kern

/+  boot
/+  datatype
/+  switch
/+  datatype [parseDatacase]

"""
""" sire.sire
""" =========
"""
""" Parser and (simple) printer for Sire + Macros.
"""
""" TODO: Can we make {EREC} support destructuring too?  Why not?
"""
""" TODO: Kill io.sire
"""
""" TODO: Parse all built-in command runes:
"""
""" - [ ] !!= #!!=
""" - [ ] = #=
""" - [ ] * #*
""" - [ ] < #<
""" - [ ] ###
"""
""" TODO: Parse all macro-defined commands:
"""
""" - [ ] !!
""" - [ ] #mutual
"""
""" DONE: Parse all built-in expression runes:
"""
""" - [x] | #|
""" - [x] @ #@
""" - [x] @@ #@@
""" - [x] & #&
""" - [x] ? #?
""" - [x] ?? #??
""" - [x] ** #**
""" - [x] ^ #^
"""
""" TODO: Parse all macro-defined expressions:
"""
"""
""" - [ ] #p #b #x
""" - [ ] % %%
""" - [ ] ` ``
""" - [ ] && || == /=
""" - [-] , ,,
""" - [ ] :
""" - [ ] ~ ~~ ::
""" - [x] #
""" - [ ] #mutrec
""" - [ ] #record #datacase #datatype #switch
"""
""" Some macros are don't need to be supported
"""
""" - > \
""" - #abstype #backfill #typedef
""" - #typeof #printType
""" - #getenv #getKey #getProp #setProp #hasProp #getTypeNames


""" Types """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

# datatype Pat
* PVAR=v k:Key n:Sym
* PSEQ=s k:Key p:Sym
* PALI=a n:Sym p:Pat
* PROW=r x:(Row Pat)
* PTAB=t x:(Tab Any Pat)

# record ConCase
| CON_CASE con:Sym params:(Row Pat) body:Exp

# record Fun
| FUN self:Sym tag:Nat args:(Row Pat) body:Exp

# datatype Exp
* EBED=cns b:Any
* EREF=ref r:Str
* ENAT=nat n:Nat
* EAPP=app x:Exp y:Exp
* EKET=ket xs:(Row Exp) v:Exp
* ELET=let n:Pat x:Exp b:Exp
* EREC=rec n:Str x:Exp b:Exp
* ELAM=lam pin:Bit fun:(Str, Nat, Row Pat, Exp)
* ELIN=lin x:Exp
* EROW=row xs:(Row Exp)
* ECAS=cas x:Exp fb:(Opt Exp) cs:(Row ConCase)
* EUNT=unt


""" Printing """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

> Any > Rex
= (showKey k)
| ifNot (isNat k)
    | todo {TODO: Support non-nat keys when printing tab patterns}
| WORD 0 (showNat k) 0

> (v > Rex) > Tab Any v > Rex
= (showTab showVal tab)
| if (null tab) `(%[])
^ NEST 0 {,} _ 0
^ map _ (tabToPairs tab)
& [k v]
^ trk [=k =v res=_] _
^ SHUT 0 {=} _ 0
| (showKey k, showVal v)

> Pat > Rex
= (showPat p)
# datacase p
* (PVAR _k v) | varE v
* (PSEQ _k v) | PREF 0 {!} ,(varE v) 0
* (PALI x y)  | SHUT 0 {@} (showPat x, showPat y) 0
* (PROW xs)   | NEST 0 {,} (map showPat xs) 0
* (PTAB xs)   | showTab showPat xs

!!= (` %[])
  | showPat | PTAB %[]

!!= `[120=x 121=(!y)]
  | showPat | PTAB [x=(PVAR 0 %x) y=(PSEQ 0 %y)]

!!= ` x@[a b@[c !d]]
  | showPat | PALI (PVAR 0 %x)
            | PROW ,, PVAR 0 %a
                   ,, PALI (PVAR 0 %b)
                        | PROW (PVAR 0 "c", PSEQ 0 "d")

> Row Rex > Rex
= (showSig rexes@[first])
| if (len rexes == 1) first
| NEST 0 {|} rexes 0

> (Exp > Rex) > Bit > Fun > Rex
= (showFun showSire pin (FUN self tag args body))
| if pin
    | todo 'show pinned lambdas'
| if (self /= tag)
    | todo 'show lambdas where name is different from tag'
@ selfRex  | varE self
@ argRexes | map showPat args
| if (isZero tag)
    | INFX 0 {&} (showSig argRexes, showSire body) 0
| else
    | INFX 0 {?} (showSig (rowCons selfRex argRexes), showSire body) 0

> Sym > Row Pat > Rex
= (showCon cn pts)
| if (null pts) (varE cn)
^ NEST 0 {|} _ 0
| rowCons (varE cn)
| map showPat pts

> (Exp > Rex) > Opt Exp > Row ConCase > Rex
= (showDatacases showSire f xs)
^ _ (listFromRow xs)
? (go xs)
: (cn,pts,b) xs
    < listCase xs
    # datacase f
    * NONE      | 0
    * (SOME fb) | ``(* _ $$(showSire fb))
@ rest (go xs)
| ``((* $$(showCon cn pts) $$(showSire b))($$rest))

= (niceApp showSire e)
^ _ e ~[]
? (loop e acc)
# datacase e
* (EAPP f x) | loop f (showSire x)::acc
* _          | NEST 0 {|} (listToRow (showSire e)::acc) 0

= (showCase showSire x f cs)
| NEST 0 {#} (varE 'datacase', showSire x)
| showDatacases showSire f cs

> Exp > Rex
= (showSire exp)
@ go showSire
# datacase exp
* (EBED x)       | EMBD x
* (EREF x)       | WORD 0 x 0
* (ENAT n)       | WORD 0 showNat-n 0
* (EAPP x y)     | niceApp go exp
* (EKET xs v)    | NEST 0 {^} (map go xs) (go v)
* (ELET n x b)   | INFX 0 {@}  (showPat n, go x) (go b)
* (EREC n x b)   | INFX 0 {@@} (showPat (PVAR 0 n), go x) (go b)
* (ELAM pin fun) | showFun go pin fun
* (ELIN x)       | PREF 0 {**} ,(showSire x) 0
* (EROW xs)      | NEST 0 {,} (map go xs) 0
* EUNT           | `()
* (ECAS x f cs)  | showCase go x f cs
* _              | {showSire: Unknown syntax} exp

!!= ` (n @ 6516329)(fanc @ **mkLaw n a b)(0 0 0 (2 fanc))
  | showSire
  | ELET (PVAR 0 "n") (ENAT %inc)
  | ELET (PVAR 0 "fanc")
      | foldl EAPP (ELIN | EREF %mkLaw)
     ,, EREF %n
     ,, EREF %a
     ,, EREF %b
  | EAPP
      | EAPP
          | EAPP (ENAT 0) (ENAT 0)
      | ENAT 0
  | EAPP (ENAT 2)
  | EREF %fanc

!!= ` (x y & x)
  | showSire
  | ELAM FALSE
  | FUN 0 0 (PVAR 0 %x, PVAR 0 %y) (EREF %x)

!!= ` (const x y ? x)
  | showSire
  | ELAM FALSE
  | FUN "const" "const" (PVAR 0 %x, PVAR 0 %y) (EREF %x)

!!= ` (^ f _ y)x
  | showSire
  | EKET (EREF %f, EREF %_, EREF %y)
  | EREF %x


""" Parsing """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseLet readSire rex err ok)
@ kids@[patRex expRex bodRex] (rexKids rex)
| if (len kids /= 3) (err rex 'Bad let')
: var < parseBinder patRex err
: exp < readSire expRex err
: bod < readSire bodRex err
| ok (ELET var exp bod)

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseRec readSire rex err ok)
: res < parseLet readSire rex err
# datacase res
* _ (die 'impossible')
* (ELET p x b)
# datacase p
* _ | err rex {recursive-let currently doesn't support pattern matching}
* (PVAR _ v)
| ok (EREC v x b)

> (Rex > Parser Exp) > Rex > Parser Rex
= (parseHax readSire rex err ok)
@ kids@[param] (rexKids rex)
| if (null kids) (err rex '# with no parameter')
: sym <- readSymbol param err
# switch sym
* _ | err rex (strWeld 'Unknown keyword: #' sym)
* "datacase"
: val fb cases < parseDatacase readSire rex err
| ok ^ ECAS val fb (map _ cases)
     & [_ constr pats body]
     | CON_CASE constr pats body

= (readApp readSire rex err ok)
@ kids (rexKids rex)
| if (isZero | len kids) (ok EUNT)
: exps < traverseRow (x k & readSire x err k) kids
| ok (foldl EAPP (idx 0 exps) (drop 1 exps))

= (readKet readSire rex err ok)
@ sons (rexSons rex)
@ heir (rexHeir rex)
| if (null sons && isZero heir)
    | err rex "Bad ^ must be:  (^ f _ y)x"
: exp <- traverseRow (x k & readSire x err k) sons
: cab <- readSire heir err
| ok | EKET exp cab

= (readPam readSire rex err ok)
@ kids (rexKids rex)
| if (len kids /= 2) (err rex 'Bad lambda')
@ [sigRex bodRex] kids
: pats <- readBindSig sigRex err
: body <- readSire bodRex err
| ok | ELAM FALSE | FUN 0 0 pats body

= (readWut readSire pinned rex err ok)
@ kids@[sigRex bodRex] (rexKids rex)
| if (len kids /= 2) (err rex 'Bad lambda.')
: func pats <- readDestroyer sigRex err
: body <- readSire bodRex err
| ok (ELAM pinned | FUN func func pats body)

= (readLin readSire rex err ok)
@ kids@[expRex]
    | rexKids rex
| if (len kids /= 1)
    | err rex "Expected something like: **x"
: exp <- readSire expRex err
| ok (ELIN exp)

= (readCom readSire rex err ok)
: exps <- traverseRow (x k & readSire x err k) (rexKids rex)
| ok (EROW exps)

= (readLeaf rex err ok)
@ txt (rexText rex)
# switch (rexStyle rex)
* CORD ok-(ENAT txt)
* TAPE ok-(ENAT txt)
* LINE ok-(ENAT txt)
* PAGE ok-(ENAT txt)
* CURL ok-(ENAT txt)
* WORD
; TODO: Parse nat literals
| ok (EREF txt)

> Rex > Parser Exp
= (readSire rex err ok)
# switch (rexType rex)
* "EMBD" | ok EBED-(rexGetEmbd rex)
* "LEAF" | readLeaf rex err ok
* "NODE"
# switch (rexRune rex)
* {^}   | readKet readSire rex err ok
* {#^}  | readKet readSire rex err ok
* {|}   | readApp readSire rex err ok
* {#|}  | readApp readSire rex err ok
* {&}   | readPam readSire rex err ok
* {#&}  | readPam readSire rex err ok
* {?}   | readWut readSire FALSE rex err ok
* {#?}  | readWut readSire FALSE rex err ok
* {??}  | readWut readSire TRUE rex err ok
* {#??} | readWut readSire TRUE rex err ok
* {**}  | readLin readSire rex err ok
* {#**} | readLin readSire rex err ok
* {,}   | readCom readSire rex err ok
* {@}   | parseLet readSire rex err ok
* {#@}  | parseLet readSire rex err ok
* {@@}  | parseRec readSire rex err ok
* {#@@} | parseRec readSire rex err ok
* {#}   | parseHax readSire rex err ok
* _     | err rex (strWeld 'Unknown Rune')

; Assumes that the input formatting matches the printers formatting.
= (sireRound rex)
@ out (readSire rex v2 showSire)
| if (rexEql rex out) 1
| out

!! sireRound ` x
!! sireRound ` 0
!! sireRound ` (f x y)
!! sireRound ` (**f x y)
!! sireRound ` (x & x)
!! sireRound ` (x y & x)
!! sireRound ` (id x ? x)
!! sireRound ` (const x y ? x)
!! sireRound ` (x @ 3)(x x x)
!! sireRound ` (x @@ 3)x
!! sireRound ` (^ f _ y)x
!! sireRound ` (x @ [1 2])[x x]
!! sireRound ` ([x y] @ [1 2])[y x]
!! sireRound ` (z@[!x y] @ [1 2])(x y z)

!!= ` (span f r ? (l @ len r)(^ _ 0)(loop i ? if (eql i l) (v2 r v0) (if (f (idx i r)) (loop (inc i)) (v2 (take i r) (drop i r)))))
  ^ readSire _ v2 showSire
  ` ? (span f r)
    @ l | len r
    ^ _ 0
    ? (loop i)
    | if (eql i l) (v2 r v0)
    | if (f (idx i r))
        | loop (inc i)
    (v2 (take i r) (drop i r))

!!= `((# datacase a)(* NONE 0)(* (SOME x) x))
  ^ readSire _ v2 showSire
  ` # datacase a
    * NONE     0
    * (SOME x) x

!!= `((# datacase a)(* NONE 0)(* _ 1))
  ^ readSire _ v2 showSire
  ` # datacase a
    * NONE     0
    * _        1


""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^ EBED EREF ENAT EAPP EKET ELET EREC ELAM ELIN ECAS
^-^
^-^ readSire showSire
