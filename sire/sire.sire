;;; Copyright 2023 The Plunder Authors
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.

### sire <- kern

/+  boot
/+  datatype
/+  switch
/+  datatype [parseDatacase]

"""
""" sire.sire
""" =========
"""
""" Parser and (simple) printer for Sire + Macros.
"""
""" TODO: Also parse commands
"""
""" TODO: Can we make {EREC} support destructuring too?  Why not?
"""


""" Types """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

# datatype Pat
* PVAR=v k:Key n:Sym
* PSEQ=s k:Key p:Sym
* PALI=a n:Sym p:Pat
* PROW=r x:(Row Pat)
* PTAB=t x:(Tab Any Pat)

# record ConCase
| CON_CASE con:Sym params:(Row Pat) body:Exp

# record Fun
| FUN self:Sym tag:Nat args:(Row Pat) body:Exp

# datatype Exp
* EBED=cns b:Any
* EREF=ref r:Str
* ENAT=nat n:Nat
* EAPP=app x:Exp y:Exp
* EKET=ket xs:(Row Exp) v:Exp
* ELET=let n:Pat x:Exp b:Exp
* EREC=rec n:Str x:Exp b:Exp
* ELAM=lam pin:Bit fun:(Str, Nat, Row Pat, Exp)
* ELIN=lin f:Str xs:(Row Exp)
* EROW=row xs:(Row Exp)
* ECAS=cas x:Exp fb:(Opt Exp) cs:(Row ConCase)


""" Printing """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

> Any > Rex
= (showKey k)
| ifNot (isNat k)
    | todo {TODO: Support non-nat keys when printing tab patterns}
| WORD 0 (showNat k) 0

> (v > Rex) > Tab Any v > Rex
= (showTab showVal tab)
| if (null tab) `(%[])
^ NEST 0 "," _ 0
^ map _ (tabToPairs tab)
& [k v]
^ trk [=k =v res=_] _
^ SHUT 0 "=" _ 0
| (showKey k, showVal v)

> Pat > Rex
= (showPat p)
# datacase p
* (PVAR _k v) | varE v
* (PSEQ _k v) | PREF 0 "!" ,(varE v) 0
* (PALI x y)  | SHUT 0 "@" (showPat x, showPat y) 0
* (PROW xs)   | NEST 0 "," (map showPat xs) 0
* (PTAB xs)   | showTab showPat xs

!!= (` %[])
  | showPat | PTAB %[]

!!= `[120=x 121=(!y)]
  | showPat | PTAB [x=(PVAR 0 %x) y=(PSEQ 0 %y)]

!!= ` x@[a b@[c !d]]
  | showPat | PALI (PVAR 0 %x)
            | PROW ,, PVAR 0 %a
                   ,, PALI (PVAR 0 %b)
                        | PROW (PVAR 0 "c", PSEQ 0 "d")

> Row Rex > Rex
= (showSig rexes@[first])
| if (len rexes == 1) first
| NEST 0 "|" rexes 0

> (Exp > Rex) > Bit > Fun > Rex
= (showFun showSire pin (FUN self tag args body))
| if pin
    | todo 'show pinned lambdas'
| if (self /= tag)
    | todo 'show lambdas where name is different from tag'
@ selfRex  | varE self
@ argRexes | map showPat args
| if (isZero tag)
    | INFX 0 "&" (showSig argRexes, showSire body) 0
| else
    | INFX 0 "?" (showSig (rowCons selfRex argRexes), showSire body) 0

> Sym > Row Pat > Rex
= (showCon cn pts)
| if (null pts) (varE cn)
^ NEST 0 "|" _ 0
| rowCons (varE cn)
| map showPat pts

> (Exp > Rex) > Opt Exp > Row ConCase > Rex
= (showDatacases showSire f xs)
^ _ (listFromRow xs)
? (go xs)
: (cn,pts,b) xs
    < listCase xs
    # datacase f
    * NONE      | 0
    * (SOME fb) | ``(* _ $$(showSire fb))
@ rest (go xs)
| ``((* $$(showCon cn pts) $$(showSire b))($$rest))

> Exp > Rex
= (showSire exp)
@ go showSire
@ (niceApp e)
    ^ _ e ~[]
    ? (loop e acc)
    # datacase e
    * (EAPP f x) | loop f (go x)::acc
    * _          | NEST 0 '|' (listToRow (go e)::acc) 0
# datacase exp
* (EBED x)       | EMBD x
* (EREF x)       | WORD 0 x 0
* (ENAT n)       | WORD 0 showNat-n 0
* (EAPP x y)     | niceApp exp
* (EKET xs v)    | NEST 0 "^" (map go xs) (go v)
* (ELET n x b)   | INFX 0 '@'  (showPat n, go x) (go b)
* (EREC n x b)   | INFX 0 '@@' (showPat (PVAR 0 n), go x) (go b)
* (ELAM pin fun) | showFun go pin fun
* (ELIN f xs)    ^ (NEST 0 '|' _ 0)
                 | rowCons (PREF 0 '**' [(go EREF-f)] 0)
                 | map go xs
* (EROW xs)      | NEST 0 "," (map go xs) 0
* (ECAS x f cs)
    | NEST 0 '#' (varE 'datacase', go x)
    | showDatacases go f cs
* _
    | {showSire: Unknown syntax} exp

!!= ` (n @ 6516329)(fanc @ **mkLaw n a b)(0 0 0 (2 fanc))
  | showSire
  | ELET (PVAR 0 "n") (ENAT %inc)
  | ELET (PVAR 0 "fanc")
      | ELIN %mkLaw
     ,, EREF %n
     ,, EREF %a
     ,, EREF %b
  | EAPP
      | EAPP
          | EAPP (ENAT 0) (ENAT 0)
      | ENAT 0
  | EAPP (ENAT 2)
  | EREF %fanc

!!= ` (x y & x)
  | showSire
  | ELAM FALSE
  | FUN 0 0 (PVAR 0 %x, PVAR 0 %y) (EREF %x)

!!= ` (const x y ? x)
  | showSire
  | ELAM FALSE
  | FUN "const" "const" (PVAR 0 %x, PVAR 0 %y) (EREF %x)

!!= ` (^ f _ y)x
  | showSire
  | EKET (EREF %f, EREF %_, EREF %y)
  | EREF %x


""" Parsing """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseLet readSire rex err ok)
@ kids@[patRex expRex bodRex] (rexKids rex)
| if (len kids /= 3) (err rex 'Bad let')
: var < parseBinder patRex err
: exp < readSire expRex err
: bod < readSire bodRex err
| ok (ELET var exp bod)

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseRec readSire rex err ok)
: res < parseLet readSire rex err
# datacase res
* _ (die 'impossible')
* (ELET p x b)
# datacase p
* _ | err rex {recursive-let currently doesn't support pattern matching}
* (PVAR _ v)
| ok (EREC v x b)

> (Rex > Parser Sire) > Rex > Parser (Either Sym Sire)
= (readAppHead readSire rex err ok)
| if (rexRune rex == "**")
    @ kids (rexKids rex)
    | if (len kids /= 1)
        | err rex "bad inline syntax, must be '**foo'"
    : sym <- readSymbol (idx 0 kids) err
    | ok (LEFT sym)
: exp <- readSire rex err
| ok (RIGHT exp)

> (Rex > Parser Exp) > Rex > Parser Rex
= (parseHax readSire rex err ok)
@ kids@[param] (rexKids rex)
| if (null kids) (err rex '# with no parameter')
: sym <- readSymbol param err
# switch sym
* "datacase"
    : val fb cases < parseDatacase readSire rex err
    | ok ^ ECAS val fb (map _ cases)
         & [_ constr pats body]
         | CON_CASE constr pats body
* _
    | err rex (strWeld 'Unknown keyword: #' sym)

> Rex > Parser Exp
= (readSire rex err ok)
@ style (rexStyle rex)
@ rune  (rexRune rex)
@ kids  (rexKids rex)
# switch rune
* 0
    # switch style
    * EMBD | ok | EBED | rexEmbd rex
    * WORD | ok | EREF | rexText rex ;; TODO: nat literals
    * CORD | ok | ENAT | rexText rex
    * TAPE | ok | ENAT | rexText rex
    * LINE | ok | ENAT | rexText rex
    * PAGE | ok | ENAT | rexText rex
    * CURL | ok | ENAT | rexText rex
* '^'
    @ sons (rexSons rex)
    @ heir (rexHeir rex)
    | if (null sons && isZero heir)
        | err rex "Bad ^ must be:  (^ f _ y)x"
    : exp <- traverseRow (x k & readSire x err k) sons
    : cab <- readSire heir err
    | ok | EKET exp cab
* '|'
    | if isZero-(len kids) (err rex "| with no kids")
    @ funcRex | idx 0 kids
    @ argsRex | drop 1 kids
    : fHead   < readAppHead readSire funcRex err
    : args    < traverseRow (x k & readSire x err k) argsRex
    # datacase fHead
    * (LEFT func) | ok | ELIN func args
    * (RIGHT exp) | ok | foldl EAPP exp args
* '&'
    @ kids (rexKids rex)
    | if (len kids /= 2) (err rex 'Bad lambda')
    @ [sigRex bodRex] kids
    : pats <- readBindSig sigRex err
    : body <- readSire bodRex err
    | ok | ELAM FALSE | FUN 0 0 pats body
* '?'
    @ kids@[sigRex bodRex] (rexKids rex)
    | if (len kids /= 2) (err rex 'Bad lambda.')
    : func pats <- readDestroyer sigRex err
    : body <- readSire bodRex err
    | ok (ELAM FALSE | FUN func func pats body)
* ','
    : exps <- traverseRow (x k & readSire x err k) (rexKids rex)
    | ok (EROW exps)
* '@'  | parseLet readSire rex err ok
* '@@' | parseRec readSire rex err ok
* '#'  | parseHax readSire rex err ok
* _
    | err rex (strWeld 'Unknown rune: ' rune)

; Assumes that the input formatting matches the printers formatting.
= (sireRound rex)
@ out (readSire rex v2 showSire)
| if (rexEql rex out) 1
| out

!! sireRound ` x
!! sireRound ` 0
!! sireRound ` (f x y)
!! sireRound ` (**f x y)
!! sireRound ` (x & x)
!! sireRound ` (x y & x)
!! sireRound ` (id x ? x)
!! sireRound ` (const x y ? x)
!! sireRound ` (x @ 3)(x x x)
!! sireRound ` (x @@ 3)x
!! sireRound ` (^ f _ y)x
!! sireRound ` (x @ [1 2])[x x]
!! sireRound ` ([x y] @ [1 2])[y x]
!! sireRound ` (z@[!x y] @ [1 2])(x y z)

!!= ` (span f r ? (l @ len r)(^ _ 0)(loop i ? if (eql i l) (v2 r v0) (if (f (idx i r)) (loop (inc i)) (v2 (take i r) (drop i r)))))
  ^ readSire _ v2 showSire
  ` ? (span f r)
    @ l | len r
    ^ _ 0
    ? (loop i)
    | if (eql i l) (v2 r v0)
    | if (f (idx i r))
        | loop (inc i)
    (v2 (take i r) (drop i r))

!!= `((# datacase a)(* NONE 0)(* (SOME x) x))
  ^ readSire _ v2 showSire
  ` # datacase a
    * NONE     0
    * (SOME x) x

!!= `((# datacase a)(* NONE 0)(* _ 1))
  ^ readSire _ v2 showSire
  ` # datacase a
    * NONE     0
    * _        1


""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^ EBED EREF ENAT EAPP EKET ELET EREC ELAM ELIN ECAS
^-^
^-^ readSire showSire
