"""
""" Datom
""" =====
"""
""" Embeddable Entity/Attribute/Value datastore.
"""

""" Imports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

/+  boot
/+  hitch
/+  switch    ["#switch"]
/+  datatype  ["#record" "#datatype" "#datacase"]
/+  mutrec

;; for v0, all trees are Tabs and Cabs, not hitch stuff. doing all the hitch
;; stuff will require adding a `Multimap a b c -> Map a (Map b (MapSet c))`
;; typw.

# datatype Error
* LOOKUP_NO_ATTRIBUTE attrName:Any
* LOOKUP_ATTRIBUTE_NOT_UNIQUE attrName:Any
* LOOKUP_NO_MATCH attrName:Any val:Any

;; The toplevel DB type.
;;
;; for v0, all tables are (Tab Any (Tab Any (Cab Any))).
# record Db
| DB
* eav    : Any
* aev    : Any
* ave    : Any
* maxEid : Nat
; rschema

; raw operation to add a resolved tuple to the database
= (rawAdd e a v indexed many db)
# openDb db
; only usable for tuples which end in [v] (eav, aev)
@ (alterEndVal c in)
  | *SOME
  : cab <- *maybeCase in (cabSingleton c)
  | if many | cabIns c cab
  | cabSingleton c
; only usable for tuples whose middle is not v (eav, aev)
@ (alterNotVal b c in)
  | *SOME
  : tab <- *maybeCase in
              | tabSingleton b
              | cabSingleton c
  | tabAlter (alterEndVal c) b tab
; only usable for tuples whose middle IS v (ave)
@ (alterEndNonV c in)
  | *SOME
  : cab <- *maybeCase in (cabSingleton c)
  | cabIns c cab
; only usable for tuples whose middle IS v (ave)
@ (alterMiddleV b c in)
  | *SOME
  : tab <- *maybeCase in
              | tabSingleton b
              | cabSingleton c
  | tabAlter (alterEndNonV c) b tab
@ eav | tabAlter (alterNotVal a v) e eav
@ aev | tabAlter (alterNotVal e v) a aev
@ ave
  | ifNot indexed ave
  | tabAlter (alterMiddleV v e) a ave
| DB eav aev ave maxEid

; raw remove
= (rawRm e a v many db)
; TODO: obey `many`.
# openDb db
@ (alter2 c in)
  : cab <- *maybeCase in NONE
  @ rmed | cabDel c cab
  | if (cabIsEmpty rmed) NONE
  | *SOME rmed
@ (alter b c in)
  : tab <- *maybeCase in NONE
  @ rmed | tabAlter (alter2 c) b tab
  | if (tabIsEmpty rmed) NONE
  | *SOME rmed
@ eav | tabAlter (alter a v) e eav
@ aev | tabAlter (alter e v) a aev
; always try to purge values from the ave table; the user might have changed
; the value of :db/unique between add and retract.
@ ave | tabAlter (alter v e) a ave
| DB eav aev ave maxEid

= dbIdentId 0
= dbIdentStr ":db/ident"
= dbCardinalityId 1
= dbCardinalityStr ":db/cardinality"
= dbUniqueId 2
= dbUniqueStr ":db/unique"
= dbIndexedId 3
= dbIndexedStr ":db/indexed"

= emptyDB
@ db
  @ eav    %[]
  @ aev    %[]
  @ ave    %[]
  ; todo: add vae table when I implement :db/ref.
  @ maxEid 4
  | DB eav aev ave maxEid
; an "empty" db still needs to have some "built-in" tuples to allow for
; attribute resolution. each attribute still has an eid.
;
; :db/ident is the name identity of an attribute. in the eav tuple
; `[5 ":my/attr" "str"], we will first do an attribute/value lookup on
; [":db/ident" ":my/attr"] and will use the entity number in storage.
;
; TODO: Must validate that incoming data type is a cord when I add value types.
| rawAdd dbIdentId dbIdentId dbIdentStr TRUE TRUE
| rawAdd dbIdentId dbUniqueId TRUE TRUE TRUE
;
; :db/unique is whether values for this attribute must be unique. It defaults
; to false. When true, and a transaction attempts to commit an already existing
; value, errors to the user.
| rawAdd dbUniqueId dbIdentId dbUniqueStr TRUE TRUE
;
; :db/indexed is whether values for this attribute are indexed, ie, whether you
; can look up an eid by their attribute and value. :db/unique implies
; :db/indexed.
| rawAdd dbIndexedId dbIdentId dbIndexedStr TRUE TRUE
;
; :db/cardinality is "one" or "many". When adding a tuple whose attribute has
; cardinality "one", the value is overwritten. When "many", multiple values
; accumulate.
;
; TODO: validate the values "one" or "many" once I implement :db/attr.preds.
| rawAdd dbCardinalityId dbIdentId dbCardinalityStr TRUE TRUE
db

;; Resolved transaction changes
# datatype TxOper
* RESADD entityId:Any attr:Any val:Any indexed:Any many:Any
* RESRETRACT entityId:Any attr:Any val:Any many:Any

# datatype Ident
; Specific numeric entity
* ENT entityId:Any
; New entity referred to multiple times by this value
* TMP val:Any
; Entity id based on an attribute lookup.
* LOOKUP attr:Any val:Any

;; Transaction items
# datatype TxnItem
; Creates a new entity and adds the contents of the tab as a list of e
* NEWENTITY tab:Any
; Adds a specific
* ADD ident:Any attr:Any val:Any
; Retracts a specific datom
* RETRACT eid:Any attr:Any val:Any

; Return a new entity id and record the new max in the database.
= (allocEntity db)
# openDb db
[maxEid [eav aev ave (inc maxEid)]]

; Passes the single item to `gud` or runs `bad`.
= (fromSingletonCab opt bad gud)
| if (neq 1 | cabLen opt) bad
| *gud (cabFirst opt)

= (singletonCabDefault opt missing next)
| *next
| if (neq 1 | cabLen opt) missing
| cabFirst opt

; Internal functions on
= (lookupByEidAid eid aid db)
# openDb db
: av <- *maybeCase (tabLookup eid eav) %[]
: v  <- *maybeCase (tabLookup aid av) %[]
v

= (lookupByAidEid aid eid db)
# openDb db
: ev <- *maybeCase (tabLookup aid aev) %[]
: v  <- *maybeCase (tabLookup eid ev) %[]
v

= (lookupByAidV aid val db)
# openDb db
: ve <- *maybeCase (tabLookup aid ave) %[]
: e  <- *maybeCase (tabLookup val ve) %[]
e

; Given a user level attribute name, translate that to a numeric attribute
; number and an 'indexed' boolean which is whether we can use the ave table to
; lookup data related to this attribute.
;
> Str > DB > Either Error [Nat Bool Bool Bool]
= (resolveAttrName attrName db)
@ attrsCab | lookupByAidV dbIdentId attrName db
: attrEid <- *fromSingletonCab attrsCab
               | *LEFT | *LOOKUP_NO_ATTRIBUTE attrName
@ isIndex
  @ attrIndexed | lookupByAidEid dbIndexedId attrEid db
  : indexed <- *singletonCabDefault attrIndexed FALSE
  indexed
@ isUnique
  @ attrUniq    | lookupByAidEid dbUniqueId attrEid db
  : uniq    <- *singletonCabDefault attrUniq FALSE
  uniq
@ isMany
  @ attrMany | lookupByAidEid dbCardinalityId attrEid db
  : many <- *singletonCabDefault attrMany "many"
  # switch many
  * one  FALSE
  * many TRUE
  * _    | 'unknown many value: ' many
| *RIGHT [attrEid isIndex isUnique isMany]

; User level manual lookup
= (lookupByEA eid attr db)
: aid <- *fromSingletonCab (lookupByAidV dbIdentId attr db)
           | 'unknown attr' attr
| lookupByEidAid eid aid db

= (lookupByAE attr eid db)
: aid <- *fromSingletonCab (lookupByAidV dbIdentId attr db)
           | 'unknown attr' attr
| lookupByAidEid aid eid db

= (lookupByAV attr val db)
# datacase (resolveAttrName attr db)
* (LEFT errs) | 'could not lookup. errors: ' errs
* (RIGHT [aid indexed unique _])
  | ifNot (or indexed unique) | 'cannot lookup unindexed attr/val' attr
  | lookupByAidV aid val db

> Any > Any > Nat > DB > Cab Nat
= (lookupByIdentA identAttr identVal attr db)
# datacase | resolveAttrName identAttr db
* (LEFT err) | 'could not lookup. error: ' err
* (RIGHT [aid _ unique _])
  | ifNot unique | 'cannot lookup unindexed attribute ' identAttr
  @ eidCab | lookupByAidV aid identVal db
  : eid <- *fromSingletonCab eidCab | 'invalid eid for aid?! ' aid
  | lookupByEA eid attr db

; Given a user level entity identity, translate that to a numeric database
; identity.
;
> Ident > (Map Any Nat) > DB > Either Error [Nat (Map Any Nat) DB]
= (resolveIdent ident txnTmps db)
# openDb db
# datacase ident
* (ENT eid)
  | *RIGHT
  ,, eid
  ,, txnTmps
  ,, | if (lth eid maxEid) db
     ; user has specified a larger eid than exists by hand.
     [eav aev ave (inc eid)]
* (TMP val)
  | *RIGHT
  : eid <- maybeCase (tabLookup val txnTmps)
             @ [eid db] | allocEntity db
             [eid (tabMut val eid txnTmps) db]
  [eid txnTmps db]
* (LOOKUP attrName val)
  # datacase | resolveAttrName attrName db
  * (LEFT err) | *LEFT err
  * (RIGHT [aid _ unique _])
    | trk [%lookup attrName aid unique]
    | ifNot unique
      | *LEFT | *LOOKUP_ATTRIBUTE_NOT_UNIQUE attrName
    @ eids | lookupByAidV aid val db
    @ l | cabLen eids
    | if (isZero l)
      | *LEFT | *LOOKUP_NO_MATCH attrName val
    | *RIGHT
    [(cabFirst eids) txnTmps db]

; Given input items, assign numeric entity ids to everything for loading into
; the actual db.
;
> [(List Err) (List TxnItem) (Map Any Nat) DB]
> TxnItem
> [(List Err) (List TxnItem) (Map Any Nat) DB]
= (resolveTransactionItem [errs items txnTmps db] item)
# datacase item
* (NEWENTITY tab)
  @ [eid db] | allocEntity db
  @ [newErrs newItems]
    ^ foldl _ [NIL NIL] | tabToPairs tab
    & ([errs items] [attrName v])
    # datacase | resolveAttrName attrName db
    * (LEFT err) [(*CONS err errs) items]
    * (RIGHT [aid indexed unique many])
        @ writeAve | or indexed unique
        [errs (*CONS (RESADD eid aid v writeAve many) items)]
  [(listWeld newErrs errs) (listWeld newItems items) txnTmps db]
* (ADD ident attr val)
  # datacase | resolveIdent ident txnTmps db
  * (LEFT err) (*CONS err errs, items, txnTmps, db)
  * (RIGHT [eid txnTmps db])
    # datacase | resolveAttrName attr db
    * (LEFT err) (*CONS err errs, items, txnTmps, db)
    * (RIGHT [aid indexed unique many])
      @ writeAve | or indexed unique
      [errs (*CONS (RESADD eid aid val writeAve many) items) txnTmps db]
* (RETRACT eid attr val)
  # datacase | resolveAttrName attr db
  * (LEFT err) (*CONS err errs, items, txnTmps, db)
  * (RIGHT [aid indexed unique many])
    [errs (*CONS (RESRETRACT eid attr val) items) txnTmps db]

; User transaction function. Given transaction items, resolve any pending
; entity numbers in them and then apply them to the database.
;
> Row TxnItem > DB > (Either (Row Error) DB)
= (transact items db)
@ [errs resolved _ db]
  | foldl resolveTransactionItem [NIL NIL %[] db] items
| ifNot (listNull errs) | *LEFT | listToRow errs
| *RIGHT
^ listFoldl _ db resolved
& (db item)
# datacase item
* (RESADD eid attr val indexed many)
  | rawAdd eid attr val indexed many db
* (RESRETRACT eid attr val many)
  | rawRm eid attr val many db

> Row TxnItem > DB > DB
= (assertTransact items db)
# datacase (transact items db)
* (LEFT l)  | 'transaction failed: ' l
* (RIGHT r) r

""" Tests """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= postDB
^ assertTransact _ emptyDB
,, | NEWENTITY %[":db/ident"=":b/post" ":db/cardinality"="one"]
,, | NEWENTITY %[":db/ident"=":b/author" ":db/cardinality"="one"]
,, | NEWENTITY %[":db/ident"=":b/title" ":db/cardinality"="one"]

; Check that NEWENTITY and ADD forms are equivalent.
!!=     ^ assertTransact _ postDB
        ,, | ADD (TMP "newpost") ":b/post" "mai poast"
        ,, | ADD (TMP "newpost") ":b/author" "Iceman"
        ,, | ADD (TMP "other") ":b/post" "Other post"
        ,, | ADD (TMP "other") ":b/author" "Sol"
   ^ assertTransact _ postDB
   ,, | NEWENTITY %[":b/post"="mai poast" ":b/author"="Iceman"]
   ,, | NEWENTITY %[":b/post"="Other post" ":b/author"="Sol"]

= emptyContactsDB
^ assertTransact _ emptyDB
,, | NEWENTITY %% =":db/ident" ":c/name"
               %% =":db/indexed" TRUE
               %% =":db/cardinality" "one"
               %% =":db/unique" TRUE
; In this contrived testing scenario, you can have many emails, but only one
; phone number and that phone number can be shared between people.
,, | NEWENTITY %% =":db/ident" ":c/email"
               %% =":db/unique" TRUE
               %% =":db/cardinality" "many"
,, | NEWENTITY %% =":db/ident" ":c/phone"
               %% =":db/indexed" TRUE
               %% =":db/unique" FALSE
               %% =":db/cardinality" "one"

= contactsDB
  ^ assertTransact _ emptyContactsDB
  ,, | NEWENTITY %[":c/name"="Iceman" ":c/email"="iceman@plunder.tech"]
  ,, | NEWENTITY %[":c/name"="Sol" ":c/email"="sol@plunder.tech"]

; Lookup by nonexistent attributes fail.
!!=   | LEFT [(LOOKUP_NO_ATTRIBUTE ":d/blah")]
    ^ transact _ emptyContactsDB
    ,, | ADD (LOOKUP ":d/blah" "51") ":c/email" "blah@plunder.tech"

; Lookup by nonexistent values fail.
!!=   | LEFT [(LOOKUP_NO_MATCH ":c/name" "Bob")]
    ^ transact _ emptyContactsDB
    ,, | ADD (LOOKUP ":c/name" "Bob") ":c/email" "bob@plunder.tech"

; NEWENTITY with nonexistent attributes fails.
!!=   | LEFT [(LOOKUP_NO_ATTRIBUTE ":bad/b") (LOOKUP_NO_ATTRIBUTE ":bad/a")]
    ^ transact _ emptyContactsDB
    ,, | NEWENTITY %[":bad/a"="bad" ":bad/b"="bad"]

; ADD with nonexistent attributes fails.
!!=   | LEFT [(LOOKUP_NO_ATTRIBUTE ":bad/a")]
    ^ transact _ emptyContactsDB
    ,, | ADD (ENT 5) ":bad/a" "bad"

; If we try set the contacts up so you can reference entities by their email,
; we should be able to set someone's phone number by their email.
= phoneDB
  ^ assertTransact _ contactsDB
  ,, | ADD (LOOKUP ":c/email" "iceman@plunder.tech") ":c/phone" "(555) 555"

!!=     %["(555) 555"]
    | lookupByIdentA ":c/email" "iceman@plunder.tech" ":c/phone" phoneDB

; Can't lookup by non-unique attributes:
!!=    | LEFT [(LOOKUP_ATTRIBUTE_NOT_UNIQUE ":c/phone")]
    ^ transact _ phoneDB
    ,, | ADD (LOOKUP ":c/phone" "(555) 555") ":c/email" "other@plunder.tech"

; For cardinality one attributes, setting the attribute twice should change the
; singular attribute value.
= changedPhoneDB
  ^ assertTransact _ contactsDB
  ,, | ADD (LOOKUP ":c/email" "iceman@plunder.tech") ":c/phone" "(111) 111"

!!=     %["(111) 111"]
    | lookupByIdentA ":c/email" "iceman@plunder.tech" ":c/phone" changedPhoneDB

; Cardinality many interacts with the ave table: make sure in cardinality one
; scenarios, the old value isn't retrievable from the ave table.
!!=     %[]
    | lookupByAV ":c/phone" "(555) 555" changedPhoneDB

= changedEmailDB
  ^ assertTransact _ contactsDB
  ,, | ADD (LOOKUP ":c/email" "iceman@plunder.tech") ":c/email"
           "alias@example.com"

; For cardinality many attributes, setting the attribute twice should add
; another value.
!!=     %["iceman@plunder.tech" "alias@example.com"]
    | lookupByIdentA ":c/email" "iceman@plunder.tech" ":c/email" changedEmailDB

; We should be able to lookup an entity by indexed attribute.
!!=   %[7]
    | lookupByAV ":c/name" "Iceman" contactsDB

; TODO: Once we return errors instead of just dying on exceptions, also
;
; - validate uniqueness during a new validation pass.

; TODO: Retraction is entirely untested and might not work. Pound on that code
; path with tests.

""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^
^-^ DB emptyDB
^-^
^-^ ENT TMP LOOKUP
^-^ NEWENTITY ADD RETRACT
^-^
^-^ lookupByEA lookupByAE lookupByAV transact

