"""
""" Datom
""" =====
"""
""" Embeddable Entity/Attribute/Value datastore.
"""

""" Imports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

/+  boot
/+  hitch
/+  switch    ["#switch"]
/+  datatype  ["#record" "#datatype" "#datacase"]
/+  mutrec

;; for v0, all trees are Tabs and Cabs, not hitch stuff. doing all the hitch
;; stuff will require adding a `Multimap a b c -> Map a (Map b (MapSet c))`
;; typw.

# datatype Error
* UNIQUE_VIOLATION attrName:Any attrVal:Any oldEid:Nat newEid:Nat
* LOOKUP_NO_ATTRIBUTE attrName:Any
* LOOKUP_ATTRIBUTE_NOT_UNIQUE attrName:Any
* LOOKUP_NO_MATCH attrName:Any val:Any
;
* INVALID_ROW row:(Row Any)
* INVALID_ROW_OP op:Any
;
* BAD_MAP_VAL val:Any

;; The toplevel DB type.
;;
;; for v0, all tables are (Tab Any (Tab Any (Cab Any))).
# record Db
| DB
* eav    : Any
* aev    : Any
* ave    : Any
* vae    : Any
* maxEid : Nat
; rschema

; raw operation to add a resolved tuple to the database
= (rawAdd e a v writeAve many isRef db)
;| trk [%rawAdd e a v writeAve many isRef db]
# openDb db
; only usable for tuples which end in [v] (eav, aev)
@ (alterEndVal c in)
  | *SOME
  : cab <- *maybeCase in (cabSingleton c)
  | if many | cabIns c cab
  | cabSingleton c
; only usable for tuples whose middle is not v (eav, aev)
@ (alterNotVal b c in)
  | *SOME
  : tab <- *maybeCase in
              | tabSingleton b
              | cabSingleton c
  | tabAlter (alterEndVal c) b tab
; only usable for tuples whose middle IS v (ave)
@ (alterEndNonV c in)
  | *SOME
  : cab <- *maybeCase in (cabSingleton c)
  | cabIns c cab
; only usable for tuples whose middle IS v (ave)
@ (alterMiddleEndNonV b c in)
  | *SOME
  : tab <- *maybeCase in
              | tabSingleton b
              | cabSingleton c
  | tabAlter (alterEndNonV c) b tab
@ eav | tabAlter (alterNotVal a v) e eav
@ aev | tabAlter (alterNotVal e v) a aev
@ ave
  | ifNot writeAve ave
  | tabAlter (alterMiddleEndNonV v e) a ave
@ vae
  | ifNot isRef vae
  | tabAlter (alterMiddleEndNonV a e) v vae
| DB eav aev ave vae maxEid

; raw remove
= (rawRm e a v db)
# openDb db
@ (alter2 c in)
  : cab <- *maybeCase in NONE
  @ rmed | cabDel c cab
  | if (cabIsEmpty rmed) NONE
  | *SOME rmed
@ (alter b c in)
  : tab <- *maybeCase in NONE
  @ rmed | tabAlter (alter2 c) b tab
  | if (tabIsEmpty rmed) NONE
  | *SOME rmed
@ eav | tabAlter (alter a v) e eav
@ aev | tabAlter (alter e v) a aev
; always try to purge values from the ave table; the user might have changed
; the value of :db/unique between add and retract.
@ ave | tabAlter (alter v e) a ave
| DB eav aev ave vae maxEid

= dbIdentId 0
= dbIdentStr ":db/ident"
= dbCardinalityId 1
= dbCardinalityStr ":db/cardinality"
= dbUniqueId 2
= dbUniqueStr ":db/unique"
= dbIndexedId 3
= dbIndexedStr ":db/indexed"
= dbValueTypeId 4
= dbValueTypeStr ":db/valueType"

= dbIdId 100  ; TODO: should be 0
= dbIdStr ":db/id"

= emptyDB
@ db
  @ eav    %[]
  @ aev    %[]
  @ ave    %[]
  @ vae    %[]
  @ maxEid 5
  | DB eav aev ave vae maxEid
@ (baseAdd e a v db)
  | rawAdd e a v TRUE TRUE FALSE db
; an "empty" db still needs to have some "built-in" tuples to allow for
; attribute resolution. each attribute still has an eid.
;
; :db/ident is the name identity of an attribute. in the eav tuple
; `[5 ":my/attr" "str"], we will first do an attribute/value lookup on
; [":db/ident" ":my/attr"] and will use the entity number in storage.
;
; TODO: Must validate that incoming data type is a cord when I add value types.
| baseAdd dbIdentId dbIdentId dbIdentStr
| baseAdd dbIdentId dbUniqueId TRUE
;
; :db/unique is whether values for this attribute must be unique. It defaults
; to false. When true, and a transaction attempts to commit an already existing
; value, errors to the user.
| baseAdd dbUniqueId dbIdentId dbUniqueStr
;
; :db/indexed is whether values for this attribute are indexed, ie, whether you
; can look up an eid by their attribute and value. :db/unique implies
; :db/indexed.
| baseAdd dbIndexedId dbIdentId dbIndexedStr
;
; :db/cardinality is "one" or "many". When adding a tuple whose attribute has
; cardinality "one", the value is overwritten. When "many", multiple values
; accumulate.
;
; TODO: validate the values "one" or "many" once I implement :db/attr.preds.
| baseAdd dbCardinalityId dbIdentId dbCardinalityStr
;
; :db/valueType is a string describing the type. For now, the values are nat,
; any and ref.
| baseAdd dbValueTypeId dbIdentId dbValueTypeStr
db

# datatype EntIdent
; Specific numeric entity
* ENT entityId:Any
; New entity referred to multiple times by this value
* TMP val:Any
; Entity id based on an attribute lookup.
* LOOKUP attr:Any val:Any

# datatype TxnAction
* ACTADD eid:Nat aid:Nat attrName:Any val:Any writeAve:Bool unique:Bool
         many:Bool isRef:Bool
* ACTRM  eid:Any aid:Any val:Any

; Return a new entity id and record the new max in the database.
> DB > [Nat DB]
= (allocEntity db)
# openDb db
,, maxEid
,, | DB eav aev ave vae (inc maxEid)

; Passes the single item to `gud` or runs `bad`.
= (fromSingletonCab opt bad gud)
| if (neq 1 | cabLen opt) bad
| *gud (cabFirst opt)

= (singletonCabDefault opt missing next)
| *next
| if (neq 1 | cabLen opt) missing
| cabFirst opt

; Internal functions on
= (lookupByEidAid eid aid db)
# openDb db
: av <- *maybeCase (tabLookup eid eav) %[]
: v  <- *maybeCase (tabLookup aid av) %[]
v

= (lookupByAidEid aid eid db)
# openDb db
: ev <- *maybeCase (tabLookup aid aev) %[]
: v  <- *maybeCase (tabLookup eid ev) %[]
v

= (lookupByAidV aid val db)
# openDb db
: ve <- *maybeCase (tabLookup aid ave) %[]
: e  <- *maybeCase (tabLookup val ve) %[]
e

= (lookupByVAid val aid db)
# openDb db
: ae <- *maybeCase (tabLookup val vae) %[]
: e  <- *maybeCase (tabLookup aid ae) %[]
e

; Given a user level attribute name, translate that to a numeric attribute
; number and an 'indexed' boolean which is whether we can use the ave table to
; lookup data related to this attribute.
;
> Str > DB > Either Error [Nat Bool Bool Bool Bool]
= (resolveAttrName attrName db)
;| trk [%resolve attrName]
@ attrsCab | lookupByAidV dbIdentId attrName db
: attrEid <- *fromSingletonCab attrsCab
               | *LEFT | *LOOKUP_NO_ATTRIBUTE attrName
@ isIndex
  @ attrIndexed | lookupByAidEid dbIndexedId attrEid db
  : indexed <- *singletonCabDefault attrIndexed FALSE
  indexed
@ isUnique
  @ attrUniq    | lookupByAidEid dbUniqueId attrEid db
  : uniq    <- *singletonCabDefault attrUniq FALSE
  uniq
@ isMany
  @ attrMany | lookupByAidEid dbCardinalityId attrEid db
  : many <- *singletonCabDefault attrMany "many"
  # switch many
  * one  FALSE
  * many TRUE
  * _    | 'unknown many value: ' many
@ isRef
  @ attrValType | lookupByAidEid dbValueTypeId attrEid db
  : t <- *singletonCabDefault attrValType "any"
  # switch t
  * ref TRUE
  * _   FALSE
| *RIGHT [attrEid isIndex isUnique isMany isRef]

; User level manual lookup
= (lookupByEA eid attr db)
: aid <- *fromSingletonCab (lookupByAidV dbIdentId attr db)
           | 'unknown attr' attr
| lookupByEidAid eid aid db

= (lookupByAE attr eid db)
: aid <- *fromSingletonCab (lookupByAidV dbIdentId attr db)
           | 'unknown attr' attr
| lookupByAidEid aid eid db

= (lookupByAV attr val db)
# datacase (resolveAttrName attr db)
* (LEFT errs) | 'could not lookup. errors: ' errs
* (RIGHT [aid indexed unique _])
  | ifNot (or indexed unique) | 'cannot lookup unindexed attr/val' attr
  | lookupByAidV aid val db

= (lookupByVA val attr db)
# datacase (resolveAttrName attr db)
* (LEFT errs) | 'could not lookup. errors: ' errs
* (RIGHT [aid _ _ _ ref])
  | ifNot ref | 'cannot lookup non-ref values' attr
  | lookupByVAid val aid db

> Any > Any > Nat > DB > Cab Nat
= (lookupByIdentA identAttr identVal attr db)
# datacase | resolveAttrName identAttr db
* (LEFT err) | 'could not lookup. error: ' err
* (RIGHT [aid _ unique _])
  | ifNot unique | 'cannot lookup unindexed attribute ' identAttr
  @ eidCab | lookupByAidV aid identVal db
  : eid <- *fromSingletonCab eidCab | 'invalid eid for aid?! ' aid
  | lookupByEA eid attr db


""" User Transact Parsing """"""""""""""""""""""""""""""""""""""""""""""""""""""

; Resolve a lookup ref into an eid or error.
;
;> Str > Any > DB > Either Error Nat
= (performLookup attrName val db)
  # datacase | resolveAttrName attrName db
  * (LEFT err) | *LEFT err
  * (RIGHT [aid _ unique _ _])
    | ifNot unique
      | *LEFT | *LOOKUP_ATTRIBUTE_NOT_UNIQUE attrName
    @ eids | lookupByAidV aid val db
    @ l | cabLen eids
    | if (isZero l)
      | *LEFT | *LOOKUP_NO_MATCH attrName val
    | *RIGHT | cabFirst eids

; Immediately resolves an entity to a numeric entity id.
;
; 5               -> RIGHT [5 ...]
; [":b/first" 5]  -> RIGHT [9 ...] (assuming underlying LOOKUP succeeds)
; [":b/second" 6] -> LEFT err (assuming lookup fails)
; %["tmpid"]      -> RIGHT [2 ...] (assigns a tmpid and adds it to the map)
;
;> Map Str Nat > DB > Any > Either Error [Nat (Map Str Nat) DB]
= (parseEntityId txnTmpIds db i)
  | if (isNat i)
    | *RIGHT [i txnTmpIds db]
  | if (and (isRow i) (eql 2 | len i))
    # datacase | performLookup (idx 0 i) (idx 1 i) db
    * (LEFT l)    | *LEFT l
    * (RIGHT eid) | *RIGHT [eid txnTmpIds db]
  ; temporarily, we're going to wrap temporary identifiers in cabs for ease of
  ; typing
  | if | rowAnd ,, isCab i
                ,, eql 1 | cabLen i
                ,, isNat | cabFirst i
    @ val | cabFirst i
    : eid <- maybeCase (tabLookup val txnTmpIds)
               @ [eid db] | allocEntity db
               | *RIGHT [eid (tabMut val eid txnTmpIds) db]
    | *RIGHT [eid txnTmpIds db]
  | *LEFT "Couldn't parse"

; Given a map, parse it into a series of actions and return the numeric eid
; parsed or assigned.
;
; We have to perform all numeric entity resolution immediately since we want to
; pass the eid upwards to participate in other parts of the transaction.
;
> DB > Tab Any Any > [(Maybe Nat) [Error] [TxnAction] (Tab Any Any) DB]
= (parseMapForm txnTmpIds db tab)
  ; if there's a :db/id, than use that. But if there's not, we have to assign a
  ; new temporary id.
  @ eitherEident
    : entVal <- *maybeCase (tabLookup dbIdStr tab)
                  @ [eid db] | allocEntity db
                  | *RIGHT [eid txnTmpIds db]
    | parseEntityId txnTmpIds db entVal
  ;
  # datacase eitherEident
  * (LEFT l)
    [NONE (*LEFT | *CONS l NIL) NIL txnTmpIds db]
  * (RIGHT [eid txnTmpIds db])
    | rowCons (SOME eid)
    ^ foldl _ [NIL NIL txnTmpIds db] | tabToPairs | tabDel dbIdStr tab
    & ([errs actions txnTmpIds db] [aVal vVal])
    ;
    # datacase (resolveAttrName aVal db)
    * (LEFT err)
      [(*CONS err errs) actions db]
    * (RIGHT [aid indexed unique isMany isRef])
      @ writeAve | or indexed unique
      | if isRef
        ; TODO: This is super complex code. It's ugly, it's long, and I don't
        ; know how to effectively factor this in sire.
        | if (rowAnd [isMany (not | isCab vVal) (isRow vVal)])
          ; we have a list here, each value needs to be treated as a map form.
          @ [suberrs subactions subeids txnTmpIds db]
            ^ foldl _ [NIL NIL NIL txnTmpIds db] vVal
            & ([errs actions eids txnTmpIds db] i)
            | ifNot | isTab i
              ,, (*CONS (BAD_MAP_VAL i) errs)
              ,, actions
              ,, eids
              ,, txnTmpIds
              ,, db
            ; we need to reparse map errors
            @ [mybEid suberrs subactions txnTmpIds db]
              | parseMapForm txnTmpIds db i
            ,, | listWeld suberrs errs
            ,, | listWeld subactions actions
            ,, : eid <- *maybeCase mybEid eids
               | *CONS eid eids
            ,, txnTmpIds
            ,, db
          ; at this point, we have a list of our subeids or errors.
          | ifNot (listNull errs)
            ,, (listWeld suberrs errs)
            ,, actions
            ,, txnTmpIds
            ,, db
          @ newActions
            ^ listMap _ subeids
            & subeid
            (ACTADD eid aid aVal subeid writeAve unique isMany isRef)
          ,, errs
          ,, (listWeld newActions | listWeld subactions actions)
          ,, txnTmpIds
          ,, db
        ; we have one value.
        # datacase | parseEntityId txnTmpIds db vVal
        * (LEFT err)
          ,, (*CONS err errs)
          ,, actions
          ,, txnTmpIds
          ,, db
        * (RIGHT [rightEid txnTmpIds db])
          ,, errs
          ,, | *CONS (ACTADD eid aid aVal rightEid writeAve unique isMany isRef)
                     actions
          ,, txnTmpIds
          ,, db
      | if isMany
        ; many, but not references. So if this is a row, parse each item as a
        ; value, otherwise
        | if | isRow vVal
          | trk [%isManyRowCase]
          | 'todo: isMany case' aid
        ,, errs
        ,, | *CONS (ACTADD eid aid aVal vVal writeAve unique isMany isRef)
                   actions
        ,, txnTmpIds
        ,, db
      ; sometimes a val is just a val
      ,, errs
      ,, | *CONS (ACTADD eid aid aVal vVal writeAve unique isMany isRef)
                 actions
      ,, txnTmpIds
      ,, db

;
;> DB > Tab Any Any > [[Error] [TxnAction] (Tab Any Any) DB]
= (parseListForm txnTmpIds db row)
  ; rows are a tuple of [op espec attr val]
  | ifNot | eql 4 | len row
    ,, (*CONS (INVALID_ROW row) NIL)
    ,, NIL
    ,, txnTmpIds
    ,, db
  @ op | idx 0 row
  | if | and | neq %add op
             | neq %rm op
    ,, (*CONS (INVALID_ROW_OP op) NIL)
    ,, NIL
    ,, txnTmpIds
    ,, db
  # datacase | parseEntityId txnTmpIds db (idx 1 row)
  * (LEFT err)
    ,, (*CONS err NIL)
    ,, NIL
    ,, txnTmpIds
    ,, db
  * (RIGHT [eid txnTmpIds db])
    ; todo: in list form, attr is not just an attrName, but can also be a raw
    ; eid or a lookupref. we completely punt on this: it should be easy to add
    ; back later when there's a more complete type system and we aren't going
    ; to use this for now.
    @ attrName | idx 2 row
    # datacase (resolveAttrName attrName db)
    * (LEFT err)
      [(*CONS err NIL) NIL txnTmpIds db]
    * (RIGHT [aid indexed unique isMany isRef])
      @ writeAve | or indexed unique
      ; In list form, we don't do arity resolution. We treat the value
      ; literally.
      @ val | idx 3 row
      | if (eql op %rm)
        ,, NIL
        ,, | *CONS | ACTRM eid aid val
        ,, txnTmpIds
        ,, db
      ,, NIL
      ,, | *CONS (ACTADD eid aid attrName val writeAve unique isMany isRef)
                 NIL
      ,, txnTmpIds
      ,, db

; Given a user-level structure of rows and tabs, parse it into a series of adds
; and retracts.
;
; Parsing depends on a database value because the query has attributes in it
; and we have to lookup the properties of those attributes to know how to parse
; them.
;
> DB > Any > [[Error] [TxnAction] (Tab Any Any) DB]
= (parseItem txnTmpIds db item)
  | if (isTab item)
    | drop 1 | parseMapForm txnTmpIds db item
  | if (isRow item)
    | parseListForm txnTmpIds db item
  ;
  | *LEFT "1) What"

> DB > Row Any > Either [Error] [[TxnAction] DB]
= (parseAllItems db items)
  ^ foldl _ [NIL NIL %[] db] items
  & ([errs actions txnTmpIds db] i)
  @ [newErrs newActions txnTmpIds db] | parseItem txnTmpIds db i
  ,, | listWeld newErrs errs
  ,, | listWeld newActions actions
  ,, txnTmpIds
  ,, db

; User transaction function. Given transaction items, resolve any pending
; entity numbers in them and then apply them to the database.
;
> Row Any > DB > (Either (Row Error) DB)
= (transact items db)
@ [errs actions _ db] | parseAllItems db items
| ifNot (listNull errs) | *LEFT | listToRow errs
@ [errs newDB]
  ^ listFoldl _ [errs db] actions
  & ([errs db] item)
  # datacase item
  * (ACTADD eid aid attrName val writeAve unique many isRef)
    | ifNot unique
      ; simple case, cannot error
      [errs (rawAdd eid aid val writeAve many isRef db)]
    ;
    ; check for uniqueness violations.
    @ oldEidCab | lookupByAidV aid val db
    | if (cabIsEmpty oldEidCab)
      ; no previous value
      [errs (rawAdd eid aid val writeAve many isRef db)]
    ,, | *CONS (UNIQUE_VIOLATION attrName val (cabFirst oldEidCab) eid) errs
    ,, db
  * (ACTRM eid attr val)
    [errs (rawRm eid attr val db)]
| ifNot (listNull errs) | *LEFT | listToRow errs
| *RIGHT newDB

> Row TxnItem > DB > DB
= (assertTransact items db)
# datacase (transact items db)
* (LEFT l)  | 'transaction failed: ' l
* (RIGHT r) r

""" Tests """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= postDB
^ assertTransact _ emptyDB
,, %[":db/ident"=":b/post" ":db/cardinality"="one"]
,, %[":db/ident"=":b/author" ":db/cardinality"="one"]
,, %[":db/ident"=":b/title" ":db/cardinality"="one"]


; Check that map form and a list form of adds are equivalent.
!!=     ^ assertTransact _ postDB
        ,, [%add %["newpost"] ":b/post" "mai poast"]
        ,, [%add %["newpost"] ":b/author" "Iceman"]
        ,, [%add %["other"] ":b/post" "Other post"]
        ,, [%add %["other"] ":b/author" "Sol"]
   ^ assertTransact _ postDB
   ,, %[":b/post"="mai poast" ":b/author"="Iceman"]
   ,, %[":b/post"="Other post" ":b/author"="Sol"]

= emptyContactsDB
^ assertTransact _ emptyDB
,, %% =":db/ident" ":c/name"
   %% =":db/indexed" TRUE
   %% =":db/cardinality" "one"
   %% =":db/unique" TRUE
; In this contrived testing scenario, you can have many emails, but only one
; phone number and that phone number can be shared between people.
,, %% =":db/ident" ":c/email"
   %% =":db/unique" TRUE
   %% =":db/cardinality" "many"
,, %% =":db/ident" ":c/phone"
   %% =":db/indexed" TRUE
   %% =":db/unique" FALSE
   %% =":db/cardinality" "one"

= contactsDB
  ^ assertTransact _ emptyContactsDB
  ,, %[":c/name"="Iceman" ":c/email"="iceman@plunder.tech"]
  ,, %[":c/name"="Sol" ":c/email"="sol@plunder.tech"]

; Lookup by nonexistent attributes fail.
!!=   | LEFT [(LOOKUP_NO_ATTRIBUTE ":d/blah")]
    ^ transact _ emptyContactsDB
    ,, [%add [":d/blah" "51"] ":c/email" "blah@plunder.tech"]

; Lookup by nonexistent values fail.
!!=   | LEFT [(LOOKUP_NO_MATCH ":c/name" "Bob")]
    ^ transact _ emptyContactsDB
    ,, [%add [":c/name" "Bob"] ":c/email" "bob@plunder.tech"]

; NEWENTITY with nonexistent attributes fails.
!!=   | LEFT [(LOOKUP_NO_ATTRIBUTE ":bad/b") (LOOKUP_NO_ATTRIBUTE ":bad/a")]
    ^ transact _ emptyContactsDB
    ,, %[":bad/a"="bad" ":bad/b"="bad"]

; ADD with nonexistent attributes fails.
!!=   | LEFT [(LOOKUP_NO_ATTRIBUTE ":bad/a")]
    ^ transact _ emptyContactsDB
    ,, [%add 5 ":bad/a" "bad"]

; Transaction which tries to duplicate a unique value fail. (Tries to add sol's
; email to iceman's entity).
!!=    @ icemanEid | cabFirst
                   | lookupByAV ":c/email" "iceman@plunder.tech" contactsDB
       @ solEid    | cabFirst
                   | lookupByAV ":c/email" "sol@plunder.tech" contactsDB
       | *LEFT ,, | UNIQUE_VIOLATION ":c/email" "sol@plunder.tech"
                                     solEid icemanEid
    ^ transact _ contactsDB
    ,, [%add [":c/email" "iceman@plunder.tech"] ":c/email" "sol@plunder.tech"]

; If we try set the contacts up so you can reference entities by their email,
; we should be able to set someone's phone number by their email.
= phoneDB
  ^ assertTransact _ contactsDB
  ,, [%add [":c/email" "iceman@plunder.tech"] ":c/phone" "(555) 555"]

!!=     %["(555) 555"]
    | lookupByIdentA ":c/email" "iceman@plunder.tech" ":c/phone" phoneDB

; Can't lookup by non-unique attributes:
!!=    | LEFT [(LOOKUP_ATTRIBUTE_NOT_UNIQUE ":c/phone")]
    ^ transact _ phoneDB
    ,, [%add [":c/phone" "(555) 555"] ":c/email" "other@plunder.tech"]

; For cardinality one attributes, setting the attribute twice should change the
; singular attribute value.
= changedPhoneDB
  ^ assertTransact _ contactsDB
  ,, [%add [":c/email" "iceman@plunder.tech"] ":c/phone" "(111) 111"]

!!=     %["(111) 111"]
    | lookupByIdentA ":c/email" "iceman@plunder.tech" ":c/phone" changedPhoneDB

; Cardinality many interacts with the ave table: make sure in cardinality one
; scenarios, the old value isn't retrievable from the ave table.
!!=     %[]
    | lookupByAV ":c/phone" "(555) 555" changedPhoneDB

= changedEmailDB
  ^ assertTransact _ contactsDB
  ,, [%add [":c/email" "iceman@plunder.tech"] ":c/email" "alias@example.com"]

; For cardinality many attributes, setting the attribute twice should add
; another value.
!!=     %["iceman@plunder.tech" "alias@example.com"]
    | lookupByIdentA ":c/email" "iceman@plunder.tech" ":c/email" changedEmailDB

; Retract removes the data from the tables:
!!=     %[]
    | lookupByIdentA ":c/email" "iceman@plunder.tech" ":c/phone"
    ^ assertTransact _ phoneDB
    ,, [%rm [":c/email" "iceman@plunder.tech"] ":c/phone" "(555) 555"]

; We should be able to lookup an entity by indexed attribute.
!!=   %[8]
    | lookupByAV ":c/name" "Iceman" contactsDB


;; Test the mutual reference case in map form:
;;
;; [{:db/id "bobid"
;;   :person/name "Bob"
;;   :person/spouse "aliceid"}
;;  {:db/id "aliceid"
;;   :person/name "Alice"
;;   :person/spouse "bobid"}]

= emptySpouseDB
  ^ assertTransact _ emptyDB
  ,, %% =":db/ident" ":person/name"
     %% =":db/cardinality" "one"
     %% =":db/indexed" TRUE
  ,, %% =":db/ident" ":person/spouse"
     %% =":db/cardinality" "one"
     %% =":db/valueType" "ref"

= aliceAndBob
  ^ assertTransact _ emptySpouseDB
  ,, %% =":db/id" %["bobid"]
     %% =":person/name" "Bob"
     %% =":person/spouse" %["aliceid"]
  ,, %% =":db/id" %["aliceid"]
     %% =":person/name" "Alice"
     %% =":person/spouse" %["bobid"]

; Test that the mutual references in value position were resolved:
!!=    | lookupByAV ":person/name" "Alice" aliceAndBob
     @ bobCab | lookupByAV ":person/name" "Bob" aliceAndBob
     : bobId <- *fromSingletonCab bobCab ('failed to find Bob' 0)
     : aid <- *fromSingletonCab
                (lookupByAidV dbIdentId ":person/spouse" aliceAndBob)
              | 'unknown attr' 0
     | lookupByVAid bobId aid aliceAndBob


; Test that we can resolve complex many/ref cases.
= emptyOrderDB
  ^ assertTransact _ emptyDB
  ,, %% =":db/ident" ":order/name"
     %% =":db/cardinality" "one"
     %% =":db/indexed" TRUE
  ,, %% =":db/ident" ":order/lineItems"
     %% =":db/cardinality" "many"
     %% =":db/valueType" "ref"
  ,, %% =":db/ident" ":item/product"
     %% =":db/cardinality" "one"
     %% =":db/indexed" TRUE
  ,, %% =":db/ident" ":item/quantity"
     %% =":db/cardinality" "one"


= withOrders
  ^ assertTransact _ emptyOrderDB
  ,, %% =":order/name" "Bob"
     %% =":order/lineItems" ,, %% =":item/product" "Hamburger"
                               %% =":item/quantity" 1
                            ,, %% =":item/product" "Guinness"
                               %% =":item/quantity" 1
  ,, %% =":order/name" "James"
     %% =":order/lineItems" ,, %% =":item/product" "Tendies"
                               %% =":item/quantity" 1
                            ,, %% =":item/product" "Kirin"
                               %% =":item/quantity" 1

; Who ordered the tendies?
!!=     | lookupByAV ":order/name" "James" withOrders
    @ tendiesEid | cabFirst | lookupByAV ":item/product" "Tendies" withOrders
    | lookupByVA tendiesEid ":order/lineItems" withOrders














""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

;  ^-^
;  ^-^ DB emptyDB
;  ^-^
;  ^-^ ENT TMP LOOKUP
;  ^-^ NEWENTITY ADD RETRACT
;  ^-^
;  ^-^ lookupByEA lookupByAE lookupByAV lookupByVA transact


