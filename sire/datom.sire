"""
""" Datom
""" =====
"""
""" Embeddable Entity/Attribute/Value datastore.
"""

""" Imports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

/+  boot
/+  hitch
/+  switch    ["#switch"]
/+  datatype  ["#record" "#datatype" "#datacase"]
/+  mutrec

;; for v0, all trees are Tabs and Cabs, not hitch stuff. doing all the hitch
;; stuff will require adding a `Multimap a b c -> Map a (Map b (MapSet c))`
;; typw.

;; The toplevel DB type.
;;
;; for v0, all tables are (Tab Any (Tab Any (Cab Any))).
# record Db
| DB
* eav    : Any
* aev    : Any
* ave    : Any
* maxEid : Nat
; rschema

; raw operation to add a resolved tuple to the database
= (rawAdd e a v doIndex db)
# openDb db
@ (alter2 c in)
  | *SOME
  : cab <- *maybeCase in (cabSingleton c)
  | cabIns c cab
@ (alter b c in)
  | *SOME
  : tab <- *maybeCase in
              | tabSingleton b
              | cabSingleton c
  | tabAlter (alter2 c) b tab
@ eav | tabAlter (alter a v) e eav
@ aev | tabAlter (alter e v) a aev
@ ave
  | ifNot doIndex ave
  | tabAlter (alter v e) a ave
| DB eav aev ave maxEid

; raw remove
= (rawRm e a v db)
# openDb db
@ (alter2 c in)
  : cab <- *maybeCase in NONE
  @ rmed | cabDel c cab
  | if (cabIsEmpty rmed) NONE
  | *SOME rmed
@ (alter b c in)
  : tab <- *maybeCase in NONE
  @ rmed | tabAlter (alter2 c) b tab
  | if (tabIsEmpty rmed) NONE
  | *SOME rmed
@ eav | tabAlter (alter a v) e eav
@ aev | tabAlter (alter e v) a aev
; always try to purge values from the ave table; the user might have changed
; the value of :db/unique between add and retract.
@ ave | tabAlter (alter v e) a ave
| DB eav aev ave maxEid

= dbIdentId 0
= dbIdentStr ":db/ident"
= dbUniqueId 1
= dbUniqueStr ":db/unique"

= emptyDB
@ db
  @ eav    %[]
  @ aev    %[]
  @ ave    %[]
  ; todo: add vae table when I implement :db/ref.
  @ maxEid 3
  | DB eav aev ave maxEid
; an "empty" db still needs to have some "built-in" tuples to allow for
; attribute resolution. each attribute still has an eid.
;
; :db/ident is the name identity of an attribute. in the eav tuple
; `[5 ":my/attr" "str"], we will first do an attribute/value lookup on
; [":db/ident" ":my/attr"] and will use the entity number in storage.
;
; TODO: Must validate that incoming data type is a cord when I add value types.
| rawAdd dbIdentId dbIdentId dbIdentStr TRUE
| rawAdd dbIdentId dbUniqueId TRUE TRUE
;
; :db/unique is whether values for this attribute must be unique. It defaults
; to false. When true, and a transaction attempts to commit an already existing
; value, errors to the user.
| rawAdd dbUniqueId dbIdentId dbUniqueStr TRUE
db

;; Resolved transaction changes
# datatype TxOper
* RESADD entityId:Any attr:Any val:Any indexed:Any
* RESRETRACT entityId:Any attr:Any val:Any

# datatype Ident
; Specific numeric entity
* ENT entityId:Any
; New entity referred to multiple times by this value
* TMP val:Any
; Entity id based on an attribute lookup.
* LOOKUP attr:Any val:Any

;; Transaction items
# datatype TxnItem
; Creates a new entity and adds the contents of the tab as a list of e
* NEWENTITY tab:Any
; Adds a specific
* ADD ident:Any attr:Any val:Any
; Retracts a specific datom
* RETRACT eid:Any attr:Any val:Any

; Return a new entity id and record the new max in the database.
= (allocEntity db)
# openDb db
[maxEid [eav aev ave (inc maxEid)]]

; Passes the single item to `gud` or runs `bad`.
= (fromSingletonCab opt bad gud)
| if (neq 1 | cabLen opt) bad
| *gud (cabFirst opt)

; Internal functions on
= (lookupByEidAid eid aid db)
# openDb db
: av <- *maybeCase (tabLookup eid eav) %[]
: v  <- *maybeCase (tabLookup aid av) %[]
v

= (lookupByAidEid aid eid db)
# openDb db
: ev <- *maybeCase (tabLookup aid aev) %[]
: v  <- *maybeCase (tabLookup eid ev) %[]
v

= (lookupByAidV aid val db)
# openDb db
: ve <- *maybeCase (tabLookup aid ave) %[]
: e  <- *maybeCase (tabLookup val ve) %[]
e

; User level manual lookup
= (lookupByEA eid attr db)
: aid <- *fromSingletonCab (lookupByAidV dbIdentId attr db)
           | 'unknown attr' attr
| lookupByEidAid eid aid db

= (lookupByAE attr eid db)
: aid <- *fromSingletonCab (lookupByAidV dbIdentId attr db)
           | 'unknown attr' attr
| lookupByAidEid aid eid db

= (lookupByAV attr val db)
: aid <- *fromSingletonCab (lookupByAidV dbIdentId attr db)
           | 'unknown attr' attr
| lookupByAidV aid val db

; Given a user level attribute name, translate that to a numeric attribute
; number and an 'indexed' boolean which is whether we can use the ave table to
; lookup data related to this attribute.
;
; TODO: Return an Either once Either is smoothed over a bit.
;
; resolveAttrName : Nat -> DB -> [entityId indexed]
= (resolveAttrName attrName db)
; TODO: Once cardinality is in, change the structure so the v in the eav and
; aev maps is a value, not a %[value], make lookupByAidV return SOME instead of
; %[].
@ attrsCab | lookupByAidV dbIdentId attrName db
: attrEid <- *fromSingletonCab attrsCab
               | 'No attribute name match for ' %[=attrName =db]
@ isIndex
  ; TODO: lol at looking up unique cardinality with non-unique primitives.
  @ attrUniq | lookupByAidEid dbUniqueId attrEid db
  : i <- *fromSingletonCab attrUniq | *FALSE
  i
[attrEid isIndex]

= (lookupByIdentA identAttr identVal attr db)
@ [aid indexed] | resolveAttrName identAttr db
| ifNot indexed | 'cannot lookup unindexed attribute ' identAttr
@ eidCab | lookupByAidV aid identVal db
: eid <- *fromSingletonCab eidCab | 'invalid eid for aid?! ' aid
| lookupByEA eid attr db

; Given a user level entity identity, translate that to a numeric database
; identity.
;
> Ident > (Map Any Nat) > DB > [Nat (Map Any Nat) DB]
= (resolveIdent ident txnTmps db)
# openDb db
# datacase ident
* (ENT eid)
  ,, eid
  ,, txnTmps
  ,, | if (lth eid maxEid) db
     ; user has specified a larger eid than exists by hand.
     [eav aev ave (inc eid)]
* (TMP val)
  : eid <- maybeCase (tabLookup val txnTmps)
             @ [eid db] | allocEntity db
             [eid (tabMut val eid txnTmps) db]
  [eid txnTmps db]
* (LOOKUP attrName val)
  @ [aid indexed] | resolveAttrName attrName db
  | ifNot indexed | 'Attribute not indexed or unique: ' attrName
  @ eids | lookupByAidV aid val db
  @ l | cabLen eids
  | if (isZero l) | 'No match for ' %[=attrName =val]
  | if (gth l 1)  | 'Not unique for ' %[=attrName =val]
  [(cabFirst eids) txnTmps db]

; Given input items, assign numeric entity ids to everything for loading into
; the actual db.
;
> [(List TxnItem) (Map Any Nat) DB] > TxnItem > _1
= (resolveTransactionItem [items txnTmps db] item)
# datacase item
* (NEWENTITY tab)
  @ [eid db] | allocEntity db
  @ (mkRes [attrName v])
    @ [aid indexed] | resolveAttrName attrName db
    | RESADD eid aid v indexed
  @ adds | listMap mkRes | tabToList tab
  [(listWeld adds items) txnTmps db]
* (ADD ident attr val)
  @ [eid txnTmps db] | resolveIdent ident txnTmps db
  @ [aid indexed] | resolveAttrName attr db
  [(*CONS (RESADD eid aid val indexed) items) txnTmps db]
* (RETRACT eid attr val)
  [(*CONS (RESRETRACT eid attr val) items) txnTmps db]

; User transaction function. Given transaction items, resolve any pending
; entity numbers in them and then apply them to the database.
;
; TODO: The type is wrong. It should be `Either Error DB`, since a ton of
; things can error and `die` is wrong in this case.
;
> Row TxnItem > DB > DB
= (transact items db)
@ [resolved _ db]
  | listFoldl resolveTransactionItem [NIL %[] db]
  | listFromRow items
^ listFoldl _ db resolved
& (db item)
# datacase item
* (RESADD eid attr val indexed)
  | rawAdd eid attr val indexed db
* (RESRETRACT eid attr val)
  | rawRm eid attr val db

= postDB
^ transact _ emptyDB
,, | NEWENTITY %[":db/ident"=":b/post"]
,, | NEWENTITY %[":db/ident"=":b/author"]
,, | NEWENTITY %[":db/ident"=":b/title"]

; Check that NEWENTITY and ADD forms are equivalent.
!!=     ^ transact _ postDB
        ,, | ADD (TMP "newpost") ":b/post" "mai poast"
        ,, | ADD (TMP "newpost") ":b/author" "Iceman"
        ,, | ADD (TMP "other") ":b/post" "Other post"
        ,, | ADD (TMP "other") ":b/author" "Sol"
   ^ transact _ postDB
   ,, | NEWENTITY %[":b/post"="mai poast" ":b/author"="Iceman"]
   ,, | NEWENTITY %[":b/post"="Other post" ":b/author"="Sol"]

= emptyContactsDB
^ transact _ emptyDB
,, | NEWENTITY %[":db/ident"=":c/name"]
,, | NEWENTITY %[":db/ident"=":c/email" ":db/unique"=TRUE]
,, | NEWENTITY %[":db/ident"=":c/phone"]

= contactsDB
  ^ transact _ emptyContactsDB
  ,, | NEWENTITY %[":c/name"="Iceman" ":c/email"="iceman@plunder.tech"]
  ,, | NEWENTITY %[":c/name"="Sol" ":c/email"="sol@plunder.tech"]

; If we try set the contacts up so you can reference entities by their email,
; we should be able to set someone's phone number by their email.
!!=     %["(555) 555"]
    @ phoneDB
      ^ transact _ contactsDB
      ,, | ADD (LOOKUP ":c/email" "iceman@plunder.tech") ":c/phone" "(555) 555"
    | lookupByIdentA ":c/email" "iceman@plunder.tech" ":c/phone" phoneDB

; TODO: Once we return errors instead of just dying on exceptions, test:
;
; - trying to lookup by non-:db/unique attribute errors
; - trying to lookup by non-existent attribute errors

; TODO: Once we return errors instead of just dying on exceptions, also
;
; - validate uniqueness during a new validation pass.

""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^
^-^ DB emptyDB
^-^
^-^ ENT TMP LOOKUP
^-^ NEWENTITY ADD RETRACT
^-^
^-^ lookupByEA lookupByAE lookupByAV transact

