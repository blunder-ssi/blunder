"""
""" Datom
""" =====
"""
""" Embeddable Entity/Attribute/Value datastore.
"""

""" Imports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

/+  boot
/+  hitch
/+  switch    ["#switch"]
/+  datatype  ["#record" "#datatype" "#datacase"]
/+  mutrec

;; for v0, all trees are Tabs and Cabs, not hitch stuff. doing all the hitch
;; stuff will require adding a `Multimap a b c -> Map a (Map b (MapSet c))`
;; typw.

# datatype Error
* UNIQUE_VIOLATION attrName:Any attrVal:Any oldEid:Nat newEid:Nat
* LOOKUP_NO_ATTRIBUTE attrName:Any
* LOOKUP_ATTRIBUTE_NOT_UNIQUE attrName:Any
* LOOKUP_NO_MATCH attrName:Any val:Any
;
* INVALID_ROW row:(Row Any)
* INVALID_ROW_OP op:Any
;
* BAD_MAP_VAL val:Any
;
* PULL_NOT_ROW val:Any
* BAD_PULL_TERM val:Any

;; The toplevel DB type.
;;
;; for v0, all tables are (Tab Any (Tab Any (Cab Any))).
# record Db
| DB
* eav    : Any
* aev    : Any
* ave    : Any
* vae    : Any
* maxEid : Nat

; raw operation to add a resolved tuple to the database
> Nat > Nat > Any > Bool > Bool > Bool > DB > DB
= (rawAdd e a v writeAve many isRef db)
;| trk [%rawAdd e a v writeAve many isRef db]
# openDb db
; only usable for tuples which end in [v] (eav, aev)
@ (alterEndVal c in)
  | *SOME
  : cab <- *maybeCase in (cabSingleton c)
  | if many | cabIns c cab
  | cabSingleton c
; only usable for tuples whose middle is not v (eav, aev)
@ (alterNotVal b c in)
  | *SOME
  : tab <- *maybeCase in
              | tabSingleton b
              | cabSingleton c
  | tabAlter (alterEndVal c) b tab
; only usable for tuples whose middle IS v (ave)
@ (alterEndNonV c in)
  | *SOME
  : cab <- *maybeCase in (cabSingleton c)
  | cabIns c cab
; only usable for tuples whose middle IS v (ave)
@ (alterMiddleEndNonV b c in)
  | *SOME
  : tab <- *maybeCase in
              | tabSingleton b
              | cabSingleton c
  | tabAlter (alterEndNonV c) b tab
@ eav | tabAlter (alterNotVal a v) e eav
@ aev | tabAlter (alterNotVal e v) a aev
@ ave
  | ifNot writeAve ave
  | tabAlter (alterMiddleEndNonV v e) a ave
@ vae
  | ifNot isRef vae
  | tabAlter (alterMiddleEndNonV a e) v vae
| DB eav aev ave vae maxEid

; raw remove
> Nat > Nat > Any > DB > DB
= (rawRm e a v db)
# openDb db
@ (alter2 c in)
  : cab <- *maybeCase in NONE
  @ rmed | cabDel c cab
  | if (cabIsEmpty rmed) NONE
  | *SOME rmed
@ (alter b c in)
  : tab <- *maybeCase in NONE
  @ rmed | tabAlter (alter2 c) b tab
  | if (tabIsEmpty rmed) NONE
  | *SOME rmed
@ eav | tabAlter (alter a v) e eav
@ aev | tabAlter (alter e v) a aev
; always try to purge values from the ave table; the user might have changed
; the value of :db/unique between add and retract.
@ ave | tabAlter (alter v e) a ave
| DB eav aev ave vae maxEid

= dbIdentId 0
= dbIdentStr ":db/ident"
= dbCardinalityId 1
= dbCardinalityStr ":db/cardinality"
= dbUniqueId 2
= dbUniqueStr ":db/unique"
= dbIndexedId 3
= dbIndexedStr ":db/indexed"
= dbValueTypeId 4
= dbValueTypeStr ":db/valueType"

= dbIdId 100  ; TODO: should be 0
= dbIdStr ":db/id"

= emptyDB
@ db
  @ eav    %[]
  @ aev    %[]
  @ ave    %[]
  @ vae    %[]
  @ maxEid 5
  | DB eav aev ave vae maxEid
@ (baseAdd e a v db)
  | rawAdd e a v TRUE TRUE FALSE db
; an "empty" db still needs to have some "built-in" tuples to allow for
; attribute resolution. each attribute still has an eid.
;
; :db/ident is the name identity of an attribute. in the eav tuple
; `[5 ":my/attr" "str"], we will first do an attribute/value lookup on
; [":db/ident" ":my/attr"] and will use the entity number in storage.
;
; TODO: Must validate that incoming data type is a cord when I add value types.
| baseAdd dbIdentId dbIdentId dbIdentStr
| baseAdd dbIdentId dbUniqueId TRUE
;
; :db/unique is whether values for this attribute must be unique. It defaults
; to false. When true, and a transaction attempts to commit an already existing
; value, errors to the user.
| baseAdd dbUniqueId dbIdentId dbUniqueStr
;
; :db/indexed is whether values for this attribute are indexed, ie, whether you
; can look up an eid by their attribute and value. :db/unique implies
; :db/indexed.
| baseAdd dbIndexedId dbIdentId dbIndexedStr
;
; :db/cardinality is "one" or "many". When adding a tuple whose attribute has
; cardinality "one", the value is overwritten. When "many", multiple values
; accumulate.
;
; TODO: validate the values "one" or "many" once I implement :db/attr.preds.
| baseAdd dbCardinalityId dbIdentId dbCardinalityStr
;
; :db/valueType is a string describing the type. For now, the values are nat,
; any and ref.
| baseAdd dbValueTypeId dbIdentId dbValueTypeStr
db

# datatype EntIdent
; Specific numeric entity
* ENT entityId:Any
; New entity referred to multiple times by this value
* TMP val:Any
; Entity id based on an attribute lookup.
* LOOKUP attr:Any val:Any

# datatype TxnAction
* ACTADD eid:Nat aid:Nat attrName:Any val:Any writeAve:Bool unique:Bool
         many:Bool isRef:Bool
* ACTRM  eid:Any aid:Any val:Any

; Return a new entity id and record the new max in the database.
> DB > [Nat DB]
= (allocEntity db)
# openDb db
,, maxEid
,, | DB eav aev ave vae (inc maxEid)

= (singletonCabDefault opt missing next)
| *next
| if (neq 1 | cabLen opt) missing
| cabFirst opt

; Internal functions on
> Nat > Nat > DB > Cab Any
= (lookupByEidAid eid aid db)
# openDb db
: av <- *maybeCase (tabLookup eid eav) %[]
: v  <- *maybeCase (tabLookup aid av) %[]
v

> Nat > Nat > DB > Cab Any
= (lookupByAidEid aid eid db)
# openDb db
: ev <- *maybeCase (tabLookup aid aev) %[]
: v  <- *maybeCase (tabLookup eid ev) %[]
v

> Nat > Nat > DB > Cab Nat
= (lookupByAidV aid val db)
# openDb db
: ve <- *maybeCase (tabLookup aid ave) %[]
: e  <- *maybeCase (tabLookup val ve) %[]
e

> Any > Nat > DB > Cab Nat
= (lookupByVAid val aid db)
# openDb db
: ae <- *maybeCase (tabLookup val vae) %[]
: e  <- *maybeCase (tabLookup aid ae) %[]
e

; Given a user level attribute name, translate that to a numeric attribute
; number and an 'indexed' boolean which is whether we can use the ave table to
; lookup data related to this attribute.
;
> Str > DB > Either Error [Nat Bool Bool Bool Bool]
= (resolveAttrName attrName db)
;| trk [%resolve attrName]
@ attrsCab | lookupByAidV dbIdentId attrName db
: attrEid <- *fromSingletonCab attrsCab
               | *LEFT | *LOOKUP_NO_ATTRIBUTE attrName
@ isIndex
  @ attrIndexed | lookupByAidEid dbIndexedId attrEid db
  : indexed <- *singletonCabDefault attrIndexed FALSE
  indexed
@ isUnique
  @ attrUniq    | lookupByAidEid dbUniqueId attrEid db
  : uniq    <- *singletonCabDefault attrUniq FALSE
  uniq
@ isMany
  @ attrMany | lookupByAidEid dbCardinalityId attrEid db
  : many <- *singletonCabDefault attrMany "many"
  # switch many
  * one  FALSE
  * many TRUE
  * _    | 'unknown many value: ' many
@ isRef
  @ attrValType | lookupByAidEid dbValueTypeId attrEid db
  : t <- *singletonCabDefault attrValType "any"
  # switch t
  * ref TRUE
  * _   FALSE
| *RIGHT [attrEid isIndex isUnique isMany isRef]

; User level manual lookup
> Nat > Any > DB > Cab Any
= (lookupByEA eid attr db)
: aid <- *fromSingletonCab (lookupByAidV dbIdentId attr db)
           | 'unknown attr' attr
| lookupByEidAid eid aid db

> Any > Nat > DB > Cab Any
= (lookupByAE attr eid db)
: aid <- *fromSingletonCab (lookupByAidV dbIdentId attr db)
           | 'unknown attr' attr
| lookupByAidEid aid eid db

> Any > Any > DB > Cab Nat
= (lookupByAV attr val db)
# datacase (resolveAttrName attr db)
* (LEFT errs) | 'could not lookup. errors: ' errs
* (RIGHT [aid indexed unique _])
  | ifNot (or indexed unique) | 'cannot lookup unindexed attr/val' attr
  | lookupByAidV aid val db

> Any > Any > DB > Cab Nat
= (lookupByVA val attr db)
# datacase (resolveAttrName attr db)
* (LEFT errs) | 'could not lookup. errors: ' errs
* (RIGHT [aid _ _ _ ref])
  | ifNot ref | 'cannot lookup non-ref values' attr
  | lookupByVAid val aid db

> Any > Any > Nat > DB > Cab Nat
= (lookupByIdentA identAttr identVal attr db)
# datacase | resolveAttrName identAttr db
* (LEFT err) | 'could not lookup. error: ' err
* (RIGHT [aid _ unique _])
  | ifNot unique | 'cannot lookup unindexed attribute ' identAttr
  @ eidCab | lookupByAidV aid identVal db
  : eid <- *fromSingletonCab eidCab | 'invalid eid for aid?! ' aid
  | lookupByEA eid attr db

""" User Transact Parsing """"""""""""""""""""""""""""""""""""""""""""""""""""""

; Resolve a lookup ref into an eid or error.
;
> Str > Any > DB > Either Error Nat
= (performLookup attrName val db)
  # datacase | resolveAttrName attrName db
  * (LEFT err) | *LEFT err
  * (RIGHT [aid _ unique _ _])
    | ifNot unique
      | *LEFT | *LOOKUP_ATTRIBUTE_NOT_UNIQUE attrName
    @ eids | lookupByAidV aid val db
    @ l | cabLen eids
    | if (isZero l)
      | *LEFT | *LOOKUP_NO_MATCH attrName val
    | *RIGHT | cabFirst eids

; Immediately resolves an entity to a numeric entity id.
;
; 5               -> RIGHT [5 ...]
; [":b/first" 5]  -> RIGHT [9 ...] (assuming underlying LOOKUP succeeds)
; [":b/second" 6] -> LEFT err (assuming lookup fails)
; %["tmpid"]      -> RIGHT [2 ...] (assigns a tmpid and adds it to the map)
;
> Tab Str Nat > DB > Any > Either Error [Nat (Tab Str Nat) DB]
= (parseEntityId txnTmpIds db i)
  | if (isNat i)
    | *RIGHT [i txnTmpIds db]
  | if (and (isRow i) (eql 2 | len i))
    # datacase | performLookup (idx 0 i) (idx 1 i) db
    * (LEFT l)    | *LEFT l
    * (RIGHT eid) | *RIGHT [eid txnTmpIds db]
  ; temporarily, we're going to wrap temporary identifiers in cabs for ease of
  ; typing
  | if | rowAnd ,, isCab i
                ,, eql 1 | cabLen i
                ,, isNat | cabFirst i
    @ val | cabFirst i
    : eid <- maybeCase (tabLookup val txnTmpIds)
               @ [eid db] | allocEntity db
               | *RIGHT [eid (tabMut val eid txnTmpIds) db]
    | *RIGHT [eid txnTmpIds db]
  | *LEFT ["Couldn't parse" i]

; Given a map, parse it into a series of actions and return the numeric eid
; parsed or assigned.
;
; We have to perform all numeric entity resolution immediately since we want to
; pass the eid upwards to participate in other parts of the transaction.
;
> DB > Tab Any Any > [(Maybe Nat) [Error] [TxnAction] (Tab Any Any) DB]
= (parseMapForm txnTmpIds db tab)
  ; if there's a :db/id, than use that. But if there's not, we have to assign a
  ; new temporary id.
  @ eitherEident
    : entVal <- *maybeCase (tabLookup dbIdStr tab)
                  @ [eid db] | allocEntity db
                  | *RIGHT [eid txnTmpIds db]
    | parseEntityId txnTmpIds db entVal
  ;
  # datacase eitherEident
  * (LEFT l)
    [NONE (*LEFT | *CONS l NIL) NIL txnTmpIds db]
  * (RIGHT [eid txnTmpIds db])
    | rowCons (SOME eid)
    ^ foldl _ [NIL NIL txnTmpIds db] | tabToPairs | tabDel dbIdStr tab
    & ([errs actions txnTmpIds db] [aVal vVal])
    ;
    # datacase (resolveAttrName aVal db)
    * (LEFT err)
      [(*CONS err errs) actions db]
    * (RIGHT [aid indexed unique isMany isRef])
      @ writeAve | or indexed unique
      | if isRef
        ; TODO: This is super complex code. It's ugly, it's long, and I don't
        ; know how to effectively factor this in sire.
        | if (rowAnd [isMany (not | isCab vVal) (isRow vVal)])
          ; we have a list here, each value needs to be treated as a map form.
          @ [suberrs subactions subeids txnTmpIds db]
            ^ foldl _ [NIL NIL NIL txnTmpIds db] vVal
            & ([errs actions eids txnTmpIds db] i)
            | ifNot | isTab i
              ,, (*CONS (BAD_MAP_VAL i) errs)
              ,, actions
              ,, eids
              ,, txnTmpIds
              ,, db
            ; we need to reparse map errors
            @ [mybEid suberrs subactions txnTmpIds db]
              | parseMapForm txnTmpIds db i
            ,, | listWeld suberrs errs
            ,, | listWeld subactions actions
            ,, : eid <- *maybeCase mybEid eids
               | *CONS eid eids
            ,, txnTmpIds
            ,, db
          ; at this point, we have a list of our subeids or errors.
          | ifNot (listNull errs)
            ,, (listWeld suberrs errs)
            ,, actions
            ,, txnTmpIds
            ,, db
          @ newActions
            ^ listMap _ subeids
            & subeid
            (ACTADD eid aid aVal subeid writeAve unique isMany isRef)
          ,, errs
          ,, (listWeld newActions | listWeld subactions actions)
          ,, txnTmpIds
          ,, db
        | if ((isTab vVal) && (not | isCab vVal))
          @ [mybEid suberrs subactions txnTmpIds db]
            | parseMapForm txnTmpIds db vVal
          : subeid <- *maybeCase mybEid
                     ,, | listWeld suberrs errs
                     ,, | listWeld subactions actions
                     ,, txnTmpIds
                     ,, db
          @ topAdd | ACTADD eid aid aVal subeid writeAve unique isMany isRef
          ,, | listWeld suberrs errs
          ,, | *CONS topAdd | listWeld subactions actions
          ,, txnTmpIds
          ,, db
        ; we have one entity id as the rhs.
        # datacase | parseEntityId txnTmpIds db vVal
        * (LEFT err)
          ,, (*CONS err errs)
          ,, actions
          ,, txnTmpIds
          ,, db
        * (RIGHT [rightEid txnTmpIds db])
          ,, errs
          ,, | *CONS (ACTADD eid aid aVal rightEid writeAve unique isMany isRef)
                     actions
          ,, txnTmpIds
          ,, db
      | if isMany
        ; many, but not references. So if this is a row, parse each item as a
        ; value, otherwise
        @ adds
          | if | isRow vVal
            | listMap v&(ACTADD eid aid aVal v writeAve unique isMany isRef)
            | listFromRow vVal
          | *CONS | ACTADD eid aid aVal vVal writeAve unique isMany isRef
            NIL
        ,, errs
        ,, listWeld adds actions
        ,, txnTmpIds
        ,, db
      ; sometimes a val is just a val
      ,, errs
      ,, | *CONS (ACTADD eid aid aVal vVal writeAve unique isMany isRef)
                 actions
      ,, txnTmpIds
      ,, db

> DB > Tab Any Any > [[Error] [TxnAction] (Tab Any Any) DB]
= (parseListForm txnTmpIds db row)
  ; rows are a tuple of [op espec attr val]
  | ifNot | eql 4 | len row
    ,, (*CONS (INVALID_ROW row) NIL)
    ,, NIL
    ,, txnTmpIds
    ,, db
  @ op | idx 0 row
  | if | and | neq %add op
             | neq %rm op
    ,, (*CONS (INVALID_ROW_OP op) NIL)
    ,, NIL
    ,, txnTmpIds
    ,, db
  # datacase | parseEntityId txnTmpIds db (idx 1 row)
  * (LEFT err)
    ,, (*CONS err NIL)
    ,, NIL
    ,, txnTmpIds
    ,, db
  * (RIGHT [eid txnTmpIds db])
    ; todo: in list form, attr is not just an attrName, but can also be a raw
    ; eid or a lookupref. we completely punt on this: it should be easy to add
    ; back later when there's a more complete type system and we aren't going
    ; to use this for now.
    @ attrName | idx 2 row
    # datacase (resolveAttrName attrName db)
    * (LEFT err)
      [(*CONS err NIL) NIL txnTmpIds db]
    * (RIGHT [aid indexed unique isMany isRef])
      @ writeAve | or indexed unique
      ; In list form, we don't do arity resolution. We treat the value
      ; literally.
      @ val | idx 3 row
      | if (eql op %rm)
        ,, NIL
        ,, | *CONS | ACTRM eid aid val
        ,, txnTmpIds
        ,, db
      ,, NIL
      ,, | *CONS (ACTADD eid aid attrName val writeAve unique isMany isRef)
                 NIL
      ,, txnTmpIds
      ,, db

; Given a user-level structure of rows and tabs, parse it into a series of adds
; and retracts.
;
; Parsing depends on a database value because the query has attributes in it
; and we have to lookup the properties of those attributes to know how to parse
; them.
;
> DB > Any > [[Error] [TxnAction] (Tab Any Any) DB]
= (parseItem txnTmpIds db item)
  | if (isTab item)
    | drop 1 | parseMapForm txnTmpIds db item
  | if (isRow item)
    | parseListForm txnTmpIds db item
  ;
  | *LEFT "1) What"

> DB > Row Any > Either [Error] [[TxnAction] DB]
= (parseAllItems db items)
  ^ foldl _ [NIL NIL %[] db] items
  & ([errs actions txnTmpIds db] i)
  @ [newErrs newActions txnTmpIds db] | parseItem txnTmpIds db i
  ,, | listWeld newErrs errs
  ,, | listWeld newActions actions
  ,, txnTmpIds
  ,, db

; User transaction function. Given transaction items, resolve any pending
; entity numbers in them and then apply them to the database.
;
> Row Any > DB > (Either (Row Error) DB)
= (transact items db)
@ [errs actions _ db] | parseAllItems db items
| ifNot (listNull errs) | *LEFT | listToRow errs
@ [errs newDB]
  ^ listFoldl _ [errs db] actions
  & ([errs db] item)
  # datacase item
  * (ACTADD eid aid attrName val writeAve unique many isRef)
    | ifNot unique
      ; simple case, cannot error
      [errs (rawAdd eid aid val writeAve many isRef db)]
    ;
    ; check for uniqueness violations.
    @ oldEidCab | lookupByAidV aid val db
    | if (cabIsEmpty oldEidCab)
      ; no previous value
      [errs (rawAdd eid aid val writeAve many isRef db)]
    ,, | *CONS (UNIQUE_VIOLATION attrName val (cabFirst oldEidCab) eid) errs
    ,, db
  * (ACTRM eid attr val)
    [errs (rawRm eid attr val db)]
| ifNot (listNull errs) | *LEFT | listToRow errs
| *RIGHT newDB

""" Pull """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

; todo: maybe wrong structure. probably want to have each option as a maybe
; in PULL_ATTR.
# datatype AttrOption
* OPTION_AS name:Str

# datatype AttrExpr
* ATTR_EXPR name:String options:(Tab String Any)

# datatype ParsedPull
* PULL_WILDCARD
* PULL_ATTR expr:AttrExpr
* PULL_MAP spec:(Row [AttrExpr (Row ParsedPull)])

> DB > Any > Either [Error] ParsedPull
= (parse db val)
| if | isRow val
  ; TODO: all non simple list forms.
  | *LEFT "todo: any map term"
| if | isTab val
  @ [errs specs]
    | partition
    ^ map _ | tabToPairs val
    & [k v]
    # datacase | parse db k
    * (LEFT new) | LEFT new
    * (RIGHT parsed)
      # datacase parsed
      * (PULL_ATTR keyExpr)
        @ [errs parsedVals]
          | partition
          | map (parse db) v
        | ifNot | isZero | len errs
          | *LEFT errs
        | *RIGHT [keyExpr parsedVals]
      * _ | *LEFT | *BAD_MAP_VAL parsed
  | ifNot | isZero | len errs
    | *LEFT errs
  | *RIGHT | PULL_MAP specs
; TODO: reverse lookups
| if (val == "*")
  | *RIGHT PULL_WILDCARD
| if (isNat val)
  | *RIGHT | *PULL_ATTR (ATTR_EXPR val %[])
| *LEFT | *BAD_PULL_TERM val

> Either Error [Str (Cab Any) [Nat Bool Bool Bool Bool]]
= (lookupAttr db eid expr)
# datacase expr
* (ATTR_EXPR name options)
  # datacase (resolveAttrName name db)
  * (LEFT err)
    | *LEFT err
  * (RIGHT [aid indexed unique isMany isRef])
    @ outputKey | fromSome name | tabLookup ":as" options
    @ rawCab | lookupByEidAid eid aid db
    ; TODO: handle limits in rawCab.
    | *RIGHT [outputKey rawCab [indexed unique isMany isRef]]

> [(List Error) (Tab Any Any) Nat DB]
> ParsedPull
> [(List Error) (Tab Any Any) Nat DB]
= (lookupSpec [errs t eid db] item)
# datacase item
* PULL_WILDCARD
  ; We have to return a map of all attributes to their values, including
  ; recursively, which is hard. We need to already have individual
  | 'pull wildcard unimplemented' 0
* (PULL_ATTR expr)
  # datacase | lookupAttr db eid expr
  * (LEFT err)
    [(*CONS err errs) t eid db]
  * (RIGHT [outputKey cab [indexed unique isMany isRef]])
    | if | cabIsEmpty cab
      [errs t eid db]
    ;
    | if isRef
      | 'todo: isRef' 0
    | if isMany
      ; many/non-ref
      [errs (tabMut outputKey (cabRow cab) t) eid db]
    ;
    [errs (tabMut outputKey (cabFirst cab) t) eid db]
* (PULL_MAP spec)
  ; Need to process the map here. This is a key from a eid ref to all the values
  ; which match it.
  ^ foldl _ [errs t eid db] spec
  & ([errs t eid db] [k v])
  # datacase | lookupAttr db eid k
  * (LEFT err)
    [(*CONS err errs) t eid db]
  * (RIGHT [outputKey cab [indexed unique isMany isRef]])
    @ [newErrs result]
      ^ foldl _ [errs NIL db] | cabRow cab
      ? (lookupSubEid [errs subres db] subeid)
      @ [suberrs result] | foldl lookupSpec [NIL %[] subeid db] v
      [errs (*CONS result subres) db]
    | ifNot | isZero | len newErrs
      [(*CONS newErrs errs) t eid db]
    @ o | tabMut outputKey (listToRow result) t
    ,, errs
    ,, o
    ,, eid
    ,, db

; General lookup function which returns information starting at an entity.
;
; Given an entity number, produces a tab with attributes as keys as described
; by `pullSpec`. This tab can recurse downwards into linked attributes, but
; does cannot do arbitrary higher complexity queries.
;
> Any > Any > DB > Either [Error] (Tab Any Any)
= (pull pullSpec eidSpec db)
: [eid _ _] <- *eitherCase | parseEntityId %[] db eidSpec
                 'error in eid spec: '
| ifNot | isRow pullSpec
  | *LEFT [(*PULL_NOT_ROW pullSpec)]
@ [errs specs] | partition | map (parse db) pullSpec
| ifNot | isZero | len errs
  | *LEFT errs
@ [errs result] | foldl lookupSpec [NIL %[] eid db] specs
| ifNot | listNull errs
  | *LEFT | listToRow errs
| *RIGHT result

""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^ UNIQUE_VIOLATION LOOKUP_NO_ATTRIBUTE LOOKUP_ATTRIBUTE_NOT_UNIQUE
^-^ LOOKUP_NO_MATCH INVALID_ROW INVALID_ROW_OP BAD_MAP_VAL BAD_PULL_TERM
^-^
^-^ DB emptyDB
^-^
^-^ lookupByEA lookupByAE lookupByAV lookupByVA transact
^-^ pull
^-^
; These shouldn't be exported, but are for testing. Remove these when there's
; a proper complete pull api implementation.
^-^ lookupByAidV lookupByVAid lookupByIdentA dbIdentId
