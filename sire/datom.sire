"""
""" Datom
""" =====
"""
""" Embeddable Entity/Attribute/Value datastore.
"""

""" Imports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

/+  boot
/+  hitch
/+  switch    ["#switch"]
/+  datatype  ["#record" "#datatype" "#datacase"]
/+  mutrec

;; for v0, all trees are Tabs and Cabs, not hitch stuff. doing all the hitch
;; stuff will require adding a `Multimap a b c -> Map a (Map b (MapSet c))`
;; typw.

;; The toplevel DB type.
;;
;; for v0, all tables are (Tab Any (Tab Any (Cab Any))).
# record Db
| DB
* eav    : Any
* aev    : Any
* ave    : Any
* maxEid : Nat
; rschema

; raw operation to add a resolved tuple to the database
= (rawAdd e a v indexed many db)
# openDb db
; only usable for tuples which end in [v] (eav, aev)
@ (alterEndVal c in)
  | *SOME
  : cab <- *maybeCase in (cabSingleton c)
  | if many | cabIns c cab
  | cabSingleton c
; only usable for tuples whose middle is not v (eav, aev)
@ (alterNotVal b c in)
  | *SOME
  : tab <- *maybeCase in
              | tabSingleton b
              | cabSingleton c
  | tabAlter (alterEndVal c) b tab
; only usable for tuples whose middle IS v (ave)
@ (alterEndNonV c in)
  | *SOME
  : cab <- *maybeCase in (cabSingleton c)
  | cabIns c cab
; only usable for tuples whose middle IS v (ave)
@ (alterMiddleV b c in)
  | *SOME
  : tab <- *maybeCase in
              | tabSingleton b
              | cabSingleton c
  | tabAlter (alterEndNonV c) b tab
@ eav | tabAlter (alterNotVal a v) e eav
@ aev | tabAlter (alterNotVal e v) a aev
@ ave
  | ifNot indexed ave
  | tabAlter (alterMiddleV v e) a ave
| DB eav aev ave maxEid

; raw remove
= (rawRm e a v many db)
; TODO: obey `many`.
# openDb db
@ (alter2 c in)
  : cab <- *maybeCase in NONE
  @ rmed | cabDel c cab
  | if (cabIsEmpty rmed) NONE
  | *SOME rmed
@ (alter b c in)
  : tab <- *maybeCase in NONE
  @ rmed | tabAlter (alter2 c) b tab
  | if (tabIsEmpty rmed) NONE
  | *SOME rmed
@ eav | tabAlter (alter a v) e eav
@ aev | tabAlter (alter e v) a aev
; always try to purge values from the ave table; the user might have changed
; the value of :db/unique between add and retract.
@ ave | tabAlter (alter v e) a ave
| DB eav aev ave maxEid

= dbIdentId 0
= dbIdentStr ":db/ident"
= dbCardinalityId 1
= dbCardinalityStr ":db/cardinality"
= dbUniqueId 2
= dbUniqueStr ":db/unique"
= dbIndexedId 3
= dbIndexedStr ":db/indexed"

= emptyDB
@ db
  @ eav    %[]
  @ aev    %[]
  @ ave    %[]
  ; todo: add vae table when I implement :db/ref.
  @ maxEid 4
  | DB eav aev ave maxEid
; an "empty" db still needs to have some "built-in" tuples to allow for
; attribute resolution. each attribute still has an eid.
;
; :db/ident is the name identity of an attribute. in the eav tuple
; `[5 ":my/attr" "str"], we will first do an attribute/value lookup on
; [":db/ident" ":my/attr"] and will use the entity number in storage.
;
; TODO: Must validate that incoming data type is a cord when I add value types.
| rawAdd dbIdentId dbIdentId dbIdentStr TRUE TRUE
| rawAdd dbIdentId dbUniqueId TRUE TRUE TRUE
;
; :db/unique is whether values for this attribute must be unique. It defaults
; to false. When true, and a transaction attempts to commit an already existing
; value, errors to the user.
| rawAdd dbUniqueId dbIdentId dbUniqueStr TRUE TRUE
;
; :db/indexed is whether values for this attribute are indexed, ie, whether you
; can look up an eid by their attribute and value. :db/unique implies
; :db/indexed.
| rawAdd dbIndexedId dbIdentId dbIndexedStr TRUE TRUE
;
; :db/cardinality is "one" or "many". When adding a tuple whose attribute has
; cardinality "one", the value is overwritten. When "many", multiple values
; accumulate.
;
; TODO: validate the values "one" or "many" once I implement :db/attr.preds.
| rawAdd dbCardinalityId dbIdentId dbCardinalityStr TRUE TRUE
db

;; Resolved transaction changes
# datatype TxOper
* RESADD entityId:Any attr:Any val:Any indexed:Any many:Any
* RESRETRACT entityId:Any attr:Any val:Any many:Any

# datatype Ident
; Specific numeric entity
* ENT entityId:Any
; New entity referred to multiple times by this value
* TMP val:Any
; Entity id based on an attribute lookup.
* LOOKUP attr:Any val:Any

;; Transaction items
# datatype TxnItem
; Creates a new entity and adds the contents of the tab as a list of e
* NEWENTITY tab:Any
; Adds a specific
* ADD ident:Any attr:Any val:Any
; Retracts a specific datom
* RETRACT eid:Any attr:Any val:Any

; Return a new entity id and record the new max in the database.
= (allocEntity db)
# openDb db
[maxEid [eav aev ave (inc maxEid)]]

; Passes the single item to `gud` or runs `bad`.
= (fromSingletonCab opt bad gud)
| if (neq 1 | cabLen opt) bad
| *gud (cabFirst opt)

= (singletonCabDefault opt missing next)
| *next
| if (neq 1 | cabLen opt) missing
| cabFirst opt

; Internal functions on
= (lookupByEidAid eid aid db)
# openDb db
: av <- *maybeCase (tabLookup eid eav) %[]
: v  <- *maybeCase (tabLookup aid av) %[]
v

= (lookupByAidEid aid eid db)
# openDb db
: ev <- *maybeCase (tabLookup aid aev) %[]
: v  <- *maybeCase (tabLookup eid ev) %[]
v

= (lookupByAidV aid val db)
# openDb db
: ve <- *maybeCase (tabLookup aid ave) %[]
: e  <- *maybeCase (tabLookup val ve) %[]
e

; Given a user level attribute name, translate that to a numeric attribute
; number and an 'indexed' boolean which is whether we can use the ave table to
; lookup data related to this attribute.
;
; TODO: Return an Either once Either is smoothed over a bit.
;
; resolveAttrName : Nat -> DB -> [entityId indexed many]
= (resolveAttrName attrName db)
@ attrsCab | lookupByAidV dbIdentId attrName db
: attrEid <- *fromSingletonCab attrsCab
               | 'No attribute name match for ' %[=attrName =db]
@ isIndex
  ; TODO: lol at looking up unique cardinality with non-unique primitives.
  @ attrUniq    | lookupByAidEid dbUniqueId attrEid db
  : uniq    <- *singletonCabDefault attrUniq FALSE
  | if uniq TRUE
  @ attrIndexed | lookupByAidEid dbIndexedId attrEid db
  : indexed <- *singletonCabDefault attrIndexed FALSE
  | if indexed TRUE
  FALSE
@ isMany
  @ attrMany | lookupByAidEid dbCardinalityId attrEid db
  : many <- *singletonCabDefault attrMany "many"
  # switch many
  * one  FALSE
  * many TRUE
  * _    | 'unknown many value: ' many
[attrEid isIndex isMany]

; User level manual lookup
= (lookupByEA eid attr db)
: aid <- *fromSingletonCab (lookupByAidV dbIdentId attr db)
           | 'unknown attr' attr
| lookupByEidAid eid aid db

= (lookupByAE attr eid db)
: aid <- *fromSingletonCab (lookupByAidV dbIdentId attr db)
           | 'unknown attr' attr
| lookupByAidEid aid eid db

= (lookupByAV attr val db)
@ [aid indexed _] | resolveAttrName attr db
| ifNot indexed | 'cannot lookup unindexed attr/val' attr
| lookupByAidV aid val db

= (lookupByIdentA identAttr identVal attr db)
@ [aid indexed _] | resolveAttrName identAttr db
| ifNot indexed | 'cannot lookup unindexed attribute ' identAttr
@ eidCab | lookupByAidV aid identVal db
: eid <- *fromSingletonCab eidCab | 'invalid eid for aid?! ' aid
| lookupByEA eid attr db

; Given a user level entity identity, translate that to a numeric database
; identity.
;
> Ident > (Map Any Nat) > DB > [Nat (Map Any Nat) DB]
= (resolveIdent ident txnTmps db)
# openDb db
# datacase ident
* (ENT eid)
  ,, eid
  ,, txnTmps
  ,, | if (lth eid maxEid) db
     ; user has specified a larger eid than exists by hand.
     [eav aev ave (inc eid)]
* (TMP val)
  : eid <- maybeCase (tabLookup val txnTmps)
             @ [eid db] | allocEntity db
             [eid (tabMut val eid txnTmps) db]
  [eid txnTmps db]
* (LOOKUP attrName val)
  @ [aid indexed _] | resolveAttrName attrName db
  | ifNot indexed | 'Attribute not indexed or unique: ' attrName
  @ eids | lookupByAidV aid val db
  @ l | cabLen eids
  | if (isZero l) | 'No match for ' %[=attrName =val]
  | if (gth l 1)  | 'Not unique for ' %[=attrName =val]
  [(cabFirst eids) txnTmps db]

; Given input items, assign numeric entity ids to everything for loading into
; the actual db.
;
> [(List TxnItem) (Map Any Nat) DB] > TxnItem > _1
= (resolveTransactionItem [items txnTmps db] item)
# datacase item
* (NEWENTITY tab)
  @ [eid db] | allocEntity db
  @ (mkRes [attrName v])
    @ [aid indexed many] | resolveAttrName attrName db
    | RESADD eid aid v indexed many
  @ adds | listMap mkRes | tabToList tab
  [(listWeld adds items) txnTmps db]
* (ADD ident attr val)
  @ [eid txnTmps db] | resolveIdent ident txnTmps db
  @ [aid indexed many] | resolveAttrName attr db
  [(*CONS (RESADD eid aid val indexed many) items) txnTmps db]
* (RETRACT eid attr val)
  @ [aid indexed many] | resolveAttrName attr db
  [(*CONS (RESRETRACT eid attr val) items) txnTmps db]

; User transaction function. Given transaction items, resolve any pending
; entity numbers in them and then apply them to the database.
;
; TODO: The type is wrong. It should be `Either Error DB`, since a ton of
; things can error and `die` is wrong in this case.
;
> Row TxnItem > DB > DB
= (transact items db)
@ [resolved _ db]
  | listFoldl resolveTransactionItem [NIL %[] db]
  | listFromRow items
^ listFoldl _ db resolved
& (db item)
# datacase item
* (RESADD eid attr val indexed many)
  | rawAdd eid attr val indexed many db
* (RESRETRACT eid attr val many)
  | rawRm eid attr val many db

""" Tests """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= postDB
^ transact _ emptyDB
,, | NEWENTITY %[":db/ident"=":b/post" ":db/cardinality"="one"]
,, | NEWENTITY %[":db/ident"=":b/author" ":db/cardinality"="one"]
,, | NEWENTITY %[":db/ident"=":b/title" ":db/cardinality"="one"]

; Check that NEWENTITY and ADD forms are equivalent.
!!=     ^ transact _ postDB
        ,, | ADD (TMP "newpost") ":b/post" "mai poast"
        ,, | ADD (TMP "newpost") ":b/author" "Iceman"
        ,, | ADD (TMP "other") ":b/post" "Other post"
        ,, | ADD (TMP "other") ":b/author" "Sol"
   ^ transact _ postDB
   ,, | NEWENTITY %[":b/post"="mai poast" ":b/author"="Iceman"]
   ,, | NEWENTITY %[":b/post"="Other post" ":b/author"="Sol"]

= emptyContactsDB
^ transact _ emptyDB
,, | NEWENTITY %% =":db/ident" ":c/name"
               %% =":db/indexed" TRUE
               %% =":db/cardinality" "one"
               %% =":db/unique" TRUE
; In this contrived testing scenario, you can have many emails, but only one
; phone number and that phone number can be shared between people.
,, | NEWENTITY %% =":db/ident" ":c/email"
               %% =":db/unique" TRUE
               %% =":db/cardinality" "many"
,, | NEWENTITY %% =":db/ident" ":c/phone"
               %% =":db/indexed" TRUE
               %% =":db/unique" FALSE
               %% =":db/cardinality" "one"

= contactsDB
  ^ transact _ emptyContactsDB
  ,, | NEWENTITY %[":c/name"="Iceman" ":c/email"="iceman@plunder.tech"]
  ,, | NEWENTITY %[":c/name"="Sol" ":c/email"="sol@plunder.tech"]

; If we try set the contacts up so you can reference entities by their email,
; we should be able to set someone's phone number by their email.
= phoneDB
  ^ transact _ contactsDB
  ,, | ADD (LOOKUP ":c/email" "iceman@plunder.tech") ":c/phone" "(555) 555"

!!=     %["(555) 555"]
    | lookupByIdentA ":c/email" "iceman@plunder.tech" ":c/phone" phoneDB

; For cardinality one attributes, setting the attribute twice should change the
; singular attribute value.
= changedPhoneDB
  ^ transact _ contactsDB
  ,, | ADD (LOOKUP ":c/email" "iceman@plunder.tech") ":c/phone" "(111) 111"

!!=     %["(111) 111"]
    | lookupByIdentA ":c/email" "iceman@plunder.tech" ":c/phone" changedPhoneDB

; Cardinality many interacts with the ave table: make sure in cardinality one
; scenarios, the old value isn't retrievable from the ave table.
!!=     %[]
    | lookupByAV ":c/phone" "(555) 555" changedPhoneDB

= changedEmailDB
  ^ transact _ contactsDB
  ,, | ADD (LOOKUP ":c/email" "iceman@plunder.tech") ":c/email"
           "alias@example.com"

; For cardinality many attributes, setting the attribute twice should add
; another value.
!!=     %["iceman@plunder.tech" "alias@example.com"]
    | lookupByIdentA ":c/email" "iceman@plunder.tech" ":c/email" changedEmailDB

; We should be able to lookup an entity by indexed attribute.
!!=   %[7]
    | lookupByAV ":c/name" "Iceman" contactsDB

; TODO: Once we return errors instead of just dying on exceptions, test:
;
; - trying to lookup by non-:db/unique attribute errors
; - trying to lookup by non-existent attribute errors
; - trying to looukp an av pair by unindexed attribute.

; TODO: Once we return errors instead of just dying on exceptions, also
;
; - validate uniqueness during a new validation pass.

; TODO: Retraction is entirely untested and might not work. Pound on that code
; path with tests.

""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^
^-^ DB emptyDB
^-^
^-^ ENT TMP LOOKUP
^-^ NEWENTITY ADD RETRACT
^-^
^-^ lookupByEA lookupByAE lookupByAV transact

