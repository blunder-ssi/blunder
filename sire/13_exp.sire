; Copyright 2023 The Plunder Authors
; Use of this source code is governed by a BSD-style license that can be
; found in the LICENSE file.

### 13_exp <- 12_tab

;;;; Sire Expressions
;;;; ================
;;;;
;;;; This is a collection of utilities for working with Rex trees that
;;;; represent Sire expressions.
;;;;
;;;; This is initially useful for writing macros, but should also be
;;;; useful in sire-in-sire once that's fully working.


;;; Imports ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

/+  01_fan
/+  02_bit  [if else or ifNot FALSE and not]
/+  03_nat  [even add mod sub mul]
/+  05_row  [len idx get put]
/+  04_cmp  [eql neq isZero]
/+  05_row  [v1 v2 v3 foldr map rowApply]
/+  06_rex  [rexHeir rexEmbd rexSons rexText rexRune]
/+  06_rex  [rexIsLeaf rexIsEmbd rexIsNode]
/+  06_rex  [WORD EMBD NEST OPEN PREF CORD]
/+  06_rex  [rexGetWord rexKids rexStyle {``}]
/+  06_rex  [rexGetNodeWithRune rexGetKidsOfNodeWithRune]
/+  06_rex  [rexGetWordNoHeir rexSetHeir]
/+  07_dat
/+  08_sci  []
/+  09_chr  [isAlpha isDigit]
/+  10_str  [strCat explode strWeld]
/+  11_set  ['%']
/+  12_tab  [tabToPairs '#' tabE]


;;; Parsing and Printing Nats ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(showNat n)=(strCat digits-n)

(showDigit d)=(add d '0')

(loadDigit chr)=(mod (sub chr '0') 10)

= (getDigit chr fall ret)
@ res (**loadDigit chr)
| ifNot (eql chr (**showDigit res)) fall
| **ret res

> Str > a > (Nat > a) > a
= (getNatStr str fall ret)
| if (isZero str) fall
| rowTraverse (c r)&(**getDigit c fall r) (explode str)
& nums
^ ret (idx 1 (foldr _ [1 0] nums))
? (f elem rest)
@ pos (idx 0 rest)
@ acc (idx 1 rest)
++ mul 10 pos
++ add acc (mul pos elem)

;;

= rnWord | "Expected a bare word"
= rnNumb | "Invalid number literal"

= (readNat rex err ret)
| rexGetWordNoHeir rex (err rex rnWord)
& text
| getNatStr text       (err rex rnNumb)
& numb
| ret numb

= cenOneKid | "% literals must have one kid"
= cenWord   | "% literals expect a word (and no heir)"

= (readAtomLit rex err ret)
| ifNot (isZero rexHeir-rex)
        | err rex "Unexpected heir"
| if (rexIsEmbd rex)
        @ val (rexEmbd rex)
        | ifNot (isNat val)
                | err rex "Embed fan is not a number"
        | ret val
| if (rexIsLeaf rex)
        | if (eql "WORD" (rexStyle rex))
                | readNat rex err ret
        | else
                | ret (rexText rex)
| else
        | rexGetKidsOfNodeWithRune "%" rex
                | err rex "Expected a %234 literal"
        & kids
        | if (neq 1 len-kids)
                | err rex cenOneKid
        | rexGetWord (idx 0 kids) (err rex cenWord)
        & (text heir)
        | if (neq 0 heir) (err rex cenWord)
        | ret text


!!= 1  | getDigit "1"  [] id
!!= 5  | getDigit "5"  [] id
!!= 9  | getDigit "9"  [] id
!!= [] | getDigit "a"  [] id
!!= [] | getDigit ""   [] id
!!= [] | getDigit "10" [] id

!!= 123 | getNatStr "123" [] id
!!= []  | getNatStr ""    [] id
!!= 0   | getNatStr "0"   [] id
!!= 1   | getNatStr "1"   [] id
!!= []  | getNatStr "a"   [] id

!!= 345           | readNat ``345 v2 id
!!= 0             | readNat ``0   v2 id
!!= [``[] rnWord] | readNat ``[]  v2 id
!!= [``a  rnNumb] | readNat ``a   v2 id

!!= 345                | readAtomLit ``345     v2 id
!!= %asdf              | readAtomLit ``(%asdf) v2 id
!!= %asdf              | readAtomLit ``"asdf"  v2 id
!!= [``(%) cenOneKid]  | readAtomLit ``(%)     v2 id
!!= [``(%(.)) cenWord] | readAtomLit ``(%(.))   v2 id


;;; Expresssions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= (natE n)         | WORD (showNat n) 0
= (varE v)         | WORD v 0
= (cnsE v)         | EMBD v
= (barE xs)        | NEST "#|" xs 0
= (letE i x b)     | OPEN "#@"  [varE-i    x] b
= (recE i x b)     | OPEN "#@@" [varE-i    x] b
= (txtE t)         | CORD t 0
= (tmpName s n)    | strCat ["_" s showNat-n]
= (tmpVarE s n)    | varE (tmpName s n)
= (sigE r)         | if (eql 1 len-r) varE-(idx 0 r) (NEST "|" (map varE r) 0)
= (lamE rs b)      | OPEN "#&"  [(sigE rs)] b
= (wutE rs b)      | OPEN "#?"  [(sigE rs)] b
= (wutWutE rs b)   | OPEN "#??" [(sigE rs)] b

= (**generateUniqueKey st ok)
@ nex | get st 0
@ st  | put st 0 (inc nex)
| **ok st nex

= (**generateTempName name st ok)
| generateUniqueKey st
& (st nex)
| **ok st (tmpName name nex)

= (**generateVarE name st ok)
| generateUniqueKey st
& (st nex)
| **ok st (tmpVarE name nex)

(**generateTempAnon st ok)=(generateTempName "g" st ok)
(**generateAnonVarE st ok)=(generateVarE "g" st ok)

= (inlinedLamE f rs b)
^ OPEN "#?" [_] b
^ NEST "|" (rowCons _ | map varE rs) 0
| PREF "**" [(varE f)] 0


;;; Bloodlines ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Given a list of rex nodes, make each one the heir of the last.
> List Rex > Rex
(bloodline lis)=(listFoldr (i r & rexSetHeir r i) 0 lis)

!!= ``((a=1)(b=2)(c=3))
  | bloodline [``(a=1) [``(b=2) [``(c=3) 0]]]


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= (readNodeWithRune rune rex err ret)
| **rexGetNodeWithRune rune rex
        | err rex
        | strCat ("Expected a ", rune, " node")
| ret

= (readKidsOfNodeWithRune rune rex err ret)
| **rexGetKidsOfNodeWithRune rune rex
        | err rex
        | strCat ("Expected a ", rune, " node")
| ret


= (readNodeWithoutHeirButWithRune rune rex err ok)
| **readNodeWithRune rune rex err
& (sons heir)
| if (neq 0 heir)
        | err heir
        | strCat ("Unexpected heir on ", rune, " node")
| **ok sons

= needBar | "Expected a | node"

!!= [``3 ``4]         | readNodeWithoutHeirButWithRune {,} ``[3 4] v2 id
!!= [``[3 4] needBar] | readNodeWithoutHeirButWithRune {|} ``[3 4] v2 id
!!= [``[3 4] needBar] | readNodeWithoutHeirButWithRune {|} ``[3 4] v2 id



;;; Sire Symbols ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= (isSymbolChar c)
| or eql-"_"-c
| or isAlpha-c
     isDigit-c

= (strIsSymbol str)
| if (isZero str) FALSE
@ chars explode-str
@ c0 idx-0-chars
| and (not isDigit-c0)
| all isSymbolChar chars

= (rexIsSymbol rex)
| rexGetWord rex 0
& (word heir)
| and (isZero heir)
      (strIsSymbol word)

= badSymChar | "Invalid Character in Symbol"
= badSymHeir | "Unexpected heir on symbol"
= badSymBare | "expected a bare word"

= (readWord rex err ok)
| rexGetWord rex (err rex "Expected a word") ok

symTodo='todo: support .foo and .234'

= (readSymbol rex err ok)
@ rune (rexRune rex)
@ kids (rexKids rex)
@ nKid (len kids)
| if (eql {.} rune)
    | if (neq 1 nKid)
        | err rex "Should be .x, .5, .{x}, etc"
    @ kid (idx 0 kids)
    | ifNot (rexIsLeaf kid)
        | err rex "Should be .x, .5, .{x}, etc"
    | if (eql "WORD" | rexStyle kid)
        | err rex symTodo
    | ok (rexText kid)
| rexGetWord rex | (err rex badSymBare)
& (word heir)
| if (neq 0 heir) | (err rex badSymHeir)
| ifNot strIsSymbol-word | (err rex badSymChar)
| ok word

!!= ["asdf"]         ^ readSymbol _ v2 v1 | ``(.{asdf})
!!= [" "]            ^ readSymbol _ v2 v1 | ``(.' ')
!!= [""]             ^ readSymbol _ v2 v1 | ``(."")
!!= [``(.x) symTodo] ^ readSymbol _ v2 v1 | ``(.x)
!!= [``(.1) symTodo] ^ readSymbol _ v2 v1 | ``(.1)

= (litE nat)
| if (strIsSymbol nat) (txtE nat)
| natE nat


;;; Sire Law Signatures ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= (rexParseRow rexRow readRow err ok)
^ rowTraverse _ (zip readRow rexRow) ok
? (step pair ret)
@ read (idx 0 pair)
@ rex  (idx 1 pair)
| read rex err ret

= (rexParseSonsRow rex readers err ok)
| ifNot (rexIsNode rex)
    | err rex "Expected a node"
@ sons (rexSons rex)
| if (neq len-readers len-sons)
    | err rex
    | strCat ("Expecting ", showNat len-readers, " sons")
| rexParseRow sons readers err ok

= (rexParseSons rex readers err ok)
| rexParseSonsRow rex readers err (rowApply ok)

= (rexParseKidsRow rex readers err ok)
| ifNot (rexIsNode rex)
    | err rex "Expected a node"
@ kids (rexKids rex)
| if (neq len-readers len-kids)
    | err rex
    | strCat ("Expecting ", showNat len-readers, " kids")
| rexParseRow kids readers err ok

= (rexParseKids rex readers err ok)
| rexParseKidsRow rex readers err (rowApply ok)



;;; Read Row of Names ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= nrBadForm | "Patterns must be a symbol (x) or a row of: (x,y,z)"
= nrBadHeir | "Name-sequence cannot have an heir"

= (readRowOfNames rex err ok)
| if (rexIsNode rex)
    | if (neq (rexRune rex) ",") | err rex nrBadForm
    | if (neq (rexHeir rex) 0)   | err rex nrBadHeir
    @ step
        ? (step son ret)
        | readSymbol son err ret
    | rowTraverse step (rexSons rex) ok
| if (eql "WORD" rexStyle-rex)
    | readSymbol rex err
    & sym
    | ok [sym]
| else
    | err rex nrBadForm

!!= [%x]                 | readRowOfNames ``x        v2 id
!!= [%x]                 | readRowOfNames ``(x)      v2 id
!!= []                   | readRowOfNames ``[]       v2 id
!!= [%x]                 | readRowOfNames ``[x]      v2 id
!!= [%x %y]              | readRowOfNames ``[x y]    v2 id
!!= [%x %y %z]           | readRowOfNames ``[x y z]  v2 id
!!= [``9 badSymChar]     | readRowOfNames ``[x y 9]  v2 id
!!= [``() nrBadForm]     | readRowOfNames ``()       v2 id
!!= [``([][]) nrBadHeir] | readRowOfNames ``([][])   v2 id


;;; Exports ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

^-^
^-^ readNodeWithRune
^-^ readKidsOfNodeWithRune
^-^ readNodeWithoutHeirButWithRune
^-^
^-^ isSymbolChar strIsSymbol rexIsSymbol readSymbol
^-^ natE litE varE cnsE barE letE recE
^-^ sigE lamE wutE wutWutE
^-^ inlinedLamE
^-^ txtE appE
^-^
^-^ bloodline
^-^
^-^ showNat getNatStr readNat
^-^ showDigit loadDigit getDigit
^-^ readAtomLit
^-^
^-^ readRowOfNames
^-^ rexParseKids rexParseKidsRow
^-^ rexParseSons rexParseSonsRow
^-^
^-^ rowE tabE
^-^
^-^ tmpName tmpVarE
^-^ generateUniqueKey
^-^ generateTempName generateVarE
^-^ generateTempAnon generateAnonVarE
^-^
