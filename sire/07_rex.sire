;;; Copyright 2023 The Plunder Authors
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.

### 07_rex <- 06_row

"""
""" Rex Syntax Trees
""" ================
"""
""" This defines the representation for the Rex datajet.  Some utilities
""" for working with Rex values, and the {`} macro, for lisp-style
""" rex quoting.
"""
""" The need for data-jetting requires this representation to be somewhat
""" unconventional and unintuitive.  It is also by-far the most
""" complicated of the data-jets.  Hopefully it can eventually be
""" eliminated, but it is very useful for the time being.
"""


""" Imports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

/+  01_fan  [lawName trk]
/+  02_bit  [if ifNot or else]
/+  03_nat  []
/+  06_row  [idx len]
/+  04_cmp  [eql neq isZero]
/+  06_row  [weld map c1 v0 v1 v2 v4 v5]


""" Rex Representation (possibly data-jetted) """"""""""""""""""""""""""""""""""

"""
""" These are the datatypes that are used to represent Rex trees use in
""" the Sire macro system.
"""
""" Macros are passed Rex tress represented in this format, and are
""" expected to produce Rex trees represented in this way.
"""
""" All these basic Rex representations are defined using Scott
""" Encoding.
"""
""" Scott encoding is less efficient than tagged-array encoding, but
""" it makes sense in this context, since we haven't built up any of
""" the operations required to work with that representation.
"""
""" TODO: Clarify the above.  We already have `idx`, `len`, `if`, `eql`,
""" and row constructors.  Is that not enough?  It's possible that
""" this comment (and therefore the representation) is stale.  IIRC,
""" this module used to be very early in the bootstrapping sequence.
"""
""" TODO: If this representation is pointless, and we manage to get rid
""" of the Rex ids, would something like the following representation
""" be more appropriate?
"""
"""     (_Rex a b)=_Rex
"""
"""     = (EMBD x)                    | _Rex [x]
"""     = (LEAF style text heir)      | _Rex [style text heir]
"""     = (NODE style rune sons heir) | _Rex [style rune sons heir]
"""
""" This representation:
"""
""" 1)  Is still data-jettable
""" 2)  Should be fairly efficient even unjetted.
""" 3)  Can be pretty-printed effectively even without a data-jet.
""" 4)  Can pretty-printing of rex trees that are not quite valid.
"""
""" That last point would address a curent sticking point, where
""" invalid rex has such insane printer-output, that it is difficult to
""" find the mistake.
"""
""" The printer could use the non-ASCII symbol ↑ for embedded values
""" and ↓ for invalid values.
"""
""" For example:
"""
"""     NODE {nest} {|} (LEAF {word} {hi} 0, EMBD 3, 4) 0
"""
""" Could be printed as:
"""
"""     (hi ↑3 ↓4)
"""
""" This doesn't conflict with an existing syntax, since Sire and Loot
""" only accept ASCII runes.
"""

= (R x)
| 0 'R' 3
| (0 (0 (0 x 1) 2) 3)

= EMBD (EMBD valu e l n ? e EMBD valu)

= WORD (WORD idnt text heir e l n ? l WORD idnt text heir)
= CORD (CORD idnt text heir e l n ? l CORD idnt text heir)
= TAPE (TAPE idnt text heir e l n ? l TAPE idnt text heir)
= LINE (LINE idnt text heir e l n ? l LINE idnt text heir)
= PAGE (PAGE idnt text heir e l n ? l PAGE idnt text heir)
= CURL (CURL idnt text heir e l n ? l CURL idnt text heir)

= OPEN (OPEN idnt rune sons heir e l n ? n OPEN idnt rune sons heir)
= NEST (NEST idnt rune sons heir e l n ? n NEST idnt rune sons heir)
= INFX (INFX idnt rune sons heir e l n ? n INFX idnt rune sons heir)
= PREF (PREF idnt rune sons heir e l n ? n PREF idnt rune sons heir)
= SHUT (SHUT idnt rune sons heir e l n ? n SHUT idnt rune sons heir)

;;;;;;;;;;

embd=EMBD
word=WORD
cord=CORD
tape=TAPE
line=LINE
page=PAGE
brak=CURL
open=OPEN
nest=NEST
infx=INFX
pref=PREF
shut=SHUT

= (EMBD valu) | R | embd valu

= (WORD text heir) | R | word 0 text heir
= (CORD text heir) | R | cord 0 text heir
= (TAPE text heir) | R | tape 0 text heir
= (LINE text heir) | R | line 0 text heir
= (PAGE text heir) | R | page 0 text heir
= (CURL text heir) | R | brak 0 text heir

= (OPEN rune sons heir) | R | open 0 rune sons heir
= (NEST rune sons heir) | R | nest 0 rune sons heir
= (INFX rune sons heir) | R | infx 0 rune sons heir
= (PREF rune sons heir) | R | pref 0 rune sons heir
= (SHUT rune sons heir) | R | shut 0 rune sons heir

;;;;;;;;;;

= (rexConstr rex)
@ E ? (E c v)       | c
@ L ? (L c i t h)   | c
@ N ? (N c i r s h) | c
| rex E L N

;;;;;;;;;;

= (rexRune rex)
@ E ? (E c v)       | 0
@ L ? (L c i t h)   | 0
@ N ? (N c i r s h) | r
| rex E L N

= (rexSetRune newRune rex)
@ E ? (E c v)       | rex
@ L ? (L c i t h)   | rex
@ N ? (N c i r s h) | R | c i newRune s h
| rex E L N

;;;;;;;;;;

= (rexHeir rex)
@ E ? (E c v)       | 0
@ L ? (L c i t h)   | h
@ N ? (N c i r s h) | h
| rex E L N

= (rexSetHeir newHeir rex)
@ E ? (E c v)       | rex
@ L ? (L c i t h)   | R | c i t newHeir
@ N ? (N c i r s h) | R | c i r s newHeir
| rex E L N

;;;;;;;;;;

= (rexText rex)
@ E ? (E c v)       | 0
@ L ? (L c i t h)   | t
@ N ? (N c i r s h) | 0
| rex E L N

= (rexSetText newText rex)
@ E ? (E c v)       | rex
@ L ? (L c i t h)   | R | c i newText h
@ N ? (N c i r s h) | rex
| rex E L N

;;;;;;;;;;

= (rexSons rex)
@ E ? (E c v)       | 0
@ L ? (L c i t h)   | 0 0 1 0
@ N ? (N c i r s h) | s
| rex E L N

= (rexSetSons newSons rex)
@ E ? (E c v)       | rex
@ L ? (L c i t h)   | rex
@ N ? (N c i r s h) | R | c i r newSons h
| rex E L N

;;;;;;;;;;

= (rexEmbd rex)
@ E ? (E c v)       | v
@ L ? (L c i t h)   | 0
@ N ? (N c i r s h) | 0
| rex E L N

= (rexSetEmbd newVal rex)
@ E ? (E c v)       | R | c newVal
@ L ? (L c i t h)   | rex
@ N ? (N c i r s h) | rex
| rex E L N

;;;;;;;;;;

= (rexIsEmbd rex)
@ E ? (E c v)       | 1
@ L ? (L c i t h)   | 0
@ N ? (N c i r s h) | 0
| rex E L N

= (rexIsLeaf rex)
@ E ? (E c v)       | 0
@ L ? (L c i t h)   | 1
@ N ? (N c i r s h) | 0
| rex E L N

= (rexIsNode rex)
@ E ? (E c v)       | 0
@ L ? (L c i t h)   | 0
@ N ? (N c i r s h) | 1
| rex E L N


""" Basic Shape Queries """"""""""""""""""""""""""""""""""""""""""""""""""""""""

= (rexType rex)
@ E ? (E c v)       | "EMBD"
@ L ? (L c i t h)   | "LEAF"
@ N ? (N c i r s h) | "NODE"
| rex E L N

= (rexGetNode rex fallback ok)
@ E ? (E c v)       | fallback
@ L ? (L c i t h)   | fallback
@ N ? (N c i r s h) | ok r s h
| rex E L N

= (rexGetLeaf rex fallback ok)
@ E ? (E c v)       | fallback
@ L ? (L c i t h)   | ok t h
@ N ? (N c i r s h) | fallback
| rex E L N

= (rexGetEmbd rex fallback ok)
@ E ? (E c v)       | ok v
@ L ? (L c i t h)   | fallback
@ N ? (N c i r s h) | fallback
| rex E L N


""" Definitions """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (rexStyle rex)
@ E ? (E c v)       | lawName c
@ L ? (L c i t h)   | lawName c
@ N ? (N c i r s h) | lawName c
| rex E L N

= (rexGetWord rex fall ok)
| if (neq "WORD" rexStyle-rex) fall
| rexGetLeaf rex fall ok

= (rexGetWordNoHeir rex fall ok)
| if (neq "WORD" rexStyle-rex) fall
| rexGetLeaf rex fall
& (text heir)
| if (neq 0 heir) fall
| ok text

= (rexGetText rex fall ok)
@ style (rexStyle rex)
@ expected | or (eql style "TAPE")
                (eql style "CORD")
| ifNot expected fall
| rexGetLeaf rex fall ok

= (rexGetAnyText rex fall ok)
@ style (rexStyle rex)
@ expected | or (eql style "TAPE")
           | or (eql style "CORD")
           | or (eql style "PAGE")
                (eql style "LINE")
| ifNot expected fall
| rexGetLeaf rex fall ok

= (rexGetNodeWithRune rune rex fall ret)
| rexGetNode rex fall
& (r s h)
| if (neq r rune) fall
| ret s h

= (rexGetKidsOfNodeWithRune rune rex fall ok)
| rexGetNodeWithRune rune rex fall
& (s h)
@ kids (if (isZero h) s (weld s (c1 h)))
| ok kids

= (rexKids rex)
@ sons (rexSons rex)
@ heir (rexHeir rex)
| if (isZero heir) sons
| weld sons (c1 heir)


""" Equality """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

;
; Applies a function to every node (including leaves and embeded
; fan values) of a Rex tree.  The function is applied to leaves first,
; then to the nodes containing them.
;
; The fan values contained in EMBD nodes are not traversed.
;
= (rexEvery f rex)
@ E
        ? (E c v)
        | f rex
@ L
        ? (L c i t h)
        @ h (if (isZero h) 0 (rexEvery f h))
        | f | R | c i t h
@ N
        ? (N c i r s h)
        @ s (map (rexEvery f) s)
        @ h (if (isZero h) 0 (rexEvery f h))
        | f | R | c i r s h
| rex E L N

; Changes the layout-style of a rex tree to closed-form by converting
; every OPEN node into a NEST node.
= (rexClose topRex)
^ rexEvery _ topRex
& rex
| if (neq "OPEN" rexStyle-rex) rex
| NEST
    rexRune-rex
    rexSons-rex
    rexHeir-rex


""" Helpers """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (rexGuts rex)
@ heir (rexHeir rex)
| if rexIsNode-rex
    | v5 (rexStyle rex)
         (rexRune rex)
         (map rexGuts (rexSons rex))
         (if (isZero heir) heir (rexGuts heir))
| if rexIsLeaf-rex
    | v4 (rexStyle rex)
         (rexText rex)
         (if (isZero heir) heir (rexGuts heir))
| else
    | v1 (rexEmbd rex)



""" Quoting """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= ("`" s p e a r err ok)
@ args (rexKids r)
| if (neq 1 len-args)
    | **err r "Expected 1 Parameter"
| **ok p a
| EMBD (idx 0 args)


""" Tests """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

!!= | OPEN "&" v0 0
  | OPEN "&" v0 0

!!= | OPEN "*" v0 0
  | rexSetRune "*"
  | OPEN "-" v0 0

wx=(WORD "x" 0)
w9=(WORD "9" 0)
hi=(TAPE "hi" 0)
yo=(CORD "yo" 0)
rw=(NEST "," v0 0)
e6=(EMBD 6)
sx=(OPEN "=" (v2 wx w9) 0)

!!= 0 (rexIsNode hi)
!!= 0 (rexIsNode yo)
!!= 0 (rexIsNode e6)
!!= 1 (rexIsNode sx)
!!= 1 (rexIsNode rw)
!!= 0 (rexIsEmbd hi)
!!= 0 (rexIsEmbd sx)
!!= 1 (rexIsEmbd e6)
!!= 1 (rexIsLeaf hi)
!!= 1 (rexIsLeaf yo)
!!= 1 (rexIsLeaf wx)
!!= 0 (rexIsLeaf e6)
!!= 0 (rexIsEmbd sx)
!!= 0 (rexIsEmbd sx)

(w x)=(WORD x 0)

= (nestAnd rune sons heir) | NEST rune sons heir
= (nestNod rune sons)      | NEST rune sons 0


!!= 1 | eql `3        | (w "3")
!!= 1 | eql `(3 4)    | nestNod "|" (v2 (w "3") (w "4"))
!!= 1 | eql `([a][b]) | nestAnd "," (v1 (w "a"))
                      | nestNod "," (v1 (w "b"))
!!= 1
  | eql
      | NEST "*" (v2 (WORD "hi" 0) (WORD "yo" 0))
      | WORD ""
      | WORD "heh"
      | 0
  | NEST "*" (v2 (WORD "hi" 0) (WORD "yo" 0))
  | WORD ""
  | WORD "heh"
  | 0

!!= "NEST" | rexStyle ` []
!!= "WORD" | rexStyle ` hi
!!= "TAPE" | rexStyle ` ""
!!= "CORD" | rexStyle ` ''
!!= "LINE" | rexStyle ` '''
!!= "PAGE" | rexStyle ` """
!!= "CURL" | rexStyle ` {}


""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^
^-^ R
^-^ EMBD
^-^ WORD CORD TAPE LINE PAGE CURL
^-^ OPEN NEST INFX PREF SHUT
^-^
^-^ rexIsNode rexIsLeaf rexIsEmbd
^-^
^-^ rexConstr
^-^ rexRune rexSetRune
^-^ rexHeir rexSetHeir
^-^ rexText rexSetText
^-^ rexSons rexSetSons
^-^ rexEmbd rexSetEmbd
^-^ rexKids
^-^
^-^ rexType rexStyle
^-^ rexGetEmbd rexGetLeaf rexGetNode
^-^ rexGetWord rexGetWordNoHeir
^-^ rexGetText rexGetAnyText
^-^ rexGetNodeWithRune
^-^ rexGetKidsOfNodeWithRune
^-^
^-^ rexEvery rexClose rexGuts
^-^
^-^ "`"
^-^
