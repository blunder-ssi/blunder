;;; Copyright 2023 The Plunder Authors
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.

### jlex <- io

/+  boot
/+  switch  ["#switch"]
/+  mutrec  ["#mutrec"]
/+  datatype
/+  types
/+  stew


""" Lexems """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

abstype#(Result2 a b) ; type (Result2 a b) = (Or Str (a, b))
abstype#(Opt2 a b)    ; type (Opt2 a b)    = (Or Zero (a, b))

typedef#Deci#(Opt2 Nat Nat)
typedef#Expo#(Opt2 Nat Nat)

# datatype JLexeme
* ( TSPACE = space  )
* ( TNULL  = null   )
* ( TTRUE  = true   )
* ( TFALSE = false  )
* ( TCOMMA = comma  )
* ( TCOLON = colon  )
* ( TLBRAK = l_brak )
* ( TRBRAK = r_brak )
* ( TLCURL = l_curl )
* ( TRCURL = r_curl )
* ( TSTR   = str    ) str:Bar
* ( TNUM   = num    ) neg:Bit num:Nat dec:Deci exp:Expo
* ( TERR   = err    ) off:Nat why:Str


""" Consume Whitespace """""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (chomp input off)
# switch (barIdx off input)
* 32 | chomp input (inc off)
* 9  | chomp input (inc off)
* 10 | chomp input (inc off)
* 13 | chomp input (inc off)
* _  | off

!!= 7 (chomp b#'	  	   xyz' 0)


""" Lex Strings """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (lexStringLoop input top off)
@ off (barElemIndexOff '"' off input)
| if (eql off barLen-input)
    | 'Unexpected EOF (string)'
@ (countSlashes off count)
    | if (eql '\' | barIdx off input)
        | countSlashes (dec off) (inc count)
    | count
@ numSlashes | **countSlashes (dec off) 0
| if (and (gth numSlashes 0) (mod numSlashes 2))
    | lexStringLoop input top (inc off)
| else
    @ tok (**TSTR (barSlice top (sub off top) input))
    | (tok, inc off)

(lexString input off)=(lexStringLoop input off off)

!!= (TSTR b#{fdsafdsa}, 10)
  | lexString b#{"fdsafdsa"} 1

!!= (TSTR b#'fdsafdsa\"more', 16)
  | lexString b#'"fdsafdsa\"more"' 1

; TODO: Sol says that escaping slashes wasn't intended in the parser for {}
; literals. Remove that later.
!!= (TSTR b#'fdsafdsa\\', 12)
  | lexString b#{"fdsafdsa\\\\"} 1

!!= 'Unexpected EOF (string)'
  | lexString b#'"fdsafdsa\"more' 1


""" Lex Numbers """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (consumeDigits input startOff)
^ _ 0 startOff
? (loop acc off)
@ chr (barIdx off input)
| ifNot (isDigit chr) [acc off]
@ !acc (add (sub chr 48) (mul 10 acc))
| loop acc (inc off)

!!= [1234 5] (consumeDigits b#'+1234+' 1)
!!= [0 0]    (consumeDigits b#'+1234+' 0)


""" Lex Strings of Zeros """""""""""""""""""""""""""""""""""""""""""""""""""""""

= (consumeZeros input startOff)
^ _ 0 startOff
? (go !count off)
| if ('0' == barIdx off input)
    | go (inc count) (inc off)
| [count off]

!!= [0 0] | consumeZeros b#{+0000+} 0
!!= [4 5] | consumeZeros b#{+0000+} 1
!!= [3 5] | consumeZeros b#{+0000+} 2


""" Lex Decimal Part """""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= noDig | 'No digits after dot (.)'

; This can't be turned into inlined-continuation-passing-style because
; we have two places where we return successfully, and the short-circult
; case is the common case, so we don't want to just do the whole thing
; each time.
;
; Inlining this anyways doesn't make things faster, because it's used
; in the body of a let-binding, so all of the branches become calls to
; `if` instead of being a part of the law's code.
;
> Bar > Nat > Result2 Deci Nat
= (lexDecimal input off)
| ifNot ('.' == barIdx off input) [0 off]
;
@ off            | inc off
@ [numZeros zof] | **consumeZeros input off
@ [nat dof]      | **consumeDigits input zof
;
| if (dof == off) noDig
| [[numZeros nat] dof]

!!= [[2 33] 6] | lexDecimal b#'#.0033#' 1
!!= [[1 0 ] 3] | lexDecimal b#'#.0#'    1
!!= [[0 1 ] 3] | lexDecimal b#'#.1#'    1
!!= [0      1] | lexDecimal b#'##'      1
!!= [0      1] | lexDecimal b#'#e2#'    1
!!= noDig      | lexDecimal b#'#.#'     1


""" Lex Exponent Part """"""""""""""""""""""""""""""""""""""""""""""""""""""""""

;
; optional exponent. {e,E}{-,+,[nothing]}[digits]
;

= noDig | 'No digits in exponent'

;
; This can't be turned into inlined-continuation-passing-style because
; we have two places where we return successfully, and the short-circult
; case is the common case, so we don't want to just do the whole thing
; each time.
;
; if we were to just inline this anyways, that doesn't make things faster,
; because it's used in the body of a let-binding, so all of the branches
; become calls to `if` instead of being a part of the law's code.
;
> Bar > Nat > Result2 Expo Nat
= (lexExponent input off)
;
@ chr    (barIdx off input)
@ hasExp ((chr == 'e') || (chr == 'E'))
;
| ifNot hasExp [0 off]
@ off    (inc off)
;
@ chr    (barIdx off input)
@ nega   (chr == '-')
@ posi   (chr == '+')
@ signed (nega || posi)
@ off    (add off signed)
;
@ [nat dof] (**consumeDigits input off)
;
| if (dof == off) noDig
;
| [[nega nat] dof]

!!= [[0  0] 3] | lexExponent b#'#e0#'   1
!!= [[0  0] 4] | lexExponent b#'#e00#'  1
!!= [[0  0] 5] | lexExponent b#'#e+00#' 1
!!= [[1  0] 5] | lexExponent b#'#e-00#' 1
!!= [[1  1] 5] | lexExponent b#'#e-01#' 1
!!= [[1 10] 5] | lexExponent b#'#e-10#' 1
!!= [[1 11] 5] | lexExponent b#'#e-11#' 1
!!= noDig      | lexExponent b#'#e-#'   1
!!= noDig      | lexExponent b#'#e+#'   1
!!= noDig      | lexExponent b#'#e#'    1
!!= [0 0]      | lexExponent b#'#e00#'  0
!!= [0 1]      | lexExponent b#'#g00#'  1


""" Lexer JSON """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (lexJson input)
^ _ 0
? (loop off)
# switch (barIdx off input)
* 0
    | NIL
* n
    | ifNot (b#null == barSlice off 4 input) 0
    | (TNULL, loop (add 4 off))
* t
    | ifNot (b#true == barSlice off 4 input) 0
    | (TTRUE, loop (add 4 off))
* f
    | ifNot (b#false == barSlice off 5 input) 0
    | (TFALSE, loop (add 5 off))
;
* ',' (TCOMMA, loop (inc off))
* ':' (TCOLON, loop (inc off))
* '[' (TLBRAK, loop (inc off))
* ']' (TRBRAK, loop (inc off))
* '{' (TLCURL, loop (inc off))
* '}' (TRCURL, loop (inc off))
;
* '"'
    @ res (**lexString input (inc off))
    | if res (**TERR off res, 0)
    @ [tok off] res
    [tok (loop off)]
;
* 32 (TSPACE, loop (chomp input | inc off))
* 9  (TSPACE, loop (chomp input | inc off))
* 10 (TSPACE, loop (chomp input | inc off))
* 13 (TSPACE, loop (chomp input | inc off))
* _
    @ fst       | barIdx off input
    @ neg       | eql {-} fst
    @ off       | add neg off ; add bit+number to avoid branching.
    @ chr       | barIdx off input
    @ [nat dof] | **consumeDigits input off
    | if (dof == off)
        | if neg (**TERR off 'Bad number, no digits', 0)
        | (**TERR off 'Unexpected Character', 0)
    ;
    @ off               | dof
    @ [deci off]@decRes | lexDecimal input off
    | if decRes (**TERR off decRes, 0)
    @ [expi off]@expRes | lexExponent input off
    | if expRes (**TERR off expRes, 0)
    ;
    | (**TNUM neg nat deci expi, loop off)

!!= (listToRow | lexJson b#'{"x":999}')
 ++ TLCURL
 ++ TSTR b#x
 ++ TCOLON
 ++ TNUM FALSE 999 0 0
 ++ TRCURL

!!= (listToRow | lexJson b#'{"x":-999}')
 ++ TLCURL
 ++ TSTR b#x
 ++ TCOLON
 ++ TNUM TRUE 999 0 0
 ++ TRCURL

!!= (listToRow | lexJson b#'{"x":9.9}')
 ++ TLCURL
 ++ TSTR b#x
 ++ TCOLON
 ++ TNUM FALSE 9 [0 9] 0
 ++ TRCURL

!!= (listToRow | lexJson b#'{"x":9e9}')
 ++ TLCURL
 ++ TSTR b#x
 ++ TCOLON
 ++ TNUM FALSE 9 0 [0 9]
 ++ TRCURL

!!= (listToRow | lexJson b#'{"x":09.09e9}')
 ++ TLCURL
 ++ TSTR b#x
 ++ TCOLON
 ++ TNUM FALSE 9 [1 9] [0 9]
 ++ TRCURL

!!= (listToRow | lexJson b#' { "x" : 999 } ')
 ++ TSPACE
 ++ TLCURL
 ++ TSPACE
 ++ TSTR b#x
 ++ TSPACE
 ++ TCOLON
 ++ TSPACE
 ++ TNUM FALSE 999 0 0
 ++ TSPACE
 ++ TRCURL
 ++ TSPACE


""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^
^-^ lexJson
^-^
^-^ TSPACE TNULL TTRUE TFALSE
^-^ TCOMMA TCOLON
^-^ TLBRAK TRBRAK TLCURL TRCURL
^-^ TSTR TNUM
^-^
