; Copyright 2023 The Plunder Authors
; Use of this source code is governed by a BSD-style license that can be
; found in the LICENSE file.

### 06_rex <- 05_row

"""
""" Rex Syntax Trees
""" ================
"""
""" This defines the representation for the Rex datajet.  Some utilities
""" for working with Rex values.  It also includes the {``} macro,
""" for lisp-style rex quoting.
"""
"""
""" Jetting
""" -------
"""
""" The Rex data jet is VERY much optional, and probably has a significant
""" negative effect on performance.  This is made jettable so that an
""" implementation of Sire in a host system can move data back-and-forth
""" with the macros without constantly re-validating the whole tree.
"""
""" An implementation without a built-in Sire implementation should
""" probably not jet any of this.
"""


;;; Imports ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

/+  01_fan  [lawName lawBody trk]
/+  02_bit  [if ifNot or else and]
/+  03_nat  [dec]
/+  04_cmp  [eql neq isZero]
/+  05_row  [idx len put switch null mut]
/+  05_row  [weld map c1 v0 v1 v2 v3 v4 v5]


;;; Rex Representation (possibly data-jetted) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(REX form)=(0 '_Rex' 1 form)

(EMBD val)=(REX | v1 val)

(WORD text heir)=(REX | v3 {WORD} text heir)
(CORD text heir)=(REX | v3 {CORD} text heir)
(TAPE text heir)=(REX | v3 {TAPE} text heir)
(LINE text heir)=(REX | v3 {LINE} text heir)
(PAGE text heir)=(REX | v3 {PAGE} text heir)
(CURL text heir)=(REX | v3 {CURL} text heir)

(OPEN rune sons heir)=(REX | v4 {OPEN} rune sons heir)
(NEST rune sons heir)=(REX | v4 {NEST} rune sons heir)
(INFX rune sons heir)=(REX | v4 {INFX} rune sons heir)
(PREF rune sons heir)=(REX | v4 {PREF} rune sons heir)
(SHUT rune sons heir)=(REX | v4 {SHUT} rune sons heir)

;;;;;;;;;;

= (rexRune rex)
@ dat (lawBody rex)
| if (neq 4 | len dat) 0
| idx 1 dat

= (rexSetRune newRune rex)
@ dat (lawBody rex)
| if (neq 4 | len dat) rex
| REX (put dat 1 newRune)

;;;;;;;;;;

= (rexHeir rex)
@ dat (lawBody rex)
@ wid (len dat)
@ las (dec wid)
| if (eql 1 wid) 0
| idx las dat

= (rexSetHeir newHeir rex)
@ dat (lawBody rex)
@ wid (len dat)
@ las (dec wid)
| if (eql 1 wid) rex
| REX (put dat las newHeir)

;;;;;;;;;;

= (rexText rex)
@ dat (lawBody rex)
| if (neq 3 | len dat) 0
| idx 1 dat

= (rexSetText newText rex)
@ dat (lawBody rex)
| if (neq 3 | len dat) rex
| REX (put dat 1 newText)

;;;;;;;;;;

= (rexSons rex)
@ dat (lawBody rex)
| if (neq 4 | len dat) 0
| idx 2 dat

= (rexSetSons newSons rex)
@ dat (lawBody rex)
| if (neq 4 | len dat) rex
| REX (put dat 2 newSons)

;;;;;;;;;;

= (rexEmbd rex)
@ dat (lawBody rex)
| if (neq 1 | len dat) 0
| idx 0 dat

= (rexSetEmbd newVal rex)
@ dat (lawBody rex)
| if (neq 1 | len dat) rex
| EMBD newVal

;;;;;;;;;;

(rexIsEmbd rex)=(eql 1 (len | lawBody rex))
(rexIsLeaf rex)=(eql 3 (len | lawBody rex))
(rexIsNode rex)=(eql 4 (len | lawBody rex))


;;; Basic Shape Queries ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= (rexType rex)
@ dat (lawBody rex)
| switch (len dat) 0
| v5 0 {EMBD} 0 {LEAF} {NODE}

= (rexGetNode rex fallback ok)
@ dat (lawBody rex)
| if (neq 4 | len dat) fallback
| ok (idx 1 dat) (idx 2 dat) (idx 3 dat)

= (rexGetLeaf rex fallback ok)
@ dat (lawBody rex)
| if (neq 3 | len dat) fallback
| ok (idx 1 dat) (idx 2 dat)

= (rexGetEmbd rex fallback ok)
@ dat (lawBody rex)
| if (neq 1 | len dat) fallback
| ok (idx 0 dat)


;;; Definitions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= (rexStyle rex)
@ dat (lawBody rex)
| if (eql 1 | len dat) "EMBD"
| idx 0 dat

= (rexGetWord rex fall ok)
| if (neq "WORD" rexStyle-rex) fall
| rexGetLeaf rex fall ok

= (rexGetWordNoHeir rex fall ok)
| if (neq "WORD" rexStyle-rex) fall
| rexGetLeaf rex fall
& (text heir)
| if (neq 0 heir) fall
| ok text

= (rexGetText rex fall ok)
@ style (rexStyle rex)
@ expected | or (eql style "TAPE")
                (eql style "CORD")
| ifNot expected fall
| rexGetLeaf rex fall ok

= (rexGetAnyText rex fall ok)
@ style (rexStyle rex)
@ expected | or (eql style "TAPE")
           | or (eql style "CORD")
           | or (eql style "PAGE")
                (eql style "LINE")
| ifNot expected fall
| rexGetLeaf rex fall ok

= (rexGetNodeWithRune rune rex fall ret)
| **rexGetNode rex fall
& (r s h)
| if (neq r rune) fall
| ret s h

= (rexGetKidsOfNodeWithRune rune rex fall ok)
| **rexGetNodeWithRune rune rex fall
& (s h)
@ kids (if (isZero h) s (weld s (c1 h)))
| ok kids

= (rexKids rex)
@ sons (rexSons rex)
@ heir (rexHeir rex)
| if (isZero heir) sons
| weld sons (c1 heir)


;;; Equality ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
; Applies a function to every node (including leaves and embeded
; fan values) of a Rex tree.  The function is applied to leaves first,
; then to the nodes containing them.
;
; The fan values contained in EMBD nodes are not traversed.
;
= (rexEvery f rex)
; trk (v2 {rex} rex)
| if (isZero rex) 0
@ dat (lawBody rex)
; trk (v2 {dat} dat)
@ embdCase
    | f rex
@ leafCase
    | f
    @ heir (idx 2 dat)
    | if (isZero heir) rex
    @ heir (rexEvery f heir)
    | REX (put dat 2 heir)
@ nodeCase
    @ sons (idx 2 dat)
    @ heir (idx 3 dat)
    | if (and (null sons) (isZero heir)) rex
    @ sons (map (rexEvery f) sons)
    @ heir (rexEvery f heir)
    | f | REX (| mut 2 sons | mut 3 heir | dat)
| switch (len dat) 0
| v5 0 embdCase 0 leafCase nodeCase

; Changes the layout-style of a rex tree to closed-form by converting
; every OPEN node into a NEST node.
= (rexClose topRex)
^ rexEvery _ topRex
& rex
@ sty (rexStyle rex)
| if (eql "LINE" sty) | CORD rexText-rex rexHeir-rex
| if (eql "PAGE" sty) | TAPE rexText-rex rexHeir-rex
| if (neq "OPEN" sty) | rex
| NEST (rexRune rex) (rexSons rex) (rexHeir rex)


;;; Quoting ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= ({``} st rex err ok)
@ args (rexKids rex)
| if (neq 1 len-args)
    | err rex "Expected 1 Parameter"
| ok st
| EMBD (idx 0 args)


;;; Tests ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

!!= | OPEN "&" v0 0
  | OPEN "&" v0 0

!!= | OPEN "*" v0 0
  | rexSetRune "*"
  | OPEN "-" v0 0

!!= `` (f [x y])[z]
  | rexClose
 `` | f , x y
    , z

wx=(WORD "x" 0)
w9=(WORD "9" 0)
hi=(TAPE "hi" 0)
yo=(CORD "yo" 0)
rw=(NEST "," v0 0)
e6=(EMBD 6)
sx=(OPEN "=" (v2 wx w9) 0)

!!= 0 (rexIsNode hi)
!!= 0 (rexIsNode yo)
!!= 0 (rexIsNode e6)
!!= 1 (rexIsNode sx)
!!= 1 (rexIsNode rw)
!!= 0 (rexIsEmbd hi)
!!= 0 (rexIsEmbd sx)
!!= 1 (rexIsEmbd e6)
!!= 1 (rexIsLeaf hi)
!!= 1 (rexIsLeaf yo)
!!= 1 (rexIsLeaf wx)
!!= 0 (rexIsLeaf e6)
!!= 0 (rexIsEmbd sx)
!!= 0 (rexIsEmbd sx)

(w x)=(WORD x 0)

= (nestAnd rune sons heir) | NEST rune sons heir
= (nestNod rune sons)      | NEST rune sons 0


!!= 1 | eql ``3        | (w "3")
!!= 1 | eql ``(3 4)    | nestNod "|" (v2 (w "3") (w "4"))
!!= 1 | eql ``([a][b]) | nestAnd "," (v1 (w "a"))
                       | nestNod "," (v1 (w "b"))
!!= 1
  | eql
      | NEST "*" (v2 (WORD "hi" 0) (WORD "yo" 0))
      | WORD ""
      | WORD "heh"
      | 0
  | NEST "*" (v2 (WORD "hi" 0) (WORD "yo" 0))
  | WORD ""
  | WORD "heh"
  | 0

!!= "NEST" | rexStyle `` []
!!= "OPEN" | rexStyle `` | x
!!= "WORD" | rexStyle `` hi
!!= "TAPE" | rexStyle `` ""
!!= "CORD" | rexStyle `` ''
!!= "LINE" | rexStyle `` '''
!!= "PAGE" | rexStyle `` """
!!= "CURL" | rexStyle `` {}

!!= ``"foobar" | rexClose `` """foobar


;;; Exports ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

^-^
^-^ REX
^-^ EMBD
^-^ WORD CORD TAPE LINE PAGE CURL
^-^ OPEN NEST INFX PREF SHUT
^-^
^-^ rexIsNode rexIsLeaf rexIsEmbd
^-^
^-^ rexRune rexSetRune
^-^ rexHeir rexSetHeir
^-^ rexText rexSetText
^-^ rexSons rexSetSons
^-^ rexEmbd rexSetEmbd
^-^ rexKids
^-^
^-^ rexType rexStyle
^-^ rexGetEmbd rexGetLeaf rexGetNode
^-^ rexGetWord rexGetWordNoHeir
^-^ rexGetText rexGetAnyText
^-^ rexGetNodeWithRune
^-^ rexGetKidsOfNodeWithRune
^-^
^-^ rexEvery rexClose
^-^
^-^ {``}
^-^
