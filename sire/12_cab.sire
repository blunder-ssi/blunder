;;; Copyright 2023 The Plunder Authors
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.

### 12_cab <- 11_str

"""
""" Cabs
""" ====
"""
""" A cab is a data-jetted set of nouns.
"""
""" Cabs are represented as a law of the form:
"""
"""     (0 0 n row)
"""
""" Where n is the length of the row+1, and the row is in ascending order
""" (according to `cmp`) and unique.
"""


""" Imports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

/+  01_fan
/+  02_bit  [if else ifNot and or not]
/+  03_nat  [add sub mul dec gteNat isZero]
/+  03_nat  [even odd]
/+  04_app  [idx get len]
/+  05_cmp  [eql neq lte lth gth gte]
/+  06_cow  [null weld v2 isRow map foldl foldr fst snd]
/+  07_rex
/+  08_dat
/+  09_sci  []
/+  10_chr  [isDigit ord chr]
/+  11_str  [strToList strWeld loadKeyWord loadDecimal]


""" Cabs """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= emptyCab         | 0 0 1 []
= (cabSing x)      | 0 0 2 [x]
= (cabIsEmpty cab) | eql 1 (lawArgs cab)
= (cabToRow cab)   | lawBody cab

!!= 1 | cabIsEmpty emptyCab
!!= 1 | not (cabIsEmpty | cabSing "a")

= (cabLen cab)    | len (cabToRow cab)
= (cabToList cab) | listFromRow (cabToRow cab)
= (cabHas k cab)  | has k (cabToRow cab)
= (cabMin cab)    | idx 0 (cabToRow cab)

; {cabFromRowSet} is an internal routine that expects to be given a
; "row set" a sorted row with no duplicates.
;
; {cabPort} ports a row operation to a cab.  For this to work, the row
; operation must always return a result that is in assending order and
; contains no duplicates.

= (cabFromRowSet row) | 0 0 (inc | len row) row
= (cabPort op cab)    | cabFromRowSet | op | cabToRow cab

; {cabPortSplit} ports a row splitting function (Row a > (Row a, Row a))
; to cabs.  Like {cabPort}, {cabPortSplit} expects both of the rows
; returned by the splitting function to be in assending order and contain
; no duplicates.

= (cabPortSplit op cab)
@ xy | op (cabToRow cab)
| (cabFromRowSet (fst xy), cabFromRowSet (snd xy))

= (cabFromRow row) | cabFromRowSet (sortUniq row)
= (cabIns itm c)   | cabFromRow (rowCons itm | cabToRow c)
= (cabDel itm c)   | cabFromRowSet (delete itm | cabToRow c)
= (cabPop c)       | (idx 0 c, cabFromRowSet (drop 1 | cabToRow c))
= (cabUnion a b)   | cabFromRow (weld (cabToRow a) (cabToRow b))
= (cabCatList l)   | listFoldl cabUnion emptyCab l
= (cabCatRow r)    | foldl cabUnion emptyCab r

; {cabAscUnions} expects a row of cabs, each strictly assending (the
; greatest element of one cab is smaller than the smallest element of
; the next).  If this invariant is violated, the result will not be a cab.

(cabAscUnions cs)=(cabFromRowSet | catMap cabToRow cs)

= (isOrderedWith chk row)
@ wid (len row)
^ _ (idx 0 row) 1
? (go las i)
| or (gteNat i wid)
@ cur (idx i row)
| and (chk las cur)
| go cur (inc i)

!!= 1 | isOrderedWith lth [0 1 2]
!!= 1 | isOrderedWith lte [0 0 1]
!!= 1 | isOrderedWith gth [3 2 1]
!!= 1 | isOrderedWith gte [3 3 2]
!!= 1 | isOrderedWith eql [3 3 3]
!!= 1 | isOrderedWith neq [3 4 2]

!!= 1 | isOrderedWith lth []
!!= 1 | isOrderedWith lth [0]
!!= 1 | isOrderedWith lth [0 1]
!!= 1 | isOrderedWith lth [0 1 [0]]
!!= 1 | isOrderedWith lth [0 1 2]
!!= 1 | isOrderedWith lth [1]
!!= 1 | isOrderedWith lth [1 2]
!!= 1 | isOrderedWith lth [1 2 3 4 5 999]
!!= 1 | isOrderedWith lth [1 2 const]
!!= 1 | isOrderedWith lth [1 2 const (0 0)]
!!= 1 | isOrderedWith lth [1 const]
!!= 1 | isOrderedWith lth [2]

!!= 0 | isOrderedWith lth [0 0]
!!= 0 | isOrderedWith lth [0 0 [0]]
!!= 0 | isOrderedWith lth [1 1]
!!= 0 | isOrderedWith lth [1 2 0]
!!= 0 | isOrderedWith lth [2 1]
!!= 0 | isOrderedWith lth [2 1 (die 'never evaluated')]
!!= 0 | isOrderedWith lth [1 1 (die 'never evaluated')]
!!= 1 | isOrderedWith lth []

= (isCab cab)
| and (isLaw cab)
@ arg (lawArgs cab)
@ nam (lawName cab)
@ bod (lawBody cab)
| and (eql 0 nam)
| and (isRow bod)
| and (eql arg (inc | len bod))
      (isOrderedWith lth bod)

= (cabElem i c)         | idx i (cabToRow c)
= (cabFoldl f z c)      | foldl f z (cabToRow c)
= (cabDrop n c)         | cabPort (drop n) c
= (cabTake n c)         | cabPort (take n) c
= (cabFilter f c)       | cabPort (filter f) c
= (cabSplitAt idx c)    | cabPortSplit (splitAt idx) c
= (cabSpan p c)         | cabPortSplit (span p) c
= (cabIntersect a b)    | cabFilter x&(cabHas x a) b
= (cabDiff a b)         | cabFoldl (c i & cabDel i c) a b
= (cabSplitLT key c)    | cabSpan (gth key) c


""" % Rune: Atoms, Tabs, and Cabs """"""""""""""""""""""""""""""""""""""""""""""

= (readKey rex err ok)
| if (neq 0 (rexHeir rex))
    | err rex (strWeld "Unexpected heir on key")
@ style (rexStyle rex)
| if (eql "WORD" style)
    | ok (loadKeyWord rexText-rex)
| if    | or (eql "TAPE" style)
        | or (eql "CORD" style)
        | or (eql "LINE" style)
        | or (eql "CURL" style)
             (eql "PAGE" style)
    | ok (rexText rex)
| if (eql "EMBD" style)
    @ fan (rexEmbd rex)
    | ifNot (isNat fan)
        | err rex "Invalid Key: Embeded fan value is not a natural"
    | ok fan
| err rex "Invalid Key: Expected a word, text, or an embeded natural"

!!= 'a' (readKey `"a"     v2 x&x)
!!= 'a' (readKey `a       v2 x&x)
!!= 9   (readKey `9       v2 x&x)
!!= 9   (readKey (EMBD 9) v2 x&x)

= (mkCenMacro doCab doTab s p e a r err ok)
@ fail (err r "% expects something like %foo or %[...]")
;;
@ heir (rexHeir r)
@ sons (rexSons r)
| if (neq 0 heir) fail
| if (neq 1 len-sons) fail
@ son (idx 0 sons)
;;
| if (eql "WORD" (rexStyle son))
    | ok p a (CORD 0 rexText-son 0)
;;
| ifNot (rexIsNode son) fail
| ifNot (eql {,} rexRune-son) fail
;;
@ grandsons (rexSons son)
| if (null grandsons)
    | ok p a (EMBD emptyCab)
| if (rexIsNode (idx 0 grandsons))
  (doTab s p e a r grandsons err ok)
  (doCab s p e a r grandsons err ok)

= (cenCab s p e a r kids err ok)
^ _ emptyCab (listFromRow kids)
? (go acc kidList)
| **listCase kidList (ok p a (EMBD acc))
& (thisKid moreKids)
@ unexpected
   | err thisKid
      """ A cab key literal must be one of:
      """
      """ -   String ('', 'x', 'text', ...)
      """ -   Number number (0, 3, 12341234, ...)
      """ -   Identifier (x, _Y_3, ...)
@ okay
    ? (okay newKey)
    | if (cabHas newKey acc)
        | err thisKid "duplicate key"
    | go (cabIns newKey acc) moreKids
@ style (rexStyle thisKid)
| if (eql "WORD" style)
    | okay (loadKeyWord rexText-thisKid)
| if    | or (eql "CORD" style)
        | or (eql "TAPE" style)
        | or (eql "TAPE" style)
        | or (eql "LINE" style)
             (eql "PAGE" style)
    | okay rexText-thisKid
| if (eql "EMBD" style)
    @ fan (rexEmbd thisKid)
    | if (not isNat-fan) unexpected
    | okay fan
| else
    | unexpected

;;; TODO test the above
;;;
;;; TODO Need much more careful tests throghout this module, complex code.

= (cenTabStub s p e a kids err ok)
| err "Import the % macro from `17_tab`, not from `16_cab`."

= ({%} s p e a r err ok)
| **mkCenMacro cenCab cenTabStub s p e a r err ok


""" %% Rune: Tall-Form Tabs and Cabs """""""""""""""""""""""""""""""""""""""""""

;
; %% 3
; %% x
; %% 'x'
; %% """y
;

= (cenCenTabStub s p e a r err ok)
| err r "Import the %% macro from `17_tab`, not from `16_cab`."

= (readCenCenCabLine rex err ok)
| rexGetNodeWithRune {%%} rex
    | err rex "Expected a %% node (in a tall-form cab literal)"
& (sons heir)
^ forRow sons _ (keys & ok keys heir)
? (step son pure)
| readKey son err pure

= (readCenCenCab rex err ok)
^ _ emptyCab rex
? (go acc rex)
| if (isZero rex) (ok acc)
| **readCenCenCabLine rex err
& (newKeys heir)
^ go _ heir
^ foldl _ acc newKeys
? (step acc key)
| if (cabHas key acc) (err rex "duplicate key")
| cabIns key acc

= (cenCenCab s p e a r err ok)
| readCenCenCab r err
& cab
| ok p a (EMBD cab)

= (mkCenCenMacro doCab doTab s p e a r err ok)
@ sons (rexSons r)
| if (null sons)
    | **err r "%% rune must be given sons"
| if (rexIsNode (idx 0 sons))
    | **doTab s p e a r err ok
| else
    | **doCab s p e a r err ok

= ({%%} s p e a r err ok)
| (**mkCenCenMacro cenCenCab cenCenTabStub s p e a r err ok)


""" Tests """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

!!= %[a] (cabFromRow [%a %a])
!!= %[a b] (cabFromRow [%a %b])
!!= %[a b] (cabFromRow [%b %a])
!!= %[a b] (cabFromRow [%b %a %b])

!!= 1 | isCab %[]
!!= 1 | isCab %[1]
!!= 1 | isCab %[1 a]
!!= 1 | isCab %[a 9 1]
!!= 1 | isCab (0 0 1 (0 0 1 0))
!!= 0 | isCab (0 1 1 (0 0 1 0))
!!= 0 | isCab (0 0 1 (0 0 1 1))
!!= 0 | isCab (0 0 2 (0 0 1 0))
!!= 1 | isCab (0 0 2 (0 0 2 0 9))
!!= 0 | isCab (0 0 1 (0 0 2 0 9))

!!= %a   | "a"
!!= %3   | "3"
!!= %x_x | "x_x"

!!= %[]    | %[]
!!= %[a]   | %[97]
!!= %[a]   | %['a']
!!= %[a b] | %[98 97]
!!= %[a b] | %["b" 'a']

!!= %[]        | emptyCab
!!= %['x']     | cabIns 'x' emptyCab
!!= %[x]       | cabIns 'x' emptyCab
!!= %[3]       | cabIns 3   emptyCab
!!= %[3]       | cabSing 3
!!= %[3]       | cabIns 3  %[]
!!= %[0 1 2 3] | cabIns 3  %[0 1 2]
!!= %[a b c]   | cabIns %c %[a b]
!!= %[0 1 2 3] | cabIns 3  %[0 1 2 3]
!!= %[a b c]   | cabIns %c %[a b c]
!!= %[0 1 2]   | cabDel 3 %[0 1 2 3]
!!= %[0 1 3]   | cabDel 2 %[0 1 2 3]
!!= %[0 2 3]   | cabDel 1 %[0 1 2 3]
!!= %[1 2 3]   | cabDel 0 %[0 1 2 3]
!!= %[0 1 2]   | cabDel 3 %[0 1 2]
!!= %[0 1 2 3] | cabUnion %[0 2]   %[1 3]
!!= %[a b c]   | cabUnion %[a c]   %[b]
!!= %[a b c]   | cabUnion %[a c]   %[b c]
!!= %[a b c]   | cabUnion %[a c]   %[a b c]
!!= %[a b c]   | cabUnion %[a b c] %[a b c]

!!= %[0 2 4]   | cabFilter even %[0 1 2 3 4 5]
!!= %[1 3 5]   | cabFilter odd  %[0 1 2 3 4 5]
!!= %[a]       | cabIntersect %[a b c] %[a d]
!!= %[a b]     | cabIntersect %[a b c] %[a b d]
!!= %[]        | cabIntersect %[a b c] %[d e f]

!!= %[]        | cabAscUnions []
!!= %[a]       | cabAscUnions [%[a]]
!!= %[a b c]   | cabAscUnions [%[a] %[b] %[c]]
!!= %[a b]     | cabAscUnions [%[a] %[] %[b]]

!!= %[3]       | cabDiff %[3 5] %[5 7]

; cabAscUnions deopt behaviour
!!= (a b c d & [7 9 8])
  | cabAscUnions [%[7 9] %[8]]

!!= %[3]       | %% 3
!!= %[3 4 'a'] | (%%3)(%%4)(%% 'a')
!!= %[3 4 'a'] | (%%3)(%%4)(%% 'a')

!!= %[3 4 'a']
 %% 3
 %% 4
 %% a

!!= %[3 4 'a']
 %% 3
 %% 4
 %% """a

!!= %[3 4 'a']
 %% 3 4 """a

!!= %[3 4 'a']
 %% 3
 %% 4 """a

!!= %[a b c] | cabCatRow [%[a] %[b] %[c]]
!!= %[a b c] | cabCatList [%[a] [%[b] [%[c] 0]]]

!!= (%[0 1], %[2 3]) | cabSplitLT 2 %[0 1 2 3]


""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^ isCab
^-^ emptyCab cabIsEmpty
^-^ cabLen cabPop cabToRow cabToList cabIns cabDel cabUnion cabAscUnions
^-^ cabCatRow cabCatList
^-^ cabHas cabMin cabSing cabDrop cabTake cabSplitAt cabSplitLT
^-^ cabIntersect cabDiff cabElem
^-^ cabFromRow
^-^
^-^ {%} {%%}
^-^
^-^ readKey
^-^ mkCenMacro cenCab
^-^ mkCenCenMacro cenCenCab
