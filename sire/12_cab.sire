;;; Copyright 2023 The Plunder Authors
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.

### 12_cab <- 11_str

"""
""" Cabs
""" ====
"""
""" A cab is a data-jetted set of nouns.
"""
""" Cabs are represented as a law of the form:
"""
"""     (0 0 n row)
"""
""" Where n is the length of the row+1, and the row is in ascending order
""" (according to `cmp`) and unique.
"""


""" Imports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

/+  01_fan
/+  02_bit  [if else ifNot and or not]
/+  03_nat  [add sub mul dec]
/+  03_nat  [even odd]
/+  06_row  [idx get len]
/+  04_cmp  [eql neq lte lth gth gte isZero]
/+  06_row  [null weld v2 isRow map foldl foldr fst snd]
/+  07_rex
/+  08_dat
/+  09_sci  []
/+  10_chr  [isDigit ord chr]
/+  11_str  [strToList strWeld loadKeyWord loadDecimal]


""" Cabs """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

; {_MkCab} is an internal routine that expects to be given a
; "row set" a sorted row with no duplicates.

= (_MkCab x)       | 0 1 2 x
= (_CabToRow cab)  | lawBody cab
= cabFromRowAsc    | _MkCab
= emptyCab         | _MkCab []
= (cabSing x)      | _MkCab [x]
= (cabIsEmpty cab) | null (_CabToRow cab)

!!= 1 | cabIsEmpty emptyCab
!!= 1 | not (cabIsEmpty | cabSing "a")

= (cabLen cab)    | len (_CabToRow cab)
= (cabToList cab) | listFromRow (_CabToRow cab)
= (cabHas k cab)  | has k (_CabToRow cab)
= (cabMin cab)    | idx 0 (_CabToRow cab)

; {cabPort} ports a row operation to a cab.  For this to work, the row
; operation must always return a result that is in ascending order and
; contains no duplicates.

= (cabPort op cab) | _MkCab | op | _CabToRow cab

; {cabPortSplit} ports a row splitting function (Row a > (Row a, Row a))
; to cabs.  Like {cabPort}, {cabPortSplit} expects both of the rows
; returned by the splitting function to be in ascending order and contain
; no duplicates.

= (cabPortSplit op cab)
@ xy | op (_CabToRow cab)
| (_MkCab (fst xy), _MkCab (snd xy))

= (cabFromRow row)  | _MkCab (sortUniq row)
= (cabIns itm c)    | cabFromRow (rowCons itm | _CabToRow c)
= (cabDel itm c)    | _MkCab (delete itm | _CabToRow c)
= (cabWeld a b)     | cabFromRow (weld (_CabToRow a) (_CabToRow b))
= (cabCatList l)    | listFoldl cabWeld emptyCab l
= (cabCatRow r)     | foldl cabWeld emptyCab r
= (cabCatRowAsc cs) | _MkCab (catMap _CabToRow cs)

; {cabCatRowAsc} expects a row of cabs, each strictly ascending (the
; greatest element of each cab is smaller than all elements of the next
; cab in the sequence).  If this invariant is violated, the result will
; not be a cab.

= (isOrderedWith chk row)
@ wid (len row)
^ _ (idx 0 row) 1
? (go las i)
| or (gte i wid)
@ cur (idx i row)
| and (chk las cur)
| go cur (inc i)

!!= 1 | isOrderedWith lth [0 1 2]
!!= 1 | isOrderedWith lte [0 0 1]
!!= 1 | isOrderedWith gth [3 2 1]
!!= 1 | isOrderedWith gte [3 3 2]
!!= 1 | isOrderedWith eql [3 3 3]
!!= 1 | isOrderedWith neq [3 4 2]

!!= 1 | isOrderedWith lth []
!!= 1 | isOrderedWith lth [0]
!!= 1 | isOrderedWith lth [0 1]
!!= 1 | isOrderedWith lth [0 1 [0]]
!!= 1 | isOrderedWith lth [0 1 2]
!!= 1 | isOrderedWith lth [1]
!!= 1 | isOrderedWith lth [1 2]
!!= 1 | isOrderedWith lth [1 2 3 4 5 999]
!!= 1 | isOrderedWith lth [1 2 const]
!!= 1 | isOrderedWith lth [1 2 const (0 0)]
!!= 1 | isOrderedWith lth [1 const]
!!= 1 | isOrderedWith lth [2]

!!= 0 | isOrderedWith lth [0 0]
!!= 0 | isOrderedWith lth [0 0 [0]]
!!= 0 | isOrderedWith lth [1 1]
!!= 0 | isOrderedWith lth [1 2 0]
!!= 0 | isOrderedWith lth [2 1]
!!= 0 | isOrderedWith lth [2 1 (die 'never evaluated')]
!!= 0 | isOrderedWith lth [1 1 (die 'never evaluated')]
!!= 1 | isOrderedWith lth []

= (isCab cab)
@ head (car cab)
@ body (cdr cab)
| and (eql (0 1 2) head)
| and (isRow body)
      (isOrderedWith lth body)

= (cabElem i c)         | idx i (_CabToRow c)
= (cabFoldl f z c)      | foldl f z (_CabToRow c)
= (cabFoldr f z c)      | foldr f z (_CabToRow c)
= (cabDrop n c)         | cabPort (drop n) c
= (cabTake n c)         | cabPort (take n) c
= (cabFilter f c)       | cabPort (filter f) c
= (cabSplitAt idx c)    | cabPortSplit (splitAt idx) c
= (cabSpan p c)         | cabPortSplit (span p) c
= (cabIntersect a b)    | cabFilter (flip cabHas a) b
= (cabSub a b)          | cabFoldl (flip cabDel) a b
= (cabSplitLT key c)    | cabSpan (gth key) c
= (cabPop c)            | (cabMin c, cabDrop 1 c)


""" % Rune: Atoms, Tabs, and Cabs """"""""""""""""""""""""""""""""""""""""""""""

= (readKey rex err ok)
| if (neq 0 | rexHeir rex)
    | err rex (strWeld "Unexpected heir on key")
@ style (rexStyle rex)
| if (eql "WORD" style)
    | ok (loadKeyWord rexText-rex)
| if    | or (eql "TAPE" style)
        | or (eql "CORD" style)
        | or (eql "LINE" style)
        | or (eql "CURL" style)
             (eql "PAGE" style)
    | ok (rexText rex)
| if (eql "EMBD" style)
    @ fan (rexEmbd rex)
    | ifNot (isNat fan)
        | err rex "Invalid Key: Embeded fan value is not a natural"
    | ok fan
| err rex "Invalid Key: Expected a word, text, or an embeded natural"

!!= 'a' (readKey `"a"     v2 x&x)
!!= 'a' (readKey `a       v2 x&x)
!!= 9   (readKey `9       v2 x&x)
!!= 9   (readKey (EMBD 9) v2 x&x)


""" %% Rune: Tall-Form Tabs and Cabs """""""""""""""""""""""""""""""""""""""""""

= (readCabLine rex err ok)
| rexGetNodeWithRune {%%} rex
    | err rex "Expected a %% node (in a tall-form cab literal)"
& (sons heir)
^ rowTraverse _ sons (keys & ok keys heir)
? (step son pure)
| readKey son err pure

= (readTallCab rex err ok)
^ _ emptyCab rex
? (go acc rex)
| if (isZero rex) (ok acc)
| **readCabLine rex err
& (newKeys heir)
^ go _ heir
^ foldl _ acc newKeys
? (step acc key)
| if (cabHas key acc) (err rex "duplicate key")
| cabIns key acc

= ({%%} s p e a r err ok)
| readTallCab r err
& cab
| ok p a (EMBD cab)

cenExpect="% expects something like %foo or %[...]"

= cabKeyExpect
  """ A cab key literal must be one of:
  """
  """ -   String ('', 'x', 'text', ...)
  """ -   Number number (0, 3, 12341234, ...)
  """ -   Identifier (x, _Y_3, ...)

= (readCabKey rex err ok)
@ style | rexStyle rex
@ text  | rexText rex
@ embed | rexEmbd rex
| if (eql "WORD" style)
    | ok (loadKeyWord text)
| if (and (eql "EMBD" style) (isNat embed))
    | ok embed
| if (rexIsLeaf rex)
    | ok text
| err rex cabKeyExpect

= (readCenBracket rex err ok)
| if (neq "," | rexRune rex)
    | err rex cenExpect
| ^ rowTraverseState emptyCab _ (rexKids rex)
  & (acc kid yield)
  | seq acc
  | readCabKey kid err
  & key
  | if (cabHas key acc) (err kid "duplicate key")
  | yield (cabIns key acc) key
& (acc keys)
| ok acc

!!= (cabFromRow ['a' 'b' 'c']) | readCenBracket `[a b c] v2 id
!!= (cabFromRow ['a' 'b' 'c']) | readCenBracket `[c b a] v2 id
!!= [`(a b c) cenExpect]       | readCenBracket `(a b c) v2 id
!!= [`c "duplicate key"]       | readCenBracket `[c b c] v2 id

= (readCenLit rex err ok)
@ kids (rexKids rex)
@ nKid (len kids)
@ kid  (idx 0 kids)
| if (neq nKid 1) (err rex cenExpect)
| ifNot (rexIsNode kid)
    | if (eql "WORD" rexStyle-kid)
        | ok (LEFT | rexText kid)
    | err rex cenExpect
| readCenBracket kid err
| cab&(ok RIGHT-cab)

!!= (LEFT "a")                   | readCenLit `(%a)     v2 id
!!= (LEFT "1")                   | readCenLit `(%1)     v2 id
!!= [`1 cenExpect]               | readCenLit `1        v2 id
!!= (RIGHT emptyCab)             | readCenLit `(%[])    v2 id
!!= (RIGHT cabSing-"a")          | readCenLit `(%[a])   v2 id
!!= (RIGHT cabFromRow-["a" "b"]) | readCenLit `(%[a b]) v2 id

= ({%} s p e a r err ok)
| readCenLit r err
& eRes
@ val (**eitherCase eRes id id)
| trk [r val]
| ok p a (EMBD val)


""" Tests """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

!!= %[a]   | cabFromRow [%a %a]
!!= %[a b] | cabFromRow [%a %b]
!!= %[a b] | cabFromRow [%b %a]
!!= %[a b] | cabFromRow [%b %a %b]

!!= 1 | isCab %[]
!!= 1 | isCab %[1]
!!= 1 | isCab %[1 a]
!!= 1 | isCab %[a 9 1]
!!= 1 | isCab (0 1 2 [])
!!= 1 | isCab (0 1 2 [1])
!!= 1 | isCab (0 1 2 [1 2])
!!= 0 | isCab (0 1 2 [2 1])
!!= 0 | isCab (0 2 2 [])
!!= 0 | isCab (0 1 1 [])

!!= %a   | "a"
!!= %3   | "3"
!!= %x_x | "x_x"

!!= %[]    | %[]
!!= %[a]   | %[97]
!!= %[a]   | %['a']
!!= %[a b] | %[98 97]
!!= %[a b] | %["b" 'a']

!!= %[]        | emptyCab
!!= %['x']     | cabIns 'x' emptyCab
!!= %[x]       | cabIns 'x' emptyCab
!!= %[3]       | cabIns 3   emptyCab
!!= %[3]       | cabSing 3
!!= %[3]       | cabIns 3  %[]
!!= %[0 1 2 3] | cabIns 3  %[0 1 2]
!!= %[a b c]   | cabIns %c %[a b]
!!= %[0 1 2 3] | cabIns 3  %[0 1 2 3]
!!= %[a b c]   | cabIns %c %[a b c]
!!= %[0 1 2]   | cabDel 3 %[0 1 2 3]
!!= %[0 1 3]   | cabDel 2 %[0 1 2 3]
!!= %[0 2 3]   | cabDel 1 %[0 1 2 3]
!!= %[1 2 3]   | cabDel 0 %[0 1 2 3]
!!= %[0 1 2]   | cabDel 3 %[0 1 2]
!!= %[0 1 2 3] | cabWeld %[0 2]   %[1 3]
!!= %[a b c]   | cabWeld %[a c]   %[b]
!!= %[a b c]   | cabWeld %[a c]   %[b c]
!!= %[a b c]   | cabWeld %[a c]   %[a b c]
!!= %[a b c]   | cabWeld %[a b c] %[a b c]

!!= %[0 2 4]   | cabFilter even %[0 1 2 3 4 5]
!!= %[1 3 5]   | cabFilter odd  %[0 1 2 3 4 5]

!!= %[a]       | cabIntersect %[a b c] %[a d]
!!= %[a b]     | cabIntersect %[a b c] %[a b d]
!!= %[]        | cabIntersect %[a b c] %[d e f]

!!= %[]        | cabCatRowAsc []
!!= %[a]       | cabCatRowAsc [%[a]]
!!= %[a b c]   | cabCatRowAsc [%[a] %[b] %[c]]
!!= %[a b]     | cabCatRowAsc [%[a] %[] %[b]]

!!= %[3]       | cabSub %[3 5] %[5 7]
!!= %[5]       | cabSub %[3 5] %[1 3]
!!= %[3 5]     | cabSub %[3 5] %[4 7]
!!= %[]        | cabSub %[3 5] %[3 5]
!!= %[]        | cabSub %[] %[3 5]

; cabCatRowAsc deopt behaviour
!!= (0 1 2 [7 9 8])
  | cabCatRowAsc [%[7 9] %[8]]

!!= %[3]       | %% 3
!!= %[3 4 'a'] | (%%3)(%%4)(%% 'a')
!!= %[3 4 'a'] | (%%3)(%%4)(%% 'a')

!!= %[3 4 'a']
 %% 3
 %% 4
 %% a

!!= %[3 4 'a']
 %% 3
 %% 4
 %% """a

!!= %[3 4 'a']
 %% 3 4 """a

!!= %[3 4 'a']
 %% 3
 %% 4 """a

!!= %[a b c] | cabCatRow [%[a] %[b] %[c]]
!!= %[a b c] | cabCatList [%[a] [%[b] [%[c] 0]]]

!!= (%[0 1], %[2 3]) | cabSplitLT 2 %[0 1 2 3]


""" Aliases """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

cabUnion=cabWeld
cabDifference=cabSub
cabSubtract=cabSub
cabInsert=cabIns
cabIntersection=cabIntersect
cabToRow=(_CabToRow)


""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^
^-^ isCab
^-^
^-^ emptyCab cabIsEmpty
^-^
^-^ cabSing cabFromRow cabFromRowAsc
^-^ cabToRow cabLen cabToList
^-^ cabFoldl cabFoldr
^-^
^-^ cabIns cabDel cabHas
^-^ cabUnion cabWeld cabCatRow cabCatList cabCatRowAsc
^-^ cabMin cabPop cabDrop cabTake cabSplitAt cabSplitLT
^-^ cabIntersect cabSub cabElem
^-^
^-^ cabUnion cabDifference cabInsert cabSubtract cabIntersection
^-^
^-^ readKey
^-^ readTallCab
^-^ readCabKey readCenBracket readCenLit
^-^
^-^ {%} {%%}
^-^
