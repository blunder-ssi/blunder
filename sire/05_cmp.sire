;;; Copyright 2023 The Plunder Authors
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.

### 05_cmp <- 04_app

"""
""" Equality and Ordering
""" =====================
"""
""" This defines the equality jet (`eql`) for arbitrary Fan values
""" and it's inverse `neq`.
"""
""" And we also define `compare` and some convenience functions wrapping
""" that: (lth, lte, gte, gth, max, min)
"""

""" Imports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

/+  01_fan  [isPin pinItem]
/+  01_fan  [isLaw lawArgs lawName lawBody]
/+  01_fan  [isApp car cdr]
/+  01_fan  [isNat]
/+  01_fan  [const id]
/+  02_bit  [if ifNot else and not]
/+  03_nat  [eqlNat cmpNat LT EQ GT ordWeld]
/+  04_app  [len]


""" Ordering """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

;
; The ordering on Fan nouns is designed to find differences quickly.
;
; Laws are ordered left-to-right, so the name is compared first and the
; body last.  Law bodies are large, so we avoid entering them unless
; everything else is equal.
;
; Apps are first compared by closure-size, and then also compared
; left-to-right.  Comparing closure size is a quick short-cut, and
; comparing head-first maximizes laziness.
;
; For example, this terminates:
;
;     (cmp (v2 die-3 die-4) (v2 die-5))
;
; As does this:
;
;     (cmp const-(die 3) ignore-(die 3))
;
; This also a jetting implementation to compare data jets without
; deconstructing them.
;

= (cmpLaw cmp x y)
| ordWeld (cmpNat (lawName x) (lawName y))
| ordWeld (cmpNat (lawArgs x) (lawArgs y))
          (cmp (lawBody x) (lawBody y))

;
; (Nat < Pin < Law < App)
;
; Nats comparisons are done in the obvious ways.
;
; Pins, Laws, and Apps are compared "lexicographically" (compare the
; first thing first), except that apps are first checked length-wise.
;
; Apps with fewer application are smaller than apps with more.  Apps with
; the same length are check lexicographically.
;
; This system of comparing closure-lengths first makes it much easier
; and simpler to implement equality efficiently, especially for data-jets.
;
= (cmp x y)
| if (isNat x) | ifNot (isNat y) LT (cmpNat x y)
| if (isNat y) | GT
| if (isPin x) | ifNot (isPin y) LT (cmp (pinItem x) (pinItem y))
| if (isPin y) | GT
| if (isLaw x) | ifNot (isLaw y) LT (**cmpLaw cmp x y)
| if (isLaw y) | GT
| else
    | ordWeld (cmpNat (len x) (len y))
    | ordWeld (cmp (car x) (car y))
              (cmp (cdr x) (cdr y))

!!= LT | cmp 9     const
!!= EQ | cmp const const
!!= GT | cmp (0 0) const

!!= LT | cmp 0 1
!!= EQ | cmp 1 1
!!= GT | cmp 2 1

!!= LT | cmp (0 0) (1 1)
!!= LT | cmp (0 1) (1 1)
!!= LT | cmp (0 2) (1 1)
!!= LT | cmp (1 0) (1 1)
!!= EQ | cmp (1 1) (1 1)
!!= GT | cmp (1 2) (1 1)
!!= GT | cmp (2 0) (1 1)
!!= GT | cmp (2 1) (1 1)
!!= GT | cmp (2 2) (1 1)

!!= LT | cmp (1 1 1) | (1 1 1 1)
!!= EQ | cmp (1 1 1) | (1 1 1)
!!= GT | cmp (1 1 1) | (1 1)

!!= LT | cmp (2 2) | (1 1 1 1)
!!= LT | cmp (2 2) | (1 1 1)
!!= GT | cmp (2 2) | (1 1)
!!= GT | cmp (2 2) | 1

!!= LT | cmp (0 1 1 1) (0 2 2 2)
!!= LT | cmp (0 1 1 2) (0 2 2 2)
!!= LT | cmp (0 1 1 3) (0 2 2 2)
!!= LT | cmp (0 1 2 1) (0 2 2 2)
!!= LT | cmp (0 1 2 2) (0 2 2 2)
!!= LT | cmp (0 1 2 3) (0 2 2 2)
!!= LT | cmp (0 1 3 1) (0 2 2 2)
!!= LT | cmp (0 1 3 2) (0 2 2 2)
!!= LT | cmp (0 1 3 3) (0 2 2 2)
!!= LT | cmp (0 2 1 1) (0 2 2 2)
!!= LT | cmp (0 2 1 2) (0 2 2 2)
!!= LT | cmp (0 2 1 3) (0 2 2 2)
!!= LT | cmp (0 2 2 1) (0 2 2 2)
!!= EQ | cmp (0 2 2 2) (0 2 2 2)
!!= GT | cmp (0 2 2 3) (0 2 2 2)
!!= GT | cmp (0 2 3 1) (0 2 2 2)
!!= GT | cmp (0 2 3 2) (0 2 2 2)
!!= GT | cmp (0 2 3 3) (0 2 2 2)
!!= GT | cmp (0 3 1 1) (0 2 2 2)
!!= GT | cmp (0 3 1 2) (0 2 2 2)
!!= GT | cmp (0 3 1 3) (0 2 2 2)
!!= GT | cmp (0 3 2 1) (0 2 2 2)
!!= GT | cmp (0 3 2 2) (0 2 2 2)
!!= GT | cmp (0 3 2 3) (0 2 2 2)
!!= GT | cmp (0 3 3 1) (0 2 2 2)
!!= GT | cmp (0 3 3 2) (0 2 2 2)
!!= GT | cmp (0 3 3 3) (0 2 2 2)


""" Specific Comparisons """"""""""""""""""""""""""""""""""""""""""""""""""""""""

= (eql x y) | eqlNat EQ (cmp x y)
= (neq x y) | not (eql x y)
= (lth x y) | eql LT (cmp x y)
= (lte x y) | neq GT (cmp x y)
= (gth x y) | eql GT (cmp x y)
= (gte x y) | neq LT (cmp x y)
= (min x y) | if (lte x y) x y
= (max x y) | if (gte x y) x y

!!= 1 | eql 0              0
!!= 1 | eql 99             99
!!= 1 | eql id             id
!!= 1 | eql _&0            _&0
!!= 1 | eql (0 0)          (0 0)
!!= 1 | eql (const 0)      (const 0)
!!= 1 | eql (const const)  (const const)
!!= 1 | eql (1 0 1 2)      (1 0 1 2)


""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^
^-^ ordWeld cmp
^-^
^-^ lth lte gth gte
^-^ eql neq
^-^ min max
^-^
