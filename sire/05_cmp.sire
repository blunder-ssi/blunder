;;; Copyright 2023 The Plunder Authors
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.

### 05_cmp <- 04_app

"""
""" Equality and Ordering
""" =====================
"""
""" This defines the equality jet (`eql`) for arbitrary Fan values
""" and it's inverse `neq`.
"""
""" And we also define `compare` and some convenience functions wrapping
""" that: (lth, lte, gte, gth, max, min)
"""

""" Imports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

/+  01_fan  [isPin pinItem]
/+  01_fan  [isLaw lawArgs lawName lawBody]
/+  01_fan  [isApp car cdr]
/+  01_fan  [isNat]
/+  01_fan  [const id]
/+  02_bit  [if ifNot else and not]
/+  03_nat  [eqlNat cmpNat LT EQ GT ordWeld]
/+  04_app  [len]


""" Ordering """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

;
; The ordering on Fan nouns is designed to find differences quickly.
;
; Laws are ordered left-to-right, so the name is compared first and the
; body last.  Law bodies are large, so we avoid entering them unless
; everything else is equal.
;
; Apps are first compared by closure-size, and then also compared
; left-to-right.  Comparing closure size is a quick short-cut, and
; comparing head-first maximizes laziness.
;
; For example, this terminates:
;
;     (cmp (v2 die-3 die-4) (v2 die-5))
;
; As does this:
;
;     (cmp const-(die 3) ignore-(die 3))
;
; This also a jetting implementation to compare data jets without
; deconstructing them.
;

= (**cmpLaw cmp x y)
| ordWeld (cmpNat (lawName x) (lawName y))
| ordWeld (cmpNat (lawArgs x) (lawArgs y))
          (cmp (lawBody x) (lawBody y))

;
; (Nat < Pin < Law < App)
;
; Nats comparisons are done in the obvious ways.
;
; Pins, Laws, and Apps are compared "lexicographically" (compare the
; first thing first).
;
; Note that, (len x > len y) implies (x > y).  This is a useful property
; for efficiently comparing data-jets, for example, a shorter array is
; always smaller than a longer array.  There is no need to compare
; the values.
;
; The {cmp} function has the following lazy-evaluation behavior:
;
; -   Pins, laws, and nats are always in normal form once evaluated,
;     so these will always be fully evaluated if compared.
;
; -   The above also applies to data-jets that are built on laws:
;     Bar, Cow, Cab, and Rex.
;
; -   If a closure is compared to a non-closure, the closure will be
;     evaluated to WHNF (and no further)
;
; -   If a larger closure is compared to a smaller closure, both closures
;     will be evaluated to WHNF (and no further).
;
; -   If two closures of the same size are compared, then both closures
;     will be evaluated to WHNF, and then the items will be compared
;     one-by-one in application order.  Any remaining items will not
;     be evaluated.
;
; -   The above rules apply in the same way to data-jets that are built
;     on closures:
;
;     1)  Smaller rows and tabs are smaller (and no of the values are
;         evaluated).
;
;     2)  Rows of equal size are compared starting from the last value
;         (because row items are applied in reverse order).
;
;     3)  Tabs of equal size are compared starting from the greatest key
;         (because tab items are applied in reverse order).
;
= (cmp x y)
| if (isNat x) | ifNot (isNat y) LT (cmpNat x y)
| if (isNat y) | GT
| if (isPin x) | ifNot (isPin y) LT (cmp (pinItem x) (pinItem y))
| if (isPin y) | GT
| if (isLaw x) | ifNot (isLaw y) LT (cmpLaw cmp x y)
| if (isLaw y) | GT
| ordWeld
    (cmp (car x) (car y))
    (cmp (cdr x) (cdr y))

!!= LT | cmp 9     const
!!= EQ | cmp const const
!!= GT | cmp (0 0) const

!!= LT | cmp 0 1
!!= EQ | cmp 1 1
!!= GT | cmp 2 1

!!= LT | cmp (0 0) (1 1)
!!= LT | cmp (0 1) (1 1)
!!= LT | cmp (0 2) (1 1)
!!= LT | cmp (1 0) (1 1)
!!= EQ | cmp (1 1) (1 1)
!!= GT | cmp (1 2) (1 1)
!!= GT | cmp (2 0) (1 1)
!!= GT | cmp (2 1) (1 1)
!!= GT | cmp (2 2) (1 1)

!!= LT | cmp (1 1 1) | (1 1 1 1)
!!= EQ | cmp (1 1 1) | (1 1 1)
!!= GT | cmp (1 1 1) | (1 1)

!!= LT | cmp (2 2) | (1 1 1 1)
!!= LT | cmp (2 2) | (1 1 1)
!!= GT | cmp (2 2) | (1 1)
!!= GT | cmp (2 2) | 1

!!= LT | cmp (0 1 1 1) (0 2 2 2)
!!= LT | cmp (0 1 1 2) (0 2 2 2)
!!= LT | cmp (0 1 1 3) (0 2 2 2)
!!= LT | cmp (0 1 2 1) (0 2 2 2)
!!= LT | cmp (0 1 2 2) (0 2 2 2)
!!= LT | cmp (0 1 2 3) (0 2 2 2)
!!= LT | cmp (0 1 3 1) (0 2 2 2)
!!= LT | cmp (0 1 3 2) (0 2 2 2)
!!= LT | cmp (0 1 3 3) (0 2 2 2)
!!= LT | cmp (0 2 1 1) (0 2 2 2)
!!= LT | cmp (0 2 1 2) (0 2 2 2)
!!= LT | cmp (0 2 1 3) (0 2 2 2)
!!= LT | cmp (0 2 2 1) (0 2 2 2)
!!= EQ | cmp (0 2 2 2) (0 2 2 2)
!!= GT | cmp (0 2 2 3) (0 2 2 2)
!!= GT | cmp (0 2 3 1) (0 2 2 2)
!!= GT | cmp (0 2 3 2) (0 2 2 2)
!!= GT | cmp (0 2 3 3) (0 2 2 2)
!!= GT | cmp (0 3 1 1) (0 2 2 2)
!!= GT | cmp (0 3 1 2) (0 2 2 2)
!!= GT | cmp (0 3 1 3) (0 2 2 2)
!!= GT | cmp (0 3 2 1) (0 2 2 2)
!!= GT | cmp (0 3 2 2) (0 2 2 2)
!!= GT | cmp (0 3 2 3) (0 2 2 2)
!!= GT | cmp (0 3 3 1) (0 2 2 2)
!!= GT | cmp (0 3 3 2) (0 2 2 2)
!!= GT | cmp (0 3 3 3) (0 2 2 2)


""" Specific Comparisons """"""""""""""""""""""""""""""""""""""""""""""""""""""""

= (eql x y) | eqlNat EQ (cmp x y)
= (neq x y) | not (eql x y)
= (lth x y) | eql LT (cmp x y)
= (lte x y) | neq GT (cmp x y)
= (gth x y) | eql GT (cmp x y)
= (gte x y) | neq LT (cmp x y)
= (min x y) | if (lte x y) x y
= (max x y) | if (gte x y) x y

!!= 1 | eql 0              0
!!= 1 | eql 99             99
!!= 1 | eql id             id
!!= 1 | eql _&0            _&0
!!= 1 | eql (0 0)          (0 0)
!!= 1 | eql (const 0)      (const 0)
!!= 1 | eql (const const)  (const const)
!!= 1 | eql (1 0 1 2)      (1 0 1 2)


""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^
^-^ ordWeld cmp
^-^
^-^ lth lte gth gte
^-^ eql neq
^-^ min max
^-^
