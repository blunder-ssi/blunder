;;; Copyright 2023 The Plunder Authors
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.

### 13_tab <- 12_cab

"""
""" Tabs
""" ====
"""
""" A tab is a data-jetted map from noun to noun.
"""


""" Imports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

/+  01_fan  [lawBody trk isLaw inc seq]
/+  02_bit  [if ifNot and or not nor]
/+  03_nat  [add toNat isZero]
/+  04_app  [len idx head mut]
/+  05_cmp  [eql neq lth lte gte gth]
/+  06_row  [null map weld rowRepel rowApply rev foldl fst snd]
/+  07_rex  [rexSons rexHeir rexKids rexRune rexGetNodeWithRune]
/+  07_rex  [OPEN EMBD PREF]
/+  08_dat
/+  09_sci  [inspect fullInspection]
/+  10_chr  []
/+  11_str  [strWeld]
/+  12_cab  [isCab emptyCab cabLen cabHas cabMin cabToList]
/+  12_cab  ["%"  readKey]


""" Tabs """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

emptyTab=emptyCab

(tabSing k v)=(0 0 2 [toNat-k] v)

= (mkTab keys vals)
@ len (len keys)
| rowRepel (0 0 inc-len keys) vals

= (isTab tab)
@ cab (head tab)
| and (isCab cab)
| eql (cabLen cab) (len tab)


""" Tab Lookup """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (tabIdx key tab)
@ keys (lawBody head-tab)
| **maybeCase (elemIdx key keys) 0
(ix & idx ix tab)

(**tabGet tab key)=(tabIdx key tab)

ex=(mkTab [1 2 3] [4 5 6])

!!= 4 | tabGet ex 1
!!= 5 | tabGet ex 2
!!= 6 | tabGet ex 3


""" Basic Quations about Tabs """"""""""""""""""""""""""""""""""""""""""""""""""

= (tabLen tab)     | len tab
= (tabIsEmpty tab) | null tab
= (tabKeys tab)    | head tab
= (tabKeysRow tab) | lawBody (tabKeys tab)
= (tabVals tab)    | map (tabGet tab) (tabKeysRow tab)
= (tabHas k t)     | cabHas k (tabKeys t)
= (tabLookup k t)  | if (tabHas k t) (SOME | tabIdx k t) NONE

;; TODO: Rename tabHas to tabHas.


""" Tab Insertion """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (findInsIdx key keys)
@ midx (findIdx lte-key keys)
| **maybeCase midx (len keys) (ix & ix)

!!= 0 (findInsIdx 0 [1 2 3])
!!= 0 (findInsIdx 1 [1 2 3])
!!= 1 (findInsIdx 2 [1 2 3])
!!= 2 (findInsIdx 3 [1 2 3])
!!= 3 (findInsIdx 4 [1 2 3])

= (tabIns key val tab)
@ keys (tabKeysRow tab)
| **maybeCase (elemIdx key keys)
    @ ix (findInsIdx key keys)
    | mkTab (insert ix key keys) (insert ix val tab)
& ix
| mut ix val tab

(tabPut x k v)=(tabIns k v x)

; `tabInsWith f key newval tab` will insert the pair (key, newval)
; into `tab` if key does not exist in the tab. If the key does exist,
; the function will insert the pair `(key, f newval oldval)`.

= (tabInsWith f key newval tab)
@ m_oldval (tabLookup key tab)
^ tabIns key _ tab
| **maybeCase m_oldval newval (f newval)

= ex1 (mkTab [1 5] [5 1])

!!= ( mkTab [1 2 5] [5 6 1] ) | tabIns 2 6 | ex1
!!= ( mkTab [0 1 5] [6 5 1] ) | tabIns 0 6 | ex1
!!= ( mkTab [1 5 9] [5 1 6] ) | tabIns 9 6 | ex1
!!= ( mkTab [1 5]   [9 1]   ) | tabIns 1 9 | ex1
!!= ( mkTab [1 5]   [5 9]   ) | tabIns 5 9 | ex1
!!= ( mkTab [1 5]   [8 9]   ) | tabIns 1 8 | tabIns 5 9 | ex1
!!= ( mkTab [1 3 5] [8 7 9] ) | tabIns 3 7 | tabIns 1 8 | tabIns 5 9 | ex1
!!= ( mkTab [1 3 5] [8 7 9] ) | tabIns 1 8 | tabIns 3 7 | tabIns 5 9 | ex1
!!= ( mkTab [1 3 5] [8 7 9] ) | tabIns 5 9 | tabIns 3 7 | tabIns 1 8 | ex1
!!= ( mkTab [1 2 5] [5 6 1] ) | tabInsWith add 2 6 | ex1
!!= ( mkTab [1 5]   [11 1]  ) | tabInsWith add 1 6 | ex1
!!= ( mkTab [1 5]   [5 7]   ) | tabInsWith add 5 6 | ex1
!!= ( mkTab [1 5 9] [5 1 3] ) | tabInsWith add 9 3 | ex1

""" Switching on Tabs """"""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (tabSwitch key fal tab)
| ifNot (tabHas key tab) fal
| tabIdx key tab


""" Raw Table Construction from Ordered Pairs """"""""""""""""""""""""""""""""""

= (tabFromAscPairs pairs)
@ keys | map idx-0 pairs
@ vals | map idx-1 pairs
| mkTab keys vals

= (tabToPairs tab)
@ ks | listFromRow (tabKeysRow tab)
@ vs | listFromRow tab
| listToRow | listZip ks vs

par=[[1 4] [2 5] [3 6]]
tab=(tabFromAscPairs par)

!!= 4   | tabGet ex 1
!!= 5   | tabGet ex 2
!!= 6   | tabGet ex 3
!!= 6   | tabGet ex 3
!!= par | tabToPairs tab


""" Table Construction from unique pairs """""""""""""""""""""""""""""""""""""""

= (tabFromPairs pairs)
| foldl (t p & tabIns (fst p) (snd p) t) emptyTab pairs

= (tabToPairList tab)
| listMap i&(i, tabGet tab i)
| cabToList (tabKeys tab)

(tabToList tab)=(listFromRow tabToPairs-tab)

!!= (mkTab [3 5] [8 9]) | tabFromPairs [[3 8] [5 9]]
!!= (mkTab [3 5] [8 9]) | tabFromPairs [[5 9] [3 8]]
!!= (mkTab [3 5] [8 9]) | tabFromPairs [[3 7] [3 8] [5 9]]
!!= (mkTab [3 5] [8 9]) | tabFromPairs [[5 9] [3 7] [3 8]]

!!= 0             | tabToPairList | tabFromPairs []
!!= [3,8 0]       | tabToPairList | tabFromPairs [[3 8]]
!!= [3,8 [5,9 0]] | tabToPairList | tabFromPairs [[3 8] [5 9]]
!!= [3,8 [5,9 0]] | tabToPairList | tabFromPairs [[5 9] [3 8]]
!!= [3,8 [5,9 0]] | tabToPairList | tabFromPairs [[3 7] [3 8] [5 9]]
!!= [3,8 [5,9 0]] | tabToPairList | tabFromPairs [[5 9] [3 7] [3 8]]


""" Treating a Tab like an Array """""""""""""""""""""""""""""""""""""""""""""""

= (tabElemIdx i tab)
@ pairs (tabToPairs tab)
| if (gte i len-pairs) 0
| idx i pairs


""" Deletion """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

; TODO: Avoid using tabFromPairs for everything

= (tabDel key tab)
| tabFromPairs
| filter kv&(neq (idx 0 kv) key)
| tabToPairs
| tab

= (tabPop tab)
@ key (cabMin (head tab))
@ val (tabGet tab key)
@ rem (tabDel key tab)
| [key val rem]

= (tabSplitAt idx a)
@ pairs | tabToPairs a
@ head  | take idx pairs
@ tails | drop idx pairs
[(tabFromPairs head) (tabFromPairs tails)]

> Nat > Tab v > (Tab v, Tab v)
= (tabSplitLT key t)
@ pairs | tabToPairs t
@ s | span p&(lth (idx 0 p) key) pairs
@ head | fst s
@ tail | snd s
[(tabFromPairs head) (tabFromPairs tail)]

= (tabAlter fun key tab)
@ keys (lawBody head-tab)
| **maybeCase (elemIdx key keys)
    | **maybeCase (fun NONE)
      tab
    & val
    | tabFromPairs
    | weld [[key val]]
    | tabToPairs tab
& ix
@ prev | idx ix tab
| **maybeCase (fun (SOME prev))
    | tabDel key tab
& new
| mut ix new tab

> (Nat > v > v) > Tab v > Tab v
= (tabMap fun tab)
@ pairs | tabToPairs tab
@ do
  ? (do p)
  @ k | fst p
  @ v | snd p
  @ nv | fun k v
  [k nv]
| tabFromPairs | map do pairs

> (a > a > a) > Tab a > Tab a > Tab a
= (tabUnionWith fun ar br)
@ a | tabToList ar
@ b | tabToList br
| tabFromPairs
| listToRow
^ _ a b NIL
? (loop a b xs)
| if (listIsEmpty a) (listWeld (listRev xs) b)
| if (listIsEmpty b) (listWeld (listRev xs) a)
@ ap  (fst a)
@ ak  (fst ap)
@ av  (snd ap)
@ axs (snd a)
@ bp  (fst b)
@ bk  (fst bp)
@ bv  (snd bp)
@ bxs (snd b)
| if | eql ak bk
    | loop axs bxs (CONS [ak (fun av bv)] xs)
| if | lth ak bk
    | loop axs b (CONS ap xs)
| loop a bxs (CONS bp xs)

= (tabMinKey t)
@ pairs | tabToPairs t
| idx 0 | idx 0 pairs

> (a > Nat > b > a) > a > Tab b > a
= (tabFoldlWithKey fun start tab)
@ do
  ? (do i pair)
  | fun i (fst pair) (snd pair)
| foldl do start | tabToPairs tab


""" Parsing """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

pairExpect={Expected something like =x or x=3}

; TODO Parse decimal
; TODO Should we support 0xHEX?
; TODO Validate identifiers
= (readTabPair readVal rex err ok)
@ rune   | rexRune rex
@ kids   | rexKids rex
@ nKid   | len kids
@ keyRex | idx 0 kids
@ valRex | idx 1 kids
@ valRex | if (eql 2 nKid) valRex keyRex
| if (neq "=" rune)
    | err rex pairExpect
| if (nor (eql 1 nKid) (eql 2 nKid))
    | err rex pairExpect
| readKey keyRex err
& key
| readVal valRex err
& val
| ok key val

tabExpect={Expected something like [], [x=1 ...], [=x ...]}

= (readTabBracket readVal rex err ok)
| if (neq "," | rexRune rex)
    | err rex tabExpect
| forRowWithState emptyTab (rexKids rex)
    & (acc kid yield)
    | seq acc
    | readTabPair readVal kid err
    & (key val)
    | if (cabHas key acc)
        | err kid "duplicate key"
    | yield (tabIns key val acc) 0
& (acc _)
| ok acc

outerExpect={Expected something like #[x=1], [x=1], etc}

= (readWideTabLit readVal rex err ok)
@ rune | rexRune rex
@ kids | rexKids rex
@ nKid | len kids
| if (eql "#" rune)
    | if (neq 1 nKid)
        | err rex outerExpect
    @ kid (idx 0 kids)
    | readTabBracket readVal kid err ok
| if (null kids)
    | err rex outerExpect
| readTabBracket readVal rex err ok

= (parseTallKey rex err ok)
@ rune   (rexRune rex)
@ kids   (rexKids rex)
@ keyRex (idx 0 kids)
| if (or (neq "=" rexRune-rex) (neq 1 len-kids))
    | err rex "Expected something like: =key"
| readKey keyRex rex
& key
| ok keyRex key

tallExpect={Expected something like (## =key val ...)(...)}

= (readTallTabLit readVal rex err ok)
^ _ emptyTab rex
? (go acc rex)
| if (isZero rex) (ok acc)
@ rune     | rexRune rex
@ sons     | rexSons rex
@ nSons    | len sons
@ firstSon | idx 0 sons
@ moreSons | drop 1 sons
@ heir     | rexHeir rex
| if (or (neq "##" rune) (isZero nSons))
    | err rex tallExpect
| parseTallKey firstSon err
& (keyRex newKey)
@ valRex
    | if (eql 1 nSons) keyRex
    | OPEN 0 "|" moreSons 0
| readVal valRex err
& newVal
| if (tabHas newKey acc)
    | err firstSon "duplicate key"
@ acc (tabIns newKey newVal acc)
| seq acc
| go acc heir


""" Expansion """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

> Tab Exp > Exp
= (tabE tab)
| appE
| rowCons (EMBD | tabKeys tab)
| rev (tabVals tab)


""" Rune Macros """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= ({#} s p e a r err ok)
| readWideTabLit readRex r err
& res
| ok p a (tabE res)

= ({##} s p e a r err ok)
| readTallTabLit readRex r err
& res
| ok p a (tabE res)

= (isTabSugar rex)
@ kids (rexKids rex)
| and (not null-kids)
      (| eql "=" | rexRune | idx 0 kids)

; This extends the basic row syntax to support tab literals (if theh
; elements are = nodes).
= ({,} s p e a r err ok)
| if (isTabSugar r)
   | readWideTabLit readRex r err
   & res
   | ok p a (tabE res)
| ok p a (rowE | rexKids r)


""" Tests """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

!!= 1 | isTab #[]
!!= 1 | isTab #[0=0]
!!= 1 | isTab #[x=3]
!!= 1 | isTab #[x=3 y=4]
!!= 1 | isTab [x=3 y=4]
!!= 1 | isTab [=isTab]

!!= 0 | isTab []
!!= 0 | isTab %[x y]
!!= 0 | isTab (%[x y] 3)
!!= 1 | isTab (%[x y] 3 4)

!!= [a=0]     | #[97=0]
!!= [a=0]     | #['a'=0]
!!= [a=0 b=1] | #[98=1 97=0]
!!= [a=0 b=1] | #["b"=1 'a'=0]

!!= 0 | tabLen #[]
!!= 1 | tabLen #[x=0]
!!= 2 | tabLen #[x=0 y=1]

!!= (inspect #[x=0 y=1])        | [%[x y] 1 0]
!!= (inspect %[x y])            | [0 0 3 [%x %y]]
!!= (inspect [%x %y])           | [(0 0 3 0) %y %x]
!!= (fullInspection #[x=0 y=1]) | [[0 0 3 [[0 0 3 0] %y %x]] 1 0]

!!= 8 | tabIdx 0 #[0=8]
!!= 9 | tabIdx %aa #(bb=8, aa=9)

!!= 1 | tabHas %aa #(bb=8, aa=9)
!!= 1 | not | tabHas %cc #(bb=8, aa=9)

!!= %[3 4] | tabKeys #[3=3 4=4]
!!= %[]    | tabKeys #[]
!!= [3 4]  | tabKeysRow #[3=3 4=4]
!!= []     | tabKeysRow #[]

!!= #[3=3]     | tabIns 3 3 #[3=4]
!!= #[3=4 4=4] | tabIns 4 4 #[3=4]
!!= #[0=0]     | tabIns 0 0 #[]
!!= #[0=0]     | tabIns 0 0 #[]

!!= #[a=(0 1)] | (## =a 0 1)

;
; TODO Support things like:
;
; ## x=3 y=4
; ## p=0 q=1 r=2
; ## =s
;    | strToBar
;    | renderNat
;    | bex
;    | add 3 4
;

!!= ["a"=1 b=2 {c}=3] | (## =b 2)(## ="a" 1)(## ={c} 3)


""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^
^-^ tabSing mkTab isTab
^-^
^-^ tabLen tabIdx tabKeys tabKeysRow tabHas tabGet tabVals tabSwitch
^-^ tabFromPairs tabToPairs tabToPairList tabToList tabPut tabIns
^-^ tabIsEmpty tabDel tabPop tabSplitAt tabSplitLT tabAlter tabMap tabUnionWith
^-^ tabLookup tabMinKey tabFoldlWithKey tabElemIdx emptyTab tabInsWith
^-^
^-^ readRex
^-^
^-^ readTabPair readTabBracket readWideTabLit readTallTabLit
^-^ isTabSugar
^-^
^-^ tabE
^-^
^-^ {,} {#} {##}
^-^
