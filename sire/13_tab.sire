;;; Copyright 2023 The Plunder Authors
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.

### 13_tab <- 12_cab

"""
""" Tabs
""" ====
"""
""" A tab is a data-jetted map from noun to noun.
"""


""" Imports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

/+  01_fan  [lawBody trk isLaw inc]
/+  02_bit  [if ifNot and or not]
/+  03_nat  [add toNat isZero]
/+  04_app  [len idx head mut]
/+  05_cmp  [eql neq lth lte gte gth]
/+  06_row  [null map weld rowRepel rowApply rev foldl fst snd]
/+  07_rex  [rexKids rexRune rexGetNodeWithRune EMBD PREF]
/+  08_dat
/+  09_sci  [inspect fullInspection]
/+  10_chr  []
/+  11_str  [strWeld]
/+  12_cab  [isCab emptyCab cabLen cabHas cabMin cabToList]
/+  12_cab  ["%"  readKey]


""" Tabs """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

emptyTab=emptyCab

(tabSing k v)=(0 0 2 [toNat-k] v)

= (mkTab keys vals)
@ len (len keys)
| rowRepel (0 0 inc-len keys) vals

= (isTab tab)
@ cab (head tab)
| and (isCab cab)
| eql (cabLen cab) (len tab)


""" Tab Lookup """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (tabIdx key tab)
@ keys (lawBody head-tab)
| **maybeCase (elemIdx key keys) 0
(ix & idx ix tab)

(**tabGet tab key)=(tabIdx key tab)

ex=(mkTab [1 2 3] [4 5 6])

!!= 4 | tabGet ex 1
!!= 5 | tabGet ex 2
!!= 6 | tabGet ex 3


""" Basic Quations about Tabs """"""""""""""""""""""""""""""""""""""""""""""""""

= (tabLen tab)     | len tab
= (tabIsEmpty tab) | isLaw tab
= (tabKeys tab)    | head tab
= (tabKeysRow tab) | lawBody (tabKeys tab)
= (tabVals tab)    | map (tabGet tab) (tabKeysRow tab)
= (tabHas k t)     | cabHas k (tabKeys t)
= (tabLookup k t)  | if (tabHas k t) (SOME | tabIdx k t) NONE

;; TODO: Rename tabHas to tabHas.


""" Tab Insertion """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (findInsIdx key keys)
@ midx (findIdx lte-key keys)
| **maybeCase midx (len keys) (ix & ix)

!!= 0 (findInsIdx 0 [1 2 3])
!!= 0 (findInsIdx 1 [1 2 3])
!!= 1 (findInsIdx 2 [1 2 3])
!!= 2 (findInsIdx 3 [1 2 3])
!!= 3 (findInsIdx 4 [1 2 3])

= (tabMut key val tab)
@ keys (tabKeysRow tab)
| **maybeCase (elemIdx key keys)
    @ ix (findInsIdx key keys)
    | mkTab (insert ix key keys) (insert ix val tab)
& ix
| mut ix val tab

(tabPut x k v)=(tabMut k v x)

; `tabInsWith f key newval tab` will insert the pair (key, newval)
; into `tab` if key does not exist in the tab. If the key does exist,
; the function will insert the pair `(key, f newval oldval)`.

= (tabInsWith f key newval tab)
@ m_oldval (tabLookup key tab)
^ tabMut key _ tab
| **maybeCase m_oldval newval (f newval)

= ex1 (mkTab [1 5] [5 1])

!!= ( mkTab [1 2 5] [5 6 1] ) | tabMut 2 6 | ex1
!!= ( mkTab [0 1 5] [6 5 1] ) | tabMut 0 6 | ex1
!!= ( mkTab [1 5 9] [5 1 6] ) | tabMut 9 6 | ex1
!!= ( mkTab [1 5]   [9 1]   ) | tabMut 1 9 | ex1
!!= ( mkTab [1 5]   [5 9]   ) | tabMut 5 9 | ex1
!!= ( mkTab [1 5]   [8 9]   ) | tabMut 1 8 | tabMut 5 9 | ex1
!!= ( mkTab [1 3 5] [8 7 9] ) | tabMut 3 7 | tabMut 1 8 | tabMut 5 9 | ex1
!!= ( mkTab [1 3 5] [8 7 9] ) | tabMut 1 8 | tabMut 3 7 | tabMut 5 9 | ex1
!!= ( mkTab [1 3 5] [8 7 9] ) | tabMut 5 9 | tabMut 3 7 | tabMut 1 8 | ex1
!!= ( mkTab [1 2 5] [5 6 1] ) | tabInsWith add 2 6 | ex1
!!= ( mkTab [1 5]   [11 1]  ) | tabInsWith add 1 6 | ex1
!!= ( mkTab [1 5]   [5 7]   ) | tabInsWith add 5 6 | ex1
!!= ( mkTab [1 5 9] [5 1 3] ) | tabInsWith add 9 3 | ex1

""" Switching on Tabs """"""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (tabSwitch key fal tab)
| ifNot (tabHas key tab) fal
| tabIdx key tab


""" Raw Table Construction from Ordered Pairs """"""""""""""""""""""""""""""""""

= (tabFromAscPairs pairs)
@ keys | map idx-0 pairs
@ vals | map idx-1 pairs
| mkTab keys vals

= (tabToPairs tab)
@ ks | listFromRow (tabKeysRow tab)
@ vs | listFromRow tab
| listToRow | listZip ks vs

par=[[1 4] [2 5] [3 6]]
tab=(tabFromAscPairs par)

!!= 4   | tabGet ex 1
!!= 5   | tabGet ex 2
!!= 6   | tabGet ex 3
!!= 6   | tabGet ex 3
!!= par | tabToPairs tab


""" Table Construction from unique pairs """""""""""""""""""""""""""""""""""""""

= (tabFromPairs pairs)
| foldl (t p & tabMut (fst p) (snd p) t) emptyTab pairs

= (tabToPairList tab)
| listMap i&(i, tabGet tab i)
| cabToList (tabKeys tab)

(tabToList tab)=(listFromRow tabToPairs-tab)

!!= (mkTab [3 5] [8 9]) | tabFromPairs [[3 8] [5 9]]
!!= (mkTab [3 5] [8 9]) | tabFromPairs [[5 9] [3 8]]
!!= (mkTab [3 5] [8 9]) | tabFromPairs [[3 7] [3 8] [5 9]]
!!= (mkTab [3 5] [8 9]) | tabFromPairs [[5 9] [3 7] [3 8]]

!!= 0             | tabToPairList | tabFromPairs []
!!= [3,8 0]       | tabToPairList | tabFromPairs [[3 8]]
!!= [3,8 [5,9 0]] | tabToPairList | tabFromPairs [[3 8] [5 9]]
!!= [3,8 [5,9 0]] | tabToPairList | tabFromPairs [[5 9] [3 8]]
!!= [3,8 [5,9 0]] | tabToPairList | tabFromPairs [[3 7] [3 8] [5 9]]
!!= [3,8 [5,9 0]] | tabToPairList | tabFromPairs [[5 9] [3 7] [3 8]]


""" Treating a Tab like an Array """""""""""""""""""""""""""""""""""""""""""""""

= (tabElemIdx i tab)
@ pairs (tabToPairs tab)
| if (gte i len-pairs) 0
| idx i pairs


""" Deletion """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

; TODO: Avoid using tabFromPairs for everything

= (tabDel key tab)
| tabFromPairs
| filter kv&(neq (idx 0 kv) key)
| tabToPairs
| tab

= (tabPop tab)
@ key (cabMin (head tab))
@ val (tabGet tab key)
@ rem (tabDel key tab)
| [key val rem]

= (tabSplitAt idx a)
@ pairs | tabToPairs a
@ head  | take idx pairs
@ tails | drop idx pairs
[(tabFromPairs head) (tabFromPairs tails)]

> Nat > Tab v > (Tab v, Tab v)
= (tabSplitLT key t)
@ pairs | tabToPairs t
@ s | span p&(lth (idx 0 p) key) pairs
@ head | fst s
@ tail | snd s
[(tabFromPairs head) (tabFromPairs tail)]

= (tabAlter fun key tab)
@ keys (lawBody head-tab)
| **maybeCase (elemIdx key keys)
    | **maybeCase (fun NONE)
      tab
    & val
    | tabFromPairs
    | weld [[key val]]
    | tabToPairs tab
& ix
@ prev | idx ix tab
| **maybeCase (fun (SOME prev))
    | tabDel key tab
& new
| mut ix new tab

> (Nat > v > v) > Tab v > Tab v
= (tabMap fun tab)
@ pairs | tabToPairs tab
@ do
  ? (do p)
  @ k | fst p
  @ v | snd p
  @ nv | fun k v
  [k nv]
| tabFromPairs | map do pairs

> (a > a > a) > Tab a > Tab a > Tab a
= (tabUnionWith fun ar br)
@ a | tabToList ar
@ b | tabToList br
| tabFromPairs
| listToRow
^ _ a b NIL
? (loop a b xs)
| if (listIsEmpty a) (listWeld (listRev xs) b)
| if (listIsEmpty b) (listWeld (listRev xs) a)
@ ap  (fst a)
@ ak  (fst ap)
@ av  (snd ap)
@ axs (snd a)
@ bp  (fst b)
@ bk  (fst bp)
@ bv  (snd bp)
@ bxs (snd b)
| if | eql ak bk
    | loop axs bxs (CONS [ak (fun av bv)] xs)
| if | lth ak bk
    | loop axs b (CONS ap xs)
| loop a bxs (CONS bp xs)

= (tabMinKey t)
@ pairs | tabToPairs t
| idx 0 | idx 0 pairs

> (a > Nat > b > a) > a > Tab b > a
= (tabFoldlWithKey fun start tab)
@ do
  ? (do i pair)
  | fun i (fst pair) (snd pair)
| foldl do start | tabToPairs tab

""" Syntax """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

> Tab Exp > Exp
= (tabE tab)
| appE
| rowCons (EMBD | tabKeys tab)
| rev (tabVals tab)

; TODO Break out `readTabPair`
; TODO Parse decimal
; TODO Should we support 0xHEX?
; TODO Validate identifiers
= ({#} s p e a r err ok)
@ kids (rexKids r)
@ kid  (idx 0 kids)
| if (neq 1 | len kids)      | err r   "What is this?"
| if (neq "," | rexRune kid) | err kid "What is this?"
| trk ['kid',kid 'kids',(rexKids kid)]
^ _ emptyTab (listFromRow (rexKids kid))
? (go acc pairs)
; trk [%go acc pairs]
| **listCase pairs (ok p a tabE-acc)
& (thisPair morePairs)
;
@ unexpect
    | err thisPair "Every element of a tab literal must be an `=` node."
;
@ okay
    ? (okay newKey newValue)
    | if (tabHas newKey acc)
        | err thisPair "duplicate key"
    @ acc (tabMut newKey newValue acc)
    | go acc morePairs
;
| rexGetNodeWithRune "=" thisPair unexpect
& (sons heir)
;
@ kids   | rexKids thisPair
@ nKid   | len kids
@ keyRex | idx 0 kids
;
| if (or (isZero nKid) (gth nKid 2))
    | err thisPair "Tab key-value pairs must be = nodes with one-or-two sons"
;
| readKey keyRex err
& key
; trk [%key key]
| if (eql 1 nKid)
    | okay key keyRex
| okay key (idx 1 kids)

= ({##} s p e a r err ok)
^ _ emptyTab r
? (go acc rex)
; trk 'go',acc,rex
| if (isZero rex)
    | ok p a (tabE acc)
| rexGetNodeWithRune "##" rex
    | err rex "Expected a ## node (in a tall-form tab literal)"
& (sons heir)
@ okay
    ? (okay newKey newValue)
    ; trk 'okay',newKey,newValue
    | if (tabHas newKey acc)
        | err rex "duplicate key"
    @ acc (tabMut newKey newValue acc)
    | go acc heir
| if (isZero len-sons)
    ; trk 'zeroSons'
    | err rex "## requires at least 1 son (in a tall-form tab literal)"
;;;;
; trk %sons,sons
@ keyTisRex (idx 0 sons)
| rexGetNodeWithRune "=" keyTisRex
    | err keyTisRex
    | strWeld "First son of every ## node must be a = node "
              "(in a tall-form tab literal)"
& (tisSons tisHeir)
| if    | or (neq 1 len-tisSons)
             (neq 0 tisHeir)
    | err keyTisRex
    | "=key form for tall-form tab literal must have exactly one son"
@ keyRex (idx 0 tisSons)
@ valExp
    | if (eql 1 len-sons) keyRex
    | if (eql 2 len-sons) (idx 1 sons)
    | appE (drop 1 sons)
; trk [%keyRex,keyRex %valExp,valExp]
| **readKey keyRex err
& k
| okay k valExp

= (isTabSugar rex)
@ kids (rexKids rex)
| and (not null-kids)
      (| eql "=" | rexRune | idx 0 kids)

= (desugarTab rex)
| PREF 0 "#" [rex] 0

; Same as the previous version except that things like [x=3] get rewritten
; as #[x=3] (and therefore treated as tabs).
= ("," s p e a rex err ok)
| if (isTabSugar rex)
    | ok p a (desugarTab rex)
| ok p a (rowE | rexKids rex)


""" Tests """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

!!= 1 | isTab #[]
!!= 1 | isTab #[0=0]
!!= 1 | isTab #[x=3]
!!= 1 | isTab #[x=3 y=4]
!!= 1 | isTab [x=3 y=4]
!!= 1 | isTab [=isTab]

!!= 0 | isTab []
!!= 0 | isTab %[x y]
!!= 0 | isTab (%[x y] 3)
!!= 1 | isTab (%[x y] 3 4)

!!= [a=0]     | #[97=0]
!!= [a=0]     | #['a'=0]
!!= [a=0 b=1] | #[98=1 97=0]
!!= [a=0 b=1] | #["b"=1 'a'=0]

!!= 0 | tabLen #[]
!!= 1 | tabLen #[x=0]
!!= 2 | tabLen #[x=0 y=1]

!!= (inspect #[x=0 y=1])        | [%[x y] 1 0]
!!= (inspect %[x y])            | [0 0 3 [%x %y]]
!!= (inspect [%x %y])           | [(0 0 3 0) %y %x]
!!= (fullInspection #[x=0 y=1]) | [[0 0 3 [[0 0 3 0] %y %x]] 1 0]

!!= 8 | tabIdx 0 #[0=8]
!!= 9 | tabIdx %aa #(bb=8, aa=9)

!!= 1 | tabHas %aa #(bb=8, aa=9)
!!= 1 | not | tabHas %cc #(bb=8, aa=9)

!!= %[3 4] | tabKeys #[3=3 4=4]
!!= %[]    | tabKeys #[]
!!= [3 4]  | tabKeysRow #[3=3 4=4]
!!= []     | tabKeysRow #[]

!!= #[3=3]     | tabMut 3 3 #[3=4]
!!= #[3=4 4=4] | tabMut 4 4 #[3=4]
!!= #[0=0]     | tabMut 0 0 #[]
!!= #[0=0]     | tabMut 0 0 #[]

!!= #[a=(0 1)] | (## =a 0 1)

;
; TODO Support things like:
;
; ## x=3 y=4
; ## p=0 q=1 r=2
; ## =s
;    | strToBar
;    | renderNat
;    | bex
;    | add 3 4
;

!!= ["a"=1 b=2 {c}=3] | (## =b 2)(## ="a" 1)(## ={c} 3)


""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^
^-^ tabSing mkTab isTab
^-^
^-^ tabLen tabIdx tabKeys tabKeysRow tabHas tabGet tabVals tabSwitch
^-^ tabFromPairs tabToPairs tabToPairList tabToList tabPut tabMut
^-^ tabIsEmpty tabDel tabPop tabSplitAt tabSplitLT tabAlter tabMap tabUnionWith
^-^ tabLookup tabMinKey tabFoldlWithKey tabElemIdx emptyTab tabInsWith
^-^
^-^ isTabSugar desugarTab
^-^
^-^ tabE
^-^
^-^ "," "#" "##"
^-^
