; Copyright 2023 The Plunder Authors
; Use of this source code is governed by a BSD-style license that can be
; found in the LICENSE file.

### 15_pad <- 14_hax

;;;; Pads
;;;; ====
;;;;
;;;; A pad is a bit-string encoded as a non-zero nat.
;;;;
;;;; Pads are not data-jetted, since the direct nat works perfectly.
;;;;
;;;; Pads are encoded least-significant-bit-first, with the high bit used
;;;; to indicate the end of the bit-array.
;;;;
;;;;     p#""       = 0b1
;;;;     p#"00"     = 0b100
;;;;     p#"01"     = 0b110
;;;;     p#"111000" = 0b1000111
;;;;
;;;; All of the pad operations coerce their inputs into pads, and always
;;;; return pads.
;;;;
;;;; toPad: Coerces a value into a non-zero natural number.
;;;;
;;;; padNat: Convert a pad to a nat (dropping all trailining zeros).
;;;;
;;;; natPad: Convert a nat into a pad with a specific minimum bit-width.
;;;;
;;;; padWeld: Concatenate two pads
;;;;
;;;; padCat: Concatenate a row of pads (TODO)
;;;;
;;;; padCatTree: Concatenate a rose-tree of pads (TODO)
;;;;
;;;; padIdx: TODO
;;;; padGet: TODO
;;;; padSet: TODO
;;;; padMap: TODO


;;; Imports ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

/+  01_fan  [die seq isNat const]
/+  02_bit  [if ifNot else]
/+  03_nat  [add mul sub bex dec met lsh rsh mod]
/+  05_row  [idx len]
/+  04_cmp  [eql neq lte isZero]
/+  05_row  [map weld foldl]
/+  06_rex  [rexKids rexText rexIsLeaf SHUT WORD CURL {``}]
/+  07_dat  [{,} {++}]
/+  07_dat  [listFromRow listCase listSnoc NIL CONS]
/+  08_sci  []
/+  09_chr  []
/+  10_str  [explode strToList strFromList]
/+  11_set  []
/+  12_tab  []
/+  13_exp  [cnsE]
/+  14_hax  [{#}]


;;; Definitions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

emptyPad=1

(toPad x)=(if x x 1)

= (padNat x)
@ x toPad-x
| sub x
| bex | dec met-x

= (padWeld x y)
@ x toPad-x
@ y toPad-y
@ wid (dec met-x)
| add (sub x bex-wid)
| lsh y wid

= (padCat val)
| foldl padWeld emptyPad val

= (padFlat val)
| if isNat-val val
| padCat (map padFlat val)

= (natPad n wid)
@ pid met-n
| padWeld (add n (bex met-n))
| bex (sub wid (met n))

(padLen p)=(dec met-p)


;;; Parsing Pad Literals ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= (padSplitAt i pad)
| ifNot i [emptyPad pad]
@ remain (rsh pad i)
@ looted (add bex-i (mod pad bex-i))
| ifNot remain [pad emptyPad]
| [looted remain]

; TODO: {readPadLit} should ignore whitespace (spaces and tabs) so
; that multi-line bit-strings are possible.

; Rex > Str > Read Pad
= (readPadStr rex str err ok)
@ lis (listSnoc (strToList str) "1")
^ _ 0 lis 1
? (loop acc lis pos)
| **listCase lis (ok acc)
& (b bs)
@ nextPos (mul 2 pos)
| seq nextPos
| if (eql '0' b)
    | loop acc bs nextPos
| if (eql '1' b)
    @ acc (add pos acc)
    | seq acc
    | loop acc bs nextPos
| else
    | err rex "pad literals must contain only zeros and ones"

; Pad -> Str
= (showPadStr pad)
| strFromList
^ _ pad
? (go rem)
| if (lte rem 1) NIL
| CONS (if (mod rem 2) '1' '0')
| go (rsh rem 1)


;;; The `#p` Macro ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= hpBadShape | "Expcted two kids"
= hpBadType  | "Bar literal expects a text parameter"

; TODO: {showPadLit} should use bare-words for non-empty pads.

= (showPadLit pad)
^ SHUT "#" _ 0
++ WORD "p" 0
++ CURL (showPadStr pad) 0

; Rex > Read Bar
= (readPadLit rex err ok)
@ kids   | rexKids rex
@ strRex | idx 1 kids
| if (neq 2 len-kids)      | err rex hpBadShape
| ifNot (rexIsLeaf strRex) | err strRex hpBadType
| readPadStr rex (rexText strRex) err ok

= ({#p} st rex err ok)
| readPadLit rex err
& pad
| ok st (cnsE pad)

!!= {}   (showPadStr 0)
!!= {}   (showPadStr 1)
!!= {0}  (showPadStr p#0)
!!= {1}  (showPadStr p#1)
!!= {11} (showPadStr p#11)
!!= {10} (showPadStr p#10)
!!= {01} (showPadStr p#01)
!!= {00} (showPadStr p#00)

!!= ``(p#{})   | showPadLit p#{}
!!= ``(p#{00}) | showPadLit p#00


;;; Tests ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

!!= 1 (toPad 0)
!!= 1 (toPad 1)
!!= 1 (toPad toPad)
!!= 3 (toPad 3)

!!= 01 p#""
!!= 02 p#0
!!= 04 p#00
!!= 08 p#000
!!= 16 p#0000
!!= 17 p#1000
!!= 18 p#0100
!!= 20 p#0010
!!= 24 p#0001
!!= 19 p#1100
!!= 21 p#1010
!!= 25 p#1001
!!= 22 p#0110
!!= 26 p#0101
!!= 28 p#0011
!!= 23 p#1110
!!= 27 p#1101
!!= 29 p#1011
!!= 30 p#0111

!!= p#101 | padWeld p#101 0
!!= p#101 | padWeld p#101 const
!!= p#101 | padWeld 0     p#101
!!= p#101 | padWeld const p#101

!!= p#0000 (padWeld p#00 p#00)
!!= p#1000 (padWeld p#10 p#00)
!!= p#0100 (padWeld p#01 p#00)
!!= p#0010 (padWeld p#00 p#10)
!!= p#0001 (padWeld p#00 p#01)
!!= p#1100 (padWeld p#11 p#00)
!!= p#1010 (padWeld p#10 p#10)
!!= p#1001 (padWeld p#10 p#01)
!!= p#0110 (padWeld p#01 p#10)
!!= p#0101 (padWeld p#01 p#01)
!!= p#0011 (padWeld p#00 p#11)
!!= p#1110 (padWeld p#11 p#10)
!!= p#1101 (padWeld p#11 p#01)
!!= p#1011 (padWeld p#10 p#11)
!!= p#0111 (padWeld p#01 p#11)

!!= (padSplitAt 0 p#1111) [ p#''   p#1111 ]
!!= (padSplitAt 1 p#1111) [ p#1    p#111  ]
!!= (padSplitAt 2 p#1111) [ p#11   p#11   ]
!!= (padSplitAt 3 p#1111) [ p#111  p#1    ]
!!= (padSplitAt 4 p#1111) [ p#1111 p#''   ]
!!= (padSplitAt 5 p#1111) [ p#1111 p#''   ]
!!= (padSplitAt 9 p#1111) [ p#1111 p#''   ]

!!= p#''   | padCat []
!!= p#1100 | padCat [p#1100]
!!= p#1100 | padCat [p#11 p#00]
!!= p#1011 | padCat [p#10 p#11]
!!= p#1011 | padCat [p#1 p#0 p#1 p#1]
!!= p#1011 | padCat [p#1 p#0 p#11]
!!= p#1011 | padCat [p#1 p#0 p#11 p#'']

!!= p#''   | padFlat []
!!= p#''   | padFlat [[[]] []]
!!= p#1100 | padFlat [p#1100]
!!= p#1100 | padFlat (const p#1100)
!!= p#1100 | padFlat [[p#1100]]
!!= p#1100 | padFlat [p#11 p#00]
!!= p#1011 | padFlat [p#10 p#11]
!!= p#1011 | padFlat [[p#1 p#0] [p#1 p#1]]
!!= p#1011 | padFlat [[p#1 p#0] p#11]
!!= p#1011 | padFlat [[p#1 [] p#0] p#11 p#'']


;;; Exports ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

^-^ emptyPad
^-^ toPad padNat natPad padLen
^-^ padWeld padCat padFlat
^-^ padSplitAt
^-^
^-^ readPadStr showPadStr
^-^ readPadLit showPadLit
^-^
^-^ {#p}
