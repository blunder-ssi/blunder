;;; Copyright 2023 The Plunder Authors
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.

### 08_dat <- 07_rex

"""
""" Data Structures
""" ===============
"""
""" Rows (vectors), lists, maybe, either, and operations on these
""" datatype.
"""


""" Imports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

/+  01_fan
/+  02_bit  [if else ifNot and or not bit TRUE FALSE]
/+  03_nat  [dec sub add lsh rsh minNat div roundUp mod even isZero]
/+  03_nat  [LT GT EQ gteNat lthNat lteNat]
/+  04_app  [head arity len idx get mut]
/+  05_cmp  [eql neq cmp lth gte]
/+  06_row
/+  07_rex


""" Fake Typing Syntax """""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (">" s p e a r err ok)
@ heir (rexHeir r)
| if (isZero heir)
    | err r "> annotations require an heir to annotate"
| ok p a heir

= ("\" s p e a r err ok)
| ok p a `(#*)

= ("#typedef" s p e a r err ok)
| ok p a `(#*)


""" Basic Row Operations """""""""""""""""""""""""""""""""""""""""""""""""""""""

(rowCons x xs)=(weld (v1 x) xs)
(rowSnoc xs x)=(weld xs (v1 x))

!!= (rowCons 3 v0)       (v1 3)
!!= (rowCons 3 (v1 4))   (v2 3 4)
!!= (rowCons 3 (v2 4 5)) (v3 3 4 5)

!!= (rowSnoc v0 3)       (v1 3)
!!= (rowSnoc (v1 3) 4)   (v2 3 4)
!!= (rowSnoc (v2 3 4) 5) (v3 3 4 5)

(tag row)=(gen len-row i&(c2 idx-i-row i))

= (rep i n)         | gen n _&i
= (rowAnd v)        | foldr and TRUE v
= (rowOr v)         | foldr or FALSE v
= (sum v)           | foldr add FALSE v
= (all f v)         | rowAnd map-f-v
= (any f v)         | rowOr map-f-v
= (cat vs)          | foldr weld v0 vs
= (catMap f r)      | cat (map f r)
= (zipWith f a b)   | gen (minNat len-a len-b) i&(f idx-i-a idx-i-b)
= (zip a b)         | zipWith v2 a b
= (rowApply f xs)   | foldl apply f xs
= (rowRepel f xs)   | foldr supply f xs
= (take n v)        | gen (minNat n len-v) get-v
= (drop n v)        | gen (sub len-v n) i&(get v add-i-n)
= (has ele row)     | any eql-ele row
= (slice v s e)     | gen (sub e s) (i & get v add-s-i)

= (chunks i v)
| ifNot (isApp v) v0
| rev
@ wid (div (roundUp len-v i) i)
^ _ v cow-wid
? (go v acc)
| ifNot (len v) acc
| go (drop i v)
| acc
| take i v

= (span f r)
@ l | len r
^ _ 0
? (loop i)
| if (eql i l) (v2 r v0)
| if (f (idx i r))
    | loop (inc i)
(v2 (take i r) (drop i r))

= (splitAt i r)
(v2 (take i r) (drop i r))

(strictRow a)=(foldl const a a)

= (insert ix val row)
| gen (inc len-row)
& i
| if (lthNat i ix) | idx i row
| if (eql i ix)    | val
| else             | idx (dec i) row

!!= (v2 9 0)   | insert 0 9 (v1 0)
!!= (v2 0 9)   | insert 1 9 (v1 0)
!!= (v2 0 0)   | insert 2 9 (v1 0)
!!= (v3 9 0 1) | insert 0 9 (v2 0 1)
!!= (v3 0 9 1) | insert 1 9 (v2 0 1)
!!= (v3 0 1 9) | insert 2 9 (v2 0 1)
!!= (v3 0 1 0) | insert 3 9 (v2 0 1)


""" Generating Basic Sire Expressions """"""""""""""""""""""""""""""""""""""""""

= (appE exps)
| if (eql 1 (len exps))
    | idx 0 exps
| NEST 0 "#|" exps 0

; Same as `appE` but formatted in open mode.
= (bopE exps)
| if (eql 1 (len exps))
    | idx 0 exps
| OPEN 0 "#|" exps 0

; Same as `appE` but formatted in open mode with last argument as heir.
= (bapE exps)
@ siz (len exps)
@ las (dec siz)
| if (eql 1 siz) (idx 0 exps)
| OPEN 0 "#|" (take las exps) (idx las exps)

= (rowE exps)
@ widt (len exps)
| appE
| rowCons (EMBD (cow widt))
| rev exps

; Same as `rowE` but formatted in open mode.
= (bowE exps)
@ widt (len exps)
| bopE
| rowCons (EMBD (cow widt))
| rev exps


""" Row Literals """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= ("," s p e a rex err ok)
| ok p a (rowE | rexKids rex)

!!= []    v0
!!= [3]   (v1 3)
!!= [3 4] (v2 3 4)
!!= 3,4   (v2 3 4)


""" Maybe """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

''' TODO Use (0 | [x])

= NONE       0
= (**SOME x) (0 x)

= (maybeCase opt non som)
| if isNat-opt non
| **som cdr-opt

(isNone x)=(isZero x)
(isSome x)=(neq 0 x)

(fromSome n x)=(**maybeCase x n id)

(unpackSome x)=(**fromSome (die 'Unexpected NONE') x)

!!= 1 | maybeCase SOME-0 0 inc
!!= 1 | maybeCase SOME-1 0 id
!!= 1 | maybeCase SOME-2 0 dec
!!= 1 | maybeCase NONE   1 die

= (fmapMaybe myb fun)
| **maybeCase myb NONE
& v
| SOME | fun v

!!= SOME-1 | fmapMaybe SOME-0 inc
!!= NONE   | fmapMaybe NONE   inc

!!= 1 | isSome (SOME 0)
!!= 0 | isSome NONE
!!= 0 | isNone (SOME 0)
!!= 1 | isNone NONE


""" Scanning Rows """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

; TODO Consider returning (0 | (idx+1)) to avoid the boxing the result
;      in SOME.
= (findIdx f row)
^ foldr _ NONE tag-row
& (iv rest)
| if f-(snd iv) SOME-(fst iv) rest

= (elemIdx key row)
| findIdx (eql key) row

!!= SOME-0 | elemIdx 5 [5 6 7]
!!= SOME-1 | elemIdx 6 [5 6 7]
!!= SOME-2 | elemIdx 7 [5 6 7]
!!= NONE   | elemIdx 8 [5 6 7]


""" Unfolding """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (unfoldr f b)
^ _ 0 b
? (go idx b)
| **maybeCase (f b) (cow idx)
& xs
@ a | get xs 0
@ newB | get xs 1
| (go (inc idx) newB) a

!!= 1 @ testUnfoldr
           & x
           | if (lteNat x 5) (SOME [x (inc x)]) NONE
      | eql [0 1 2 3 4 5]
      | unfoldr testUnfoldr 0


""" Tests """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

!!= [0 1 2] (v3 0 1 2)

!!= 1 | not (has 1 [2 3 4])
!!= 1 | not (has 1 [2 3 4])
!!= 1 | has 2 [2 3 4]
!!= 1 | has 3 [2 3 4]
!!= 1 | has 4 [2 3 4]
!!= 1 | not (has 5 [2 3 4])

!!= (slice [3 4 5] 0 5) | [3 4 5 0 0]
!!= (slice [3 4 5] 1 4) | [4 5 0]
!!= (slice [3 4 5] 2 3) | [5]
!!= (slice [3 4 5] 3 2) | []

(ADD x y k)=(k x y)

!!= [5 4 3] | rev ([3 4 5])
!!= []      | rev ([])

!!= 12                  | sum-([3 4 5])
!!= [1 2 3 4 5 6 7 8 9] | cat [[] [1] [2 3] [4 5 6] [7 8] [9] []]

!!= [1 2 3] (rowCons 1 [2 3])

!!= []        | take 0  [1 2 3 4]
!!= [1]       | take 1  [1 2 3 4]
!!= [1 2 3 4] | take 4  [1 2 3 4]
!!= [1 2 3 4] | take 20 [1 2 3 4]
!!= [1 2 3 4] | drop 0  [1 2 3 4]
!!= [2 3 4]   | drop 1  [1 2 3 4]
!!= [4]       | drop 3  [1 2 3 4]
!!= []        | drop 4  [1 2 3 4]
!!= []        | drop 20 [1 2 3 4]

!!= [1 2 3 4]     | drop 0 [1 2 3 4]
!!= []            | drop 10 [1 2 3 4]
!!= []            | chunks 3 []
!!= [[1]]         | chunks 3 [1]
!!= [[1 2 3]]     | chunks 3 [1 2 3]
!!= [[1 2 3] [4]] | chunks 3 [1 2 3 4]

!!= 1 | has "aa" ["aa" "bb"]
!!= 1 | not (has "aa" ["bb" "cc"])


""" Switch """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

; TODO Rename to `rowSwitch`?
= (switch i fb ps)
| if (gteNat i len-ps) fb
| idx i ps

; TODO kill this?
; TODO Rename to `rowMatch`?
; TODO Or change this to (ifNat v v (cdr v))?
= (match v fb ps)
| switch idx-0-v fb ps


""" Lists """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= NIL           | 0
= (**CONS x xs) | [x xs]

; TODO: Always inline?
; TODO: Use isZero?

= (listCase xs nil cons)
| if isNat-xs nil
| **cons idx-0-xs idx-1-xs

;; TODO s/([a-z])Singleton/\1Sing/g

(listSing x)=(CONS x 0)

= (listMap f l)
| **listCase l NIL
& (x xs)
| CONS f-x listMap-f-xs

(listTurn l f)=(listMap f l)

= (listHead l)
| **listCase l NONE
& (h _)
| SOME h

= (listSafeHead fb l)
| **listCase l fb
& (x _)
| x

; TODO: Maybe just (idx 0 l)?
(listUnsafeHead l)=(listSafeHead 0 l)

!!= NONE   | listHead NIL
!!= SOME-3 | listHead (CONS 3 (CONS 4 NIL))
!!= 3      | listUnsafeHead (CONS 3 (CONS 4 NIL))
!!= 0      | listUnsafeHead NIL
!!= 5      | fromSome 4 (SOME 5)
!!= 5      | unpackSome (SOME 5)
!!= 4      | fromSome 4 NONE

= (listLast l)
| **listCase l NONE
& (h t)
| **listCase t (SOME h)
& (_ _)
| listLast t

!!= NONE   | listLast NIL
!!= SOME-3 | listLast (CONS 3 NIL)
!!= SOME-4 | listLast (CONS 3 (CONS 4 NIL))

""" Operations With Lists """"""""""""""""""""""""""""""""""""""""""""""""""""""

= (listFoldl f z l)
| **listCase l z
& (x xs)
@ fzx (f z x)
| seq fzx
| listFoldl f fzx xs

= (listFoldr f z l)
| **listCase l z
& (x xs)
| f x (listFoldr f z xs)

= (listMap f l)
| **listCase l NIL
& (x xs)
| CONS f-x listMap-f-xs

(listTurn l f)=(listMap f l)

'''
''' TODO: Create a versions of {listToRow} and {listToRowReversed}
''' that work with static lengths:
'''
''' -  It always produces a row of a certain size.
''' -  If the list is too long, only the head is taken.
''' -  If the list is too short, the rest of the row is zeros.
'''

= (listLen l)           | listFoldr (x acc & inc acc) 0 l
= (listSum l)           | listFoldr add 0 l
= (listToRow l)         | listFoldr supply cow-(listLen l) l
= (listToRowReversed l) | listFoldl apply cow-(listLen l) l
= (listFromRow v)       | foldr CONS NIL v
= (listAnd v)           | listFoldr and TRUE v
= (listOr v)            | listFoldr or 0 v
= (listSum v)           | listFoldr add 0 v
= (listAll f v)         | listAnd listMap-f-v
= (listAny f v)         | listOr listMap-f-v
= (listHas e xs)        | listAny eql-e xs
= (listEnumFrom n)      | CONS n (listEnumFrom inc-n)

= (listWeld a b)
| **listCase a b
& (x xs)
| CONS x (listWeld xs b)

> List (List a) > List a
= (listCat ls)
| **listCase ls NIL
& (x xs)
| listWeld x
| listCat xs

= (listTake num lis)
| ifNot num NIL
| **listCase lis NIL
& (x xs)
| CONS x
| listTake dec-num xs

= (listDrop num lis)
| ifNot num lis
| **listCase lis NIL
| (x xs & listDrop dec-num xs)

= (listTakeWhile f lis)
| **listCase lis NIL
& (x xs)
| if f-x (CONS x | listTakeWhile f xs)
| NIL

= (listDropWhile f lis)
| **listCase lis NIL
& (x xs)
| if f-x listDropWhile-f-xs
| lis

!!= [2 [3 0]]     | listTakeWhile id [2 [3 [0 [4 [5 0]]]]]
!!= [0 [4 [5 0]]] | listDropWhile id [2 [3 [0 [4 [5 0]]]]]

; TODO This does not belong here
; Convert a nat into a list of digits.
; TODO: Use `until`?
= (listDigits num)
| ifNot num (CONS "0" 0)
^ _ num NIL
? (loop mor acc)
| seq acc
| ifNot mor acc
@ char (add (mod mor 10) "0")
@ left (div mor 10)
| loop left (CONS char acc)

; Convert a nat into a row of digits.
= (digits num) (listToRow listDigits-num)
; TODO This really belongs elsewhere!  Maybe in `sci` or `out`?

= (listZipWith f al bl)
| **listCase al NIL
& (a as)
| **listCase bl NIL
& (b bs)
| CONS f-a-b
  (listZipWith f as bs)

(listZip a b)=(listZipWith (0 0 3 0) b a)

!!= | CONS [3 4] | CONS [4 5] NIL
  | listZip listFromRow-[3 4] listFromRow-[4 5]

(listIndexed l)=(listZip (listEnumFrom 0) l)

!!= (listIndexed (, "a" , "b" , "c" 0))
        (, [0 "a"] , [1 "b"] , [2 "c"] 0)

= (listFilter f lis)
| **listCase lis NIL
& (x xs)
| if f-x (CONS x listFilter-f-xs)
| listFilter f xs

(listIsEmpty xs)=(isNat xs)

= (listMinimumOn f a bs)
| **listCase bs a
& (x xs)
| listMinimumOn f
    | if (lthNat f-x f-a) x a
| xs

; TODO inline this CONS
= (listGen n f)
^ _ 0
? (loop i)
| if (eql i n) NIL
| CONS (f i)
| loop (inc i)

!!= (listGen 3 id) [0 [1 [2 0]]]

; {listSortBy}, {listSort}, {sortBy}, {sort} etc are simple
; implementations meant to be used in jets.  If you want a proper
; quicksort or mergesort, implement them yourself.

= (listInsertBy cmp x lis)
| **listCase lis (listSing x)
& (y ys)
| if (cmp x y)
    | CONS y (listInsertBy cmp x ys)
| CONS x lis

; {listUniq} removes duplicate values that appear next to each-other.
; If the input is sorted, then the output will have no duplicates.

= (listUniq xs)
| if (isZero xs) NIL
^ _ (fst xs) (snd xs)
? (go x ys)
| **listCase ys (listSing x)
& (y ys)
| if (eql x y) (go y ys)
| CONS x (go y ys)

= (listSortBy cmp xs) | listFoldr (listInsertBy cmp) NIL xs
= (listSort xs)       | listSortBy cmp xs
= (listSortUniq xs)   | listUniq (listSort xs)
= (comparing f x y)   | cmp (f x) (f y)

= (listSortOn f lis)
| listMap snd
| listSortBy (comparing fst)
| listMap x&(y @ f x)(seq y (y, x))
| lis

; {rowPort} converts from a list operation to a row operation.

= (rowPort op row) | listToRow (op | listFromRow row)
= (uniq row)       | rowPort listUniq         row
= (sortOn f row)   | rowPort (listSortOn f)   row
= (sortBy cmp row) | rowPort (listSortBy cmp) row
= (sort row)       | rowPort listSort         row
= (sortUniq row)   | rowPort listSortUniq     row

!!= [0 3 3 4 5] | sort               | [0 3 4 3 5]
!!= [0 3 3 4 5] | sortBy cmp         | [0 3 4 3 5]
!!= [5 4 3 3 0] | sortBy (flip cmp)  | [0 3 4 3 5]
!!= [0 3 4 3 5] | sortBy _&EQ        | [0 3 4 3 5]
!!= [5 4 3 3 0] | sortOn x&(sub 5 x) | [0 3 4 3 5]
!!= [5 3 4 3 0] | sortOn not         | [0 3 4 3 5]
!!= [0 5 3 4 3] | sortOn bit         | [0 3 4 3 5]
!!= [0 5 0]     | uniq [0 0 5 5 0 0]
!!= [0 5]       | sortUniq [0 0 5 5 0 0]

= (listFindIndex f xs)
^ _ 0 xs
? (loop ix rest)
| seq ix
| **listCase rest NONE
& (x xs)
| if (f x) (SOME ix)
| loop (inc ix) xs

(listElemIndex e xs)=(listFindIndex (eql e) xs)

!!= (0 0) | listElemIndex 0 (, 0 , 1 , 2 , 3 0)
!!= (0 1) | listElemIndex 1 (, 0 , 1 , 2 , 3 0)
!!= (0 2) | listElemIndex 2 (, 0 , 1 , 2 , 3 0)
!!= (0 3) | listElemIndex 3 (, 0 , 1 , 2 , 3 0)
!!= 0     | listElemIndex 4 (, 0 , 1 , 2 , 3 0)

(filter f row)=(| listToRow | listFilter f | listFromRow row)

(delete val row)=(filter (neq val) row)

= (findIdxMany f row)
^ foldr _ NIL tag-row
& (iv rest)
| ifNot f-(snd iv) rest
| CONS (fst iv) rest

(elemIdxMany key row)=(findIdxMany (eql key) row)

!!= [0 [2 0]]
  | elemIdxMany 5 [5 0 5]

= (listIntersperse sep lis)
| **listCase lis lis
& (x xs)
| **listCase xs lis
& (y ys)
| CONS x
| CONS sep
| listIntersperse sep xs

= (listRev a)
^ _ a NIL
? (loop a xs)
| if (listIsEmpty a) xs
| loop (snd a) (CONS (fst a) xs)

= (listSnoc xs e)
| **listCase xs (CONS e NIL)
& (x xs)
| CONS x
| listSnoc xs e

!!= (listSnoc [0 [1 0]] 2)
  | [0 [1 [2 0]]]


""" Either """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (**LEFT x)  [0 x]
= (**RIGHT x) [1 x]

= (eitherCase x l r)     (if (idx 0 x) (**r idx-1-x) (**l idx-1-x))
= (fromRight l x)        (**eitherCase x l id)
= (unpackRight x)        (**fromRight (die 'Unexpected LEFT') x)
= (eitherCaseLeft x r l) (if (idx 0 x) (**r idx-1-x) (**l idx-1-x))
= (eitherOpen x r)       (**eitherCase x _&x r)
= (eitherOpenLeft x l)   (**eitherCase x l _&x)
= (fromLeft r x)         (**eitherCase x id r)
= (unpackLeft x)         (**fromLeft (die 'Unexpected RIGHT') x)
= (eitherGetRight x k)   (**eitherCase x _&x k)
= (eitherGetLeft x k)    (**eitherCase x k _&x)
= (eitherMap f val)      (**eitherCase val 0 (x & 1 f-x))

!!= 1 | eitherCase RIGHT-0 const-0 inc
!!= 1 | eitherCase RIGHT-1 const-0 id
!!= 1 | eitherCase RIGHT-2 const-0 dec
!!= 1 | eitherCase LEFT-9  const-1 die
!!= 1 | eitherCase LEFT-1  id      die
!!= 1 | eitherCase LEFT-0  inc     die

!!= 1 | unpackRight (RIGHT 1)
!!= 1 | unpackLeft (LEFT 1)

> Row (Eat a b) > (Row a, Row b)
= (partition r)
^ map listToRow (foldr _ [NIL NIL] r)
& (x i)
@ lefts  | fst i
@ rights | snd i
| if (fst x)
    | (lefts, CONS (snd x) rights)
| else
    | (CONS (snd x) lefts, rights)

!!= [[0 3] [1 2]]
  | partition [LEFT-0 RIGHT-1 RIGHT-2 LEFT-3]


""" Maybe utils that depend on list """""""""""""""""""""""""""""""""""""""""""

= (listCatMaybes top)
| **listCase top NIL
& (mX xs)
| **maybeCase mX (listCatMaybes xs)
& x
| CONS x (listCatMaybes xs)

; TODO: Fold from the left using an accumulator and remember the output length.
; TODO: Jet fillRowFromAccList:(Nat > List a > Row a), which creates a
;       row from a list, in reverse order with a-prioiri knowledge of
;       the size of the resulting row.  This allows the jet to preallocate
;       an array fill it by walking the list, no need for realloc.
= (mapMaybe law row)
^ listToRowReversed (_ 0 NIL)
? (loop i acc)
| seq acc
| if (eql i | len row) acc
| loop (inc i)
| **maybeCase (law | idx i row) acc
& item
| CONS item acc

= (catMaybes lis)       | listToRow (listCatMaybes (listFromRow lis))
= (listMapMaybe f lis)  | listCatMaybes (listMap f lis)
= (listTurnMaybe lis f) | listMapMaybe f lis
= (turnMaybe row f)     | mapMaybe f row

!!= [1 [2 0]] | listCatMaybes [SOME-1 [SOME-2 0]]
!!= [1 [2 0]] | listCatMaybes [SOME-1 [SOME-2 [NONE 0]]]
!!= [1 [2 0]] | listCatMaybes [SOME-1 [NONE [SOME-2 [NONE 0]]]]
!!= [1 [2 0]] | listCatMaybes [NONE [SOME-1 [NONE [SOME-2 [NONE 0]]]]]

!!= [1 2] | catMaybes ( SOME 1 , SOME 2 )
!!= [1 2] | catMaybes ( SOME 1 , SOME 2 , NONE )
!!= [1 2] | catMaybes ( SOME 1 , NONE   , SOME 2 , NONE )
!!= [1 2] | catMaybes ( NONE   , SOME 1 , NONE   , SOME 2 )

!!= [2 4 6] | turnMaybe [1 2 3 4 5 6] x&(if (even x) SOME-x NONE)
!!= [1 4 5] | catMaybes [SOME-1 NONE SOME-4 SOME-5 NONE]


""" Tall-Form Row Literals """""""""""""""""""""""""""""""""""""""""""""""""""""

openRowExpect={Expected something like (,, x), (,, f x y), etc}

= (readOpenRow readExp rex err ok)
^ _ NIL rex
? (go acc rex)
@ sons (rexSons rex)
@ heir (rexHeir rex)
@ rune (rexRune rex)
| if (isZero rex)
    | ok (listToRowReversed acc)
| if (neq {,,} rune)
    | readExp rex err
    & exp
    @ acc (CONS exp acc)
    | go acc 0
| if (null sons)
    | err rex openRowExpect
@ itemRex
    | if (eql 1 | len sons) (idx 0 sons)
    | OPEN 0 "|" sons 0
| readExp itemRex err
& exp
@ acc (CONS exp acc)
| seq acc
| go acc heir

(readRex rex err ok)=(ok rex)

= ({,,} s p e a r err ok)
| readOpenRow readRex r err
& res
| ok p a (rowE res)

!!= [3 4 5] (,, 3)(,, 4)(,, 5)
!!= [3 4 5] (,, 3)(,, 4)5
!!= [3 4 5] (,,3)(,, 3 3)5

!!= [3 4 5]
 ,, 3
 ,, 4
 ,, 5


""" Binary Search """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

; {bsearch} finds the index of an item within a "row set".  The input
; row is presumed to be in ascending order and without duplciates.
;
; {bsearch} finds the index of an item equal to the target, or the
; index of the smallest item larger than the target, or it returns the
; length of the array, if no such item exists.
;
; The result is tagged to indicate if the result is a match or not.
; Tagging works by left-shifting the resuilt by one, and then setting the
; low bit only if there was a match.
;
; The index returned in the "not found" case is always the index where
; this item could be inserted without breaking the "row set" invariants.
;
; {lsearch} has the same behavior as {bsearch}, and mostly just exists
; as a test case.

(**found ix)=(inc | lsh ix 1)
(**not_found ix)=(lsh ix 1)

> Any > Row Any > Nat > Nat > Nat
= (lsearch_ key row low end)
| if (gte low end) (not_found low)
| switch (cmp key | get row low) 0
,, not_found low                   ;;  LT
,, found low                       ;;  EQ
,, lsearch_ key row (inc low) end  ;;  GT

> Any > Row Any > Nat
= (bsearch_ key row low end)
| if (gte low end) (not_found low)
@ index (rsh (add low end) 1)
| switch (cmp key | get row index) 0
,, bsearch_ key row low index        ;; LT
,, found index                       ;; EQ
,, bsearch_ key row (inc index) end  ;; GT

(lsearch key row)=(lsearch_ key row 0 (len row))
(bsearch key row)=(bsearch_ key row 0 (len row))

= (search_chk row assoc)
^ foldr _ TRUE assoc
& (kv continue)
@ k (fst kv)
@ e (snd kv)
@ lr (lsearch k row)
@ br (bsearch k row)
| if (neq e lr) ['lsearch mismatch' ['for key' k] [e '!=' lr]]
| if (neq e br) ['bsearch mismatch' ['for key' k] [e '!=' br]]
| continue

N=not_found
F=found

!!= 1 | search_chk []        | tag [N|0 N|0 N|0]
!!= 1 | search_chk [1]       | tag [N|0 F|0 N|1]
!!= 1 | search_chk [1 3 5]   | tag [N|0 F|0 N|1 F|1 N|2 F|2 N|3 N|3]
!!= 1 | search_chk [1 3 5 7] | tag [N|0 F|0 N|1 F|1 N|2 F|2 N|3 F|3 N|4]
!!= 1 | search_chk [1 3 5 6] | tag [N|0 F|0 N|1 F|1 N|2 F|2 F|3 N|4 N|4]


""" Traversing Lists """""""""""""""""""""""""""""""""""""""""""""""""""""""""""

> (a > (b>r)) > Row a > m (Row b)
= (traverseList f xs return)
^ _ NIL xs
? (go acc remain)
| **listCase remain
    (return (listRev acc))
& (head tail)
| f head
& newHead
| go (CONS newHead acc) tail

(forList xs f return)=(**traverseList f xs return)

!!= 0         | traverseList (x ret)&(if even-x ret-x 0) [3 [4 0]] id
!!= 0         | traverseList (x ret)&(if even-x ret-x 0) [4 [5 0]] id
!!= [4 [6 0]] | traverseList (x ret)&(if even-x ret-x 0) [4 [6 0]] id


> st
> (st > b > r)
> st
> List a
> m st (List b)
= (traverseListWithState st f xs return)
^ _ st NIL xs
? (go st acc remain)
| listCase remain (return st (listRev acc))
& (head tail)
| f st head
& (st newHead)
@ acc (CONS newHead acc)
| go st acc tail

(forListWithState st xs f return)=(**traverseListWithState st f xs return)

!!= 17,(, 3 , 4 , 5 0)
  ^ forListWithState 5 [3 [4 [5 0]]] _ v2
  ? (step st item pure)
  | pure (add st item) item


""" Traversing Rows """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""

> (a > (b>r)) > Row a > m (Row b)
= (traverseRow f xs return)
| traverseList f (listFromRow xs)
& out
| return (listToRow out)

(forRow xs f return)=(**traverseRow f xs return)

!!= 0     | traverseRow (x ret)&(if even-x ret-x 0) [3 4] id
!!= 0     | traverseRow (x ret)&(if even-x ret-x 0) [4 5] id
!!= [4 6] | traverseRow (x ret)&(if even-x ret-x 0) [4 6] id


> (a > (st>b>r)) > st > Row a > m st (Row b)
= (traverseRowWithState st f xs return)
| traverseListWithState st f (listFromRow xs)
& (st out)
| return st (listToRow out)

(forRowWithState st xs f return)=(**traverseRowWithState st f xs return)

!!= 17,[4 5 6]
  ^ forRowWithState 5 [3 4 5] _ v2
  ? (step st item pure)
  | pure (add st item) (inc item)


""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^
^-^ slice chunks rep rowCons rowSnoc
^-^ switch match
^-^ tag findIdx elemIdx has
^-^ rowAnd rowOr sum all any zip zipWith
^-^ cat catMap
^-^ take drop rev
^-^ rowApply rowRepel unfoldr span splitAt strictRow insert
^-^
^-^ bopE bapE bowE appE rowE
^-^ ","
^-^
^-^ NONE SOME maybeCase
^-^ fromSome unpackSome
^-^ isSome isNone fmapMaybe
^-^
^-^ mapMaybe turnMaybe catMaybes
^-^ listMapMaybe listTurnMaybe listCatMaybes
^-^
^-^ NIL CONS
^-^ listCase
^-^ listSing
^-^ listMap listTurn
^-^ listHead listSafeHead listUnsafeHead listLast
^-^
^-^ listFoldl listFoldr listMap listTurn listLen listSum listToRow
^-^ listToRowReversed listFromRow listAnd listOr listSum listAll listAny
^-^ listHas listEnumFrom listWeld listCat listTake listDrop listDigits
^-^ listTakeWhile listDropWhile
^-^ digits listZipWith listZip listFilter listIsEmpty listMinimumOn listSortOn
^-^ listGen listFindIndex listElemIndex
^-^ listIndexed
^-^ listIntersperse
^-^ listRev listSnoc
^-^
^-^ LEFT RIGHT
^-^ fromLeft unpackLeft
^-^ fromRight unpackRight
^-^ eitherCase eitherOpen
^-^ eitherOpenLeft eitherCaseLeft
^-^ eitherGetRight eitherGetLeft
^-^ eitherMap partition
^-^
^-^ sort sortBy sortOn sortUniq
^-^ filter delete
^-^ findIdxMany elemIdxMany
^-^
^-^ readRex
^-^ readOpenRow
^-^ ",,"
^-^
^-^ lsearch lsearch_
^-^ bsearch bsearch_
^-^
^-^ traverseList forList traverseListWithState forListWithState
^-^ traverseRow forRow traverseRowWithState forRowWithState
^-^
^-^ ">" "#typedef" "\"
^-^
