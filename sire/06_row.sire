;;; Copyright 2023 The Plunder Authors
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.

### 06_row <- 04_cmp

"""
""" Rows
""" ====
"""
""" This module defines some very basic operations on rows, which are
""" data-jetted arrays.  Since PLAN is untyped, these are also used
""" the building block used for tuples/records/datatypes.
"""
""" The bulk of the row operations are defined in 08_dat.sire, since many
""" operations are more naturally defined along with operations on other
""" datat types (such as lists and optional values).
"""
""" A row is represented as (cow n) partially applied to n argumnts,
""" for example:
"""
"""     [5 4 3] = ((cow 3) 3 4 5)
"""             = ((0 0 4 0) 3 4 5)
"""             = (0 0 4 0 3 4 5)
"""
""" `get`, `idx`, and `len` are primarily intended to be used with rows,
""" however their legal code is defined to work on any closure.
""" For example, then length of (1 2 3) is 2 and it's first element is 3.
"""
""" Similarly, operations like `map` and `gen` are defined in terms of
""" these primitives also work with closures.
"""


""" Imports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

/+  01_fan  [LAW inc seq]
/+  01_fan  [car cdr caar caaar caaaar]
/+  01_fan  [isApp isLaw lawName lawBody]
/+  01_fan  [id const apply supply]
/+  02_bit  [if ifNot and or not]
/+  03_nat  [dec sub add]
/+  04_cmp  [eql lth isZero]


""" Basic Closure Operations """""""""""""""""""""""""""""""""""""""""""""""""""

(head non)=(if isApp-non (head car-non) non)

(null row)=(not isApp-row)

= (arity x)
@ p arity
@ l (_ a _)&a
@ a (f _)&(dec arity-f)
@ n | 2 3 | 2 5 | 2 3 | const 1 ; [0=3 1=5 2=3 _=1]
| 1 p l a n x

= (len v)
^ _ 0 v
? (go n v)
| seq n
| ifNot (isApp v) n
| go (inc n) (car v)

;;;
;;; {put} modifies the closure {r}, returning a new closure where
;;; the {k}th argument is replaced with {v}.
;;;
;;; Remember that the nth element of a closure is counted from the
;;; right.  For example, (put (f a x) 0 y) => (f a y)
;;;
= (put r k v)
| if (null r) | r
| if (not k)  | car r v
| put (car r) (dec k) v (cdr r)

= (get r i)
| if (null r) 0
| 2 (cdr r) (get (car r)) i

(idx k r)=(get r k)

(mut k v r)=(put r k v)


""" Core Definitions """""""""""""""""""""""""""""""""""""""""""""""""""""""""""

(cow n)=(LAW 0 inc-n 0)

c0=(cow 0)
c1=(cow 1)
c2=(cow 2)
c3=(cow 3)
c4=(cow 4)
c5=(cow 5)
c6=(cow 6)
c7=(cow 7)
c8=(cow 8)
c9=(cow 9)

v0=c0
v1=c1
(v2 a b)=(c2 b a)
(v3 a b c)=(c3 c b a)
(v4 p q r s)=(c4 s r q p)
(v5 a b c d e)=(c5 e d c b a)
(v6 a b c d e f)=(c6 f e d c b a)
(v7 a b c d e f g)=(c7 g f e d c b a)
(v8 a b c d e f g h)=(c8 h g f e d c b a)
(v9 a b c d e f g h i)=(c9 i h g f e d c b a)

; TODO: Get rid of {mkrow}.  It's archane and can be lived without.
= (mkRow n)
^ (0 0 n (_ n (2 cow-n)))
? (go i acc)
| ifNot i acc
| go (dec i) (0 acc i)

= (isCow val)
| and (isLaw val)
| and (isZero | lawName val)
      (isZero | lawBody val)

= (isRow r)
| and (eql 1 arity-r)
| isCow head-r


""" Generating Rows """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (gen n f)
^ _ n (cow n)
? (go mor acc)
| ifNot mor acc
@ nex (dec mor)
| go nex (acc | f nex)


""" Folding Rows """"""""""""""""'""""""""""""""""""""""""""""""""""""""""""""""

= (foldr f z row)
^ _ 0 (len row)
? (go i rem)
| ifNot rem z
| f (get row i)
| go (inc i) (dec rem)

= (foldl f z row)
^ _ z 0 (len row)
? (go acc i rem)
| ifNot rem acc
@ rem (dec rem)
@ acc (f acc (idx i row))
| seq acc
| go acc (inc i) rem

(ADD x y k)=(k x y)

!!= (foldr ADD "z" (v0))       | "z"
!!= (foldl ADD "z" (v0))       | "z"
!!= (foldr ADD "z" (v3 1 2 3)) | ADD 1 | ADD 2 | ADD 3 "z"
!!= (foldl ADD "z" (v3 1 2 3)) | ADD (ADD (ADD "z" 1) 2) 3
!!= (foldl ADD "z" 1)          | "z"
!!= (foldl ADD "z" (0 1))      | ADD "z" 1
!!= (foldl ADD "z" (0 2 1))    | ADD (ADD "z" 1) 2


""" Concatenation """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (weld x y)
@ xw len-x
@ yw len-y
| gen (add xw yw)
& i
| if (lth i xw) (idx i x)
| idx (sub i xw) y

!!= (v3 1 2 3) | weld (v0) (v3 1 2 3)
!!= (v3 1 2 3) | weld (v1 1) (v2 2 3)
!!= (v3 1 2 3) | weld (v2 1 2) (v1 3)
!!= (v3 1 2 3) | weld (v3 1 2 3) (v0)


""" More Basic Operations """"""""""""""""""""""""""""""""""""""""""""""""""""""

= (fst x)         | idx 0 x
= (snd x)         | idx 1 x
= (map f v)       | gen len-v x&(f idx-x-v)
= (rev xs)        @ wid len-xs | gen wid i&(get xs sub-wid-(inc i))
= (rowApply f xs) | foldl apply f xs
= (rowRepel f xs) | foldr supply f xs
= (curry f x y)   | f (c2 y x)
= (uncurry f xy)  | f (fst xy) (snd xy)


""" Tests """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

!!= 1 | isRow v0
!!= 1 | isRow (v1 1)
!!= 1 | isRow (v2 1 2)
!!= 1 | not (isRow (0 0 3 (v2 0 1)))
!!= 1 | not (isRow isRow)

!!= (v3 3 4 5) | caaar  (v3 3 4 5) 5 4 3
!!= (v2 3 4)   | caar   (v2 3 4)   4 3
!!= (v1 3)     | car    (v1 3)     3
!!= (v0)       | car    (v0)       0
!!= (v1 3)     | caar   (v1 3)     0 3
!!= (v2 3 4)   | caaar  (v2 3 4)   0 4 3
!!= (v3 3 4 5) | caaaar (v3 3 4 5) 0 5 4 3

!!= 3 | len (v3 0 0 0)
!!= 2 | len (v2 0 0)
!!= 1 | len (v1 0)
!!= 0 | len (v0)

!!= 1 | null (v0)
!!= 0 | null (v1 "x")

!!= 1 | eql 3 arity-0
!!= 1 | eql 5 arity-1
!!= 1 | eql 3 arity-2
!!= 1 | eql 1 arity-3
!!= 1 | eql 1 arity-4
!!= 1 | eql 1 arity-5

!!= 1 | arity arity
!!= 1 | arity 3
!!= 1 | arity 4
!!= 1 | arity 0-1-2

!!= 1 | eql 2 arity-(0 0)
!!= 1 | eql 3 arity-0

!!= 1 | cdr (0 0 2 0 1)
!!= 1 | cdr (0 0 3 0 2 1)
!!= 1 | cdr car-(0 0 3 0 1 2)

!!= 1 | eql 0 | len v0
!!= 1 | len (v1 0)
!!= 1 | eql 1 | len (v1 0)

!!= 1 | eql 2 | len (v2 0 0)
!!= 1 | eql 0 | len 0
!!= 1 | eql 1 | len (0 1)

!!= 1 | eql 0 | idx 0 2
!!= 1 | eql 3 | idx 0 (2 3)
!!= 1 | eql 4 | idx 0 (2 3 4)
!!= 1 | eql 3 | idx 1 (2 3 4)
!!= 1 | eql 0 | idx 2 (2 3 4)

!!= 1 | eql 0 | idx 0 1
!!= 1 | eql 1 | idx 0 (1 0 1)
!!= 1 | eql 0 | idx 1 (1 0 1)
!!= 1 | eql 0 | idx 2 (1 0 1)

!!= 1 | eql 0 | get 1 0
!!= 1 | eql 1 | get (1 0 1) 0
!!= 1 | eql 0 | get (1 0 1) 1
!!= 1 | eql 0 | get (1 0 1) 2

!!= 1 | null-get
!!= 1 | null-0
!!= 1 | not null-(0 'x')

!!= 1        | uncurry sub (v2 4 3)
!!= (v2 3 4) | curry id 3 4

!!= 7 | rowApply add (v2 4 3)
!!= 1 | rowApply sub (v2 4 3)
!!= 7 | rowRepel add (v2 3 4)
!!= 1 | rowRepel sub (v2 3 4)

!!= (ADD 0 1) | rowApply ADD (v2 0 1)
!!= (2 0 1)   | rowApply ADD (v3 0 1 2)
!!= 1         | rowApply add (v2 0 1)
!!= (1 1)     | rowApply add (v3 0 1 1)
!!= (1 1)     | rowApply add (v2 0 1) 1
!!= (1 1 1)   | rowApply add (v2 0 1) 1 1

!!= (rowRepel ADD (v2 1 0))   | ADD 0 1
!!= (rowRepel ADD (v3 2 1 0)) | 2 0 1

!!= (v3 5 4 3) | rev | v3 3 4 5
!!= (v0)       | rev | v0


""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^
^-^ head null arity len
^-^ idx get
^-^ mut put
^-^
^-^ c0 c1 c2 c3 c4 c5 c6 c7 c8 c9
^-^ v0 v1 v2 v3 v4 v5 v6 v7 v8 v9
^-^
^-^ cow isCow isRow
^-^ mkRow null
^-^ weld
^-^ gen foldr foldl
^-^ mut put
^-^ fst snd
^-^ map rev
^-^ curry uncurry
^-^ rowApply rowRepel
^-^
