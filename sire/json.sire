;;; Copyright 2023 The Plunder Authors
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.

### json <- jlex

/+  boot
/+  switch    ["#switch"]
/+  mutrec    ["#mutrec"]
/+  datatype
/+  jlex
/+  stew
/+  types


""" Json Values """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

TAG_JSON_STR='str'
TAG_JSON_NUM='num'
TAG_JSON_VEC='vec'
TAG_JSON_MAP='map'

# datatype Json
* ( JSON_NULL  = null  )
* ( JSON_TRUE  = true  )
* ( JSON_FALSE = false )
* ( JSON_STR   = str   ) s:Bar
* ( JSON_NUM   = num   ) n:Nat
* ( JSON_VEC   = vec   ) r:(Row Json)
* ( JSON_MAP   = map   ) t:(Tab Str Json)


""" Parsing """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (eatSpace stream)
: t ts <- **listCase stream stream
| if (TSPACE == t) ts stream

= (parseLexerStream inputStream topFail topOkay)
# mutrec %loop
   | val inputStream topFail topOkay
* (val stream fail ok)
   @ stream | eatSpace stream
   : t ts   <- **listCase stream (fail "value" stream)
   # switch (dataTag t)
   * null   | ok JSON_NULL ts
   * true   | ok JSON_TRUE ts
   * false  | ok JSON_FALSE ts
   * l_brak | arr NIL ts fail ok
   * l_curl | obj #[] ts fail ok
   * str    | ok (**JSON_STR | idx 1 t) ts
   * num    | ok (**JSON_NUM | idx 2 t) ts  ; todo: more data.
   * err    @ [_ off why] t
            @ msg (strCat ["lex error @" showNat-off ": " why])
            | fail msg stream
   * _      | fail "value" stream
;
* (obj acc stream fail ok)
   ;
   @ stream (eatSpace stream)
   ;
   : t@[k v] ts <- **listCase stream (fail "'}', or key" stream)
   ;
   | if (t == TRCURL)
       | ok (**JSON_MAP acc) ts
   ;
   | if (or isNat-t (k /= TAG_JSON_STR))
       | fail "'}', or key" stream
   ;
   @ newKey   | barNat v
   @ stream   | eatSpace ts
   @ complain | fail {Expecting :} stream
   : t ts     < **listCase stream complain
   ;
   | if (TCOLON /= t) complain
   ;
   @ stream        | eatSpace ts
   : newVal stream < val stream fail
   @ !acc          | tabIns newKey newVal acc
   @ stream        | eatSpace stream
   @ complain      | fail 'Expecting , or }' stream
   : t ts          < **listCase stream complain
   ;
   | if (t == TRCURL) | obj acc stream fail ok
   | if (t == TCOMMA) | obj acc ts fail ok
   ;
   | complain
;
* (arr acc stream fail ok)
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; [end]
   @ stream   | eatSpace stream
   @ complain | fail "space, ']', or value" stream
   : t ts     < **listCase stream complain
   ;
   | if (t == TRBRAK)
       @ res (**JSON_VEC (listToRowReversed acc))
       | ok res ts
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; [val]
   : val more <- val stream fail
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; [more]
   @ more     | eatSpace more
   @ complain | fail "space, ']', or value" stream
   : m ms     < **listCase more complain
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; [final]
   | if (TRBRAK == m)
       @ acc (CONS val acc)
       @ !res (**JSON_VEC (listToRowReversed acc))
       | ok res ms
   | if (TCOMMA == m)
       @ acc (CONS val acc)
       | arr acc ms fail ok
   | fail "space or ',' or ']'" more

= (parseValue input)
@ tokStream       | lexJson input
@ (fail reason _) | reason
@ (okay v extra)  | [v extra]
| parseLexerStream tokStream fail okay

!!= (parseValue b#{"})
  | 'lex error @0: Unexpected EOF (string)'

!!= (parseValue b#{[null]})
  ^ (JSON_VEC [_], NIL)
  | JSON_NULL

!!= (parseValue b#{ [null,null,true,false] })
  ^ (JSON_VEC _, [TSPACE 0])
 ++ JSON_NULL
 ++ JSON_NULL
 ++ JSON_TRUE
 ++ JSON_FALSE

!!= (parseValue b#{[[]]})
  ^ (JSON_VEC [_], NIL)
  | JSON_VEC []

!!= (parseValue b#{[[null,null]]})
  ^ (JSON_VEC [_], NIL)
  | (JSON_VEC (JSON_NULL, JSON_NULL))

!!= (parseValue b#{[[0,0],[0, 0],[0 ,0],[0 , 0]]})
  ^ (JSON_VEC _, NIL)
 ++ JSON_VEC (JSON_NUM 0, JSON_NUM 0)
 ++ JSON_VEC (JSON_NUM 0, JSON_NUM 0)
 ++ JSON_VEC (JSON_NUM 0, JSON_NUM 0)
 ++ JSON_VEC (JSON_NUM 0, JSON_NUM 0)

!!= (parseValue b#{[0, ",", 1]})
  ^ (JSON_VEC _, NIL)
  | (JSON_NUM 0, JSON_STR b#{,}, JSON_NUM 1)

!!= (parseValue b#{{}})   (JSON_MAP #[], NIL)
!!= (parseValue b#{ { }}) (JSON_MAP #[], NIL)
!!= (parseValue b#{ {"str":"x", "null":null}})
  ^ (JSON_MAP _, NIL)
 ## =str  | JSON_STR b#x
 ## =null | JSON_NULL


""" Printer """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""" TODO: Substitue escape characters.
""" TODO: Handle edge-cases with "\u1234" escapes.

= (printJSON input)
^ barFlat (_ input)
? (go json@[t v])
;
| if (JSON_NULL == json)  | b#null
| if (JSON_TRUE == json)  | b#true
| if (JSON_FALSE == json) | b#false
| if (TAG_JSON_STR == t)  | [b#{"} v b#{"}]
| if (TAG_JSON_NUM == t)  | natBar (showNat v)
| if (TAG_JSON_VEC == t)
   ++ b#{[}
   ++ listIntersperse b#{,} (| listFromRow | map go v)
   ++ b#{]}
| if (TAG_JSON_MAP == t)
   ++ b#'{'
   ++  ^ listIntersperse b#{,} (| listFromRow | map _ | tabToPairs v)
       ? (goKV [k v])
      ++ go (JSON_STR | natBar k)
      ++ b#{:}
      ++ go v
   ++ b#'}'
| die ["impossible" t json]

!!= b#{["hi",null,true,false,99]}
  ^ printJSON (JSON_VEC _)
 ++ JSON_STR b#hi
 ++ JSON_NULL
 ++ JSON_TRUE
 ++ JSON_FALSE
 ++ JSON_NUM 99

!!= b#{{"null":null,"bools":[true,false]}}
  ^ printJSON (JSON_MAP _)
 ## =null  | JSON_NULL
 ## =bools | JSON_VEC [JSON_TRUE JSON_FALSE]

!!=  ++ b#{{}}
     ++ b#{{}}
     ++ b#{{"str":"x","null":null}}
 ++ printJSON | idx 0 | parseValue b#{{}}
 ++ printJSON | idx 0 | parseValue b#{ { }}
 ++ printJSON | idx 0 | parseValue b#{ {"str":"x", "null":null}}


""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^
^-^ parseValue printJSON
^-^
^-^ Json
^-^ JSON_NULL JSON_TRUE JSON_FALSE JSON_STR JSON_NUM JSON_VEC JSON_MAP
^-^
