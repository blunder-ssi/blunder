;;; Copyright 2023 The Plunder Authors
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.

### json <- jlex

/+  boot
/+  switch    ["#switch"]
/+  mutrec    ["#mutrec"]
/+  datatype
/+  jlex
/+  stew
/+  types


""" Native Representation """"""""""""""""""""""""""""""""""""""""""""""""""""""

abstype#Json

> Json > Nat
= (jsonTag x)
@ t (typeTag x)
| if (t == natTag) x t

#= JNULL       | {null}
#= JTRUE       | {true}
#= JFALSE      | {false}
#= (**JSTR x)  | x
#= (**JNUM n)  | 0 n
#= (**JVEC xs) | xs
#= (**JMAP kv) | kv

zero=0
one=1

setProp#(JNULL.conTag)#JNULL
setProp#(JNULL.conAri)#zero
setProp#(JNULL.conFun)#jsonTag
setProp#(JNULL.conHas)#FALSE
setProp#(JNULL.conRaw)#FALSE

setProp#(JTRUE.conTag)#JTRUE
setProp#(JTRUE.conAri)#zero
setProp#(JTRUE.conFun)#jsonTag
setProp#(JTRUE.conHas)#FALSE
setProp#(JTRUE.conRaw)#FALSE

setProp#(JFALSE.conTag)#JFALSE
setProp#(JFALSE.conAri)#zero
setProp#(JFALSE.conFun)#jsonTag
setProp#(JFALSE.conHas)#FALSE
setProp#(JFALSE.conRaw)#FALSE

setProp#(JSTR.conTag)#barTag
setProp#(JSTR.conAri)#one
setProp#(JSTR.conFun)#jsonTag
setProp#(JSTR.conHas)#FALSE
setProp#(JSTR.conRaw)#TRUE

setProp#(JNUM.conTag)#appTag
setProp#(JNUM.conAri)#one
setProp#(JNUM.conFun)#jsonTag
setProp#(JNUM.conHas)#FALSE   ; Fetching with idx-0 works on (0 _)
setProp#(JNUM.conRaw)#FALSE   ; False because wrapper in (0 _)

setProp#(JVEC.conTag)#rowTag
setProp#(JVEC.conAri)#one
setProp#(JVEC.conFun)#jsonTag
setProp#(JVEC.conHas)#FALSE
setProp#(JVEC.conRaw)#TRUE

setProp#(JMAP.conTag)#tabTag
setProp#(JMAP.conAri)#one
setProp#(JMAP.conFun)#jsonTag
setProp#(JMAP.conHas)#FALSE
setProp#(JMAP.conRaw)#TRUE

= (jsonWithType j)
# datacase j
* JNULL   [{n} j]
* JTRUE   [{t} j]
* JFALSE  [{f} j]
* JSTR|x  [{s} x]
* JNUM|n  [{u} n]
* JVEC|xs [{v} xs]
* JMAP|kv [{m} kv]

!!=   | map jsonWithType
      | [ "null" "true" "false" b#"lol" 0-9 [0-3 0-4 0-5] #[foo="null"] ]
 ++ [%n %null]
 ++ [%t %true]
 ++ [%f %false]
 ++ [%s b#lol]
 ++ [%u 9]
 ++ [%v [0-3 0-4 0-5]]
 ++ [%m [foo={null}]]


""" Parsing """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (eatSpace stream)
: t ts <- **listCase stream stream
| if (TSPACE == t) ts stream

= (parseLexerStream inputStream topFail topOkay)
# mutrec %loop
   | val inputStream topFail topOkay
* (val stream fail ok)
   @ stream | eatSpace stream
   : t ts   <- **listCase stream (fail "value" stream)
   # switch (dataTag t)
   * null   | ok JNULL ts
   * true   | ok JTRUE ts
   * false  | ok JFALSE ts
   * l_brak | arr NIL ts fail ok
   * l_curl | obj #[] ts fail ok
   * str    | ok (JSTR | idx 1 t) ts
   * num    | ok (JNUM | idx 2 t) ts  ; todo: more data.
   * err    @ [_ off why] t
            @ msg (strCat ["lex error @" showNat-off ": " why])
            | fail msg stream
   * _      | fail "value" stream
;
* (obj acc stream fail ok)
   ;
   @ stream (eatSpace stream)
   ;
   : t@[k v] ts <- **listCase stream (fail "'}', or key" stream)
   ;
   | if (t == TRCURL)
       | ok (JMAP acc) ts
   ;
   | if (isNat t || neq {str} k)
       | trk #[=t =k =v]
       | fail "'}', or key" stream
   ;
   @ newKey   | barNat v
   @ stream   | eatSpace ts
   @ complain | fail {Expecting :} stream
   : t ts     < **listCase stream complain
   ;
   | if (TCOLON /= t) complain
   ;
   @ stream        | eatSpace ts
   : newVal stream < val stream fail
   @ !acc          | tabIns newKey newVal acc
   @ stream        | eatSpace stream
   @ complain      | fail 'Expecting , or }' stream
   : t ts          < **listCase stream complain
   ;
   | if (t == TRCURL) | obj acc stream fail ok
   | if (t == TCOMMA) | obj acc ts fail ok
   ;
   | complain
;
* (arr acc stream fail ok)
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; [end]
   @ stream   | eatSpace stream
   @ complain | fail "space, ']', or value" stream
   : t ts     < **listCase stream complain
   ;
   | if (t == TRBRAK)
       @ res (JVEC | listToRowReversed acc)
       | ok res ts
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; [val]
   : val more <- val stream fail
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; [more]
   @ more     | eatSpace more
   @ complain | fail "space, ']', or value" stream
   : m ms     < **listCase more complain
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; [final]
   | if (TRBRAK == m)
       @ acc (CONS val acc)
       @ !res (JVEC | listToRowReversed acc)
       | ok res ms
   | if (TCOMMA == m)
       @ acc (CONS val acc)
       | arr acc ms fail ok
   | fail "space or ',' or ']'" more

= (parseValue input)
@ tokStream       | lexJson input
@ (fail reason _) | reason
@ (okay v extra)  | [v extra]
| parseLexerStream tokStream fail okay

!!= (parseValue b#{"})
  | 'lex error @0: Unexpected EOF (string)'

!!= (parseValue b#{[null]})
  ^ (JVEC [_], NIL)
  | JNULL

!!= (parseValue b#{ [null,null,true,false] })
  ^ (JVEC _, [TSPACE 0])
 ++ JNULL
 ++ JNULL
 ++ JTRUE
 ++ JFALSE

!!= (parseValue b#{[[]]})
  ^ (JVEC [_], NIL)
  | JVEC []

!!= (parseValue b#{[[null,null]]})
  ^ (JVEC [_], NIL)
  | (JVEC (JNULL, JNULL))

!!= (parseValue b#{[[0,0],[0, 0],[0 ,0],[0 , 0]]})
  ^ (JVEC _, NIL)
 ++ JVEC (JNUM 0, JNUM 0)
 ++ JVEC (JNUM 0, JNUM 0)
 ++ JVEC (JNUM 0, JNUM 0)
 ++ JVEC (JNUM 0, JNUM 0)

!!= (parseValue b#{[0, ",", 1]})
  ^ (JVEC _, NIL)
  | (JNUM 0, JSTR b#{,}, JNUM 1)

!!= (parseValue b#{{}})   (JMAP #[], NIL)
!!= (parseValue b#{ { }}) (JMAP #[], NIL)
!!= (parseValue b#{ {"str":"x", "null":null}})
  ^ (JMAP _, NIL)
 ## =str  | JSTR b#x
 ## =null | JNULL


""" Printer """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""" TODO: Substitue escape characters.
""" TODO: Handle edge-cases with "\u1234" escapes.

= (printVec go vec)
^ [b#{[} _ b#{]}]
| listIntersperse b#{,}
| listFromRow
| map go vec

= (printMap go map)
^ [b#'{' _ b#'}']
^ (| listIntersperse b#{,} | listMap _ | tabToPairList map)
& [k v]
| (go (JSTR | natBar k), b#{:}, go v)

= (printJSON input)
^ barFlat (_ input)
? (go json)
# datacase json
* JNULL  | b#null
* JTRUE  | b#true
* JFALSE | b#false
* JSTR|s | [b#{"} s b#{"}]
* JNUM|n | natBar (showNat n)
* JVEC|v | printVec go v
* JMAP|t | printMap go t
* _      | {bad json} [json [tag=(jsonTag json)]]

!!= b#{["hi",null,true,false,99]}
  ^ printJSON (JVEC _)
 ++ JSTR b#hi
 ++ JNULL
 ++ JTRUE
 ++ JFALSE
 ++ JNUM 99

!!= b#{{"null":null,"bools":[true,false]}}
  ^ printJSON (JMAP _)
 ## =null  | JNULL
 ## =bools | JVEC [JTRUE JFALSE]

!!=  ++ b#{{}}
     ++ b#{{}}
     ++ b#{{"str":"x","null":null}}
 ++ printJSON | idx 0 | parseValue b#{{}}
 ++ printJSON | idx 0 | parseValue b#{ { }}
 ++ printJSON | idx 0 | parseValue b#{ {"str":"x", "null":null}}


""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^
^-^ parseValue printJSON
^-^
^-^ Json
^-^ JNULL JTRUE JFALSE JSTR JNUM JVEC JMAP
^-^
