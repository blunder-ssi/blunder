### rex_parse <- parse

/+  prelude
/+  datatype
/+  types
/+  stew
/+  parse


;;; Types ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

# datatype Frag
* RUNE _:Str
* FORM _:Form
* LINE _:Bool _:Str

# datatype Form
* BEFO _:Str _:Form        ;;  +()()
* SHIN _:Str _:(Row Itmz)  ;;  ()()+()()
* SHIP _:Itmz              ;;  ()()

# datatype Item
* LEAF _:Leaf
* NEST _:Nest

# typedef Itmz (Row Item) ; never empty

# datatype Nest
* INFIX _:Str _:(Row | Row Form)
* PREFX _:Str _:(Row Form)
* WRAPD _:Form
* PAREN _:(Row Form)

# datatype CordType
* THICK=THICK
* THIN=THIN
* CURL=CURL

# datatype Leaf
* N=N _:Str
* C=C _:CordType _:Str


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

> Nat > Bit ;; TODO s/Nat/Char/
= (isRuneChar c)
| barHas c b#{$!#%&*+,-./:<=>?@\\^`|~}

> Nat > Bit
(isNameChar c)=((c == '_') || isAlphaNum c)

> Parser r Bar
rune=(**stringOf1 isRuneChar)

> Parser r Bar
name=(**stringOf1 isNameChar)

> Nat > Parser r Bar
= (cord quo)
| andThen (char quo)
| andThenLeft (stringOf1 (neq quo))
| char quo

;; TODO: support {{nesting}}
;; TODO: support \}escaping
> Parser r Bar
= curl
| andThen (char '{')
| andThenLeft (stringOf1 | neq '}') (char '}')

> Parser r (CordType, Bar)
= leaf
| choice (pmap x&(C THICK x) | cord {"})
| choice (pmap x&(C THIN  x) | cord {'})
| choice (pmap x&(C CURL  x) | curl)
         (pmap x&(N x)       | name)

!!= (SUCCESS (C THICK  b#foo)) | runParser leaf b#{"foo"}
!!= (SUCCESS (C THIN   b#foo)) | runParser leaf b#{'foo'}
!!= (SUCCESS (C CURL   b#foo)) | runParser leaf b#{{foo}}
!!= (SUCCESS (N b#foo))        | runParser leaf b#{foo}
!!= (EXPECTED b#more)          | runParser leaf b#{'foo}
