; Copyright 2023 The Plunder Authors
; Use of this source code is governed by a BSD-style license that can be
; found in the LICENSE file.

#### rex <- datatype

;;; TODO: #datacase should accept any three kids, the cases shouldn't
;;; be required to be an heir.

;;; TODO: #datacase should support **annotation on constructers to
;;; indicate that every constructor should be created as an
;;; "always-inline" law.

/+  boot
/+  datatype
/+  repl [lineRepl cogMap]


;;; Types ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

# record Line
| LN
* lineFil : Str
* lineNum : Nat
* lineBar : Bar

# record (Span a)
| SPAN
* spanLin : a
* spanOff : Nat
* spanEnd : Nat
* spanVal : a

# datatype NestType
* PAREN=PAREN
* BRACK=BRACK

# datatype (Lexi a)
* LRUNE=rune
* LWORD=word
* LWYTE=wyte
* LSEMI=semi
* LLINE=line multi:(List (Span ()))
* LTEXT=text
* LNEST=para ty:NestType xs:a
* LFAIL=fail
* LTERM=term

; type Lexeme = Span (Lexi (List Lexeme))
; type Elem   = Span (Lexi (List Clump))
; type Clump  = Span (List Elem)


;;; Basic Lexing + Nesting ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= (lexMany lexOne ln off ctx bar)
@ lexeme@[_ off end tok] (lexOne ln off ctx bar)
^ (lexeme :: _)
| if (tok == LTERM) NIL
| lexMany lexOne ln end ctx bar

= (lexNest lexMany lexOne ln typ ctx off bar)
@ ts  | lexMany lexOne ln (inc off) ctx bar
@ [_ _ end _] | listUnsafeLast ts
| (ln, off, end, **LNEST typ ts)

; ASCII is [0-9]..[A..Z]..[_]..[a-z]
> Char > Bit
= (wordy c)
&& (gte c {0}) (lte c {z})
|| (gte c {a}) (lte c {9}) (eql {_} c)
&& (gte c {A}) (lte c {Z})

> Set Char
= runeChars
| setFromRow
| barBytes
| b#{!#$%&*+,-./:<=>?@\^`|~'}

> Char > Bit
(runic c)=(setHas c runeChars)

> Bar > Nat > Nat > Nat
= (eatCurly bar o d)
| if isZero-d o
@ next (eatCurly bar inc-o)
# switch (barIdx o bar)
* 0    | o
* }_{_ | next inc-d
* }_}_ | next dec-d
* _    | next d

> Bar > Nat > Nat > Nat
= (eatCord bar o)
^ min (barLen bar) (inc _) ; return barLen if unterminated
| barElemIndexOff {"} inc-o bar

> Line > Nat > Char > Bar > Bar > Lexeme
= (lexUgly ln off bar)
@ start   | inc-off
@ delim   | barIdx start bar
@ lineStr | [ln off barLen-bar LLINE-NIL]
# switch delim
* 0   | lineStr
* { } | lineStr
* _   ^ [ln off _ LTEXT]
      ^ min (barLen bar) (inc _)     ; return barLen if unterminated
      | barElemIndexOff delim (inc start) bar

= (lexOne ln o ctx bar)
@ eat | barFindIndexOff
@ c   | barIdx o bar
# switch c
* }_(_       | lexNest lexMany lexOne ln PAREN {)} o bar
* }_[_       | lexNest lexMany lexOne ln BRACK {]} o bar
* }_}_       | lexUgly ln o bar
* }_{_       | (ln, o, eatCurly bar inc-o 1,      LTEXT)
* 0          | (ln, o, barLen bar,                LTERM)
* }_;_       | (ln, o, barLen bar,                LSEMI)
* }_"_       | (ln, o, eatCord bar o,             LTEXT)
* }_ _       | (ln, o, eat (neq 32)        o bar, LWYTE)
| if wordy-c | (ln, o, eat c&(not wordy-c) o bar, LWORD)
| if runic-c | (ln, o, eat c&(not runic-c) o bar, LRUNE)
| if ctx==c  | (ln, o, inc o,                     LTERM)
| else       | (ln, o, inc o,                     LFAIL)

(lexLine ln)=(lexMany lexOne ln 0 0 (**getLineBar ln))


;;; Merge Multi-Line Strings ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; TODO: {#datacase} should optimize the single-branch case to an if.

= (getLine tok fb k)
# datacase tok
* (LLINE extra) | **k extra
* _             | fb

> List Lexeme > List Lexeme
= (multiLine topLs)
: a@(SPAN aLin aOff aEnd aTok) ls < listCase topLs NIL
@ fb (a :: multiLine ls)
: b@(SPAN ____ bOff bEnd bTok) ls < listCase ls    fb
: aExtra < **getLine aTok fb
| if (bTok /= LTERM) fb
@ (onMatch newTok more)
    @ aTok | LLINE (setSpanVal () newTok :: aExtra)
    | multiLine (SPAN aLin aOff aEnd aTok)::more
: c@(SPAN _ cOff cEnd cTok) ls < listCase ls fb
# datacase cTok
* _       | fb
* LLINE-_ | ifNot (aOff==cOff) fb
          | onMatch c ls
* LWYTE   : d@(SPAN _ dOff dEnd dTok) ls < listCase ls fb
          : _ < **getLine dTok fb
          | ifNot (aOff==dOff) fb
          | onMatch d ls


;;; Clump Juxtaposed Tokens ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

> Row Elem > Clump
= (mkClump xs)
@ [lin off _   _] (fst xs)
@ [_   _   end _] (last xs)
| (**SPAN lin off end xs)

> (a -> b) > Lexi a > Lexi b
= (lexiMap f lexi)
# datacase lexi
* LNEST-t-xs | **LNEST t (f xs)
* _          | lexi

> Lexeme > Elem
= (lexemeToElem clump span@(SPAN l o e x))
| **SPAN l o e (lexiMap clump x)

> Set (Lexi a)
spaceToks=(setFromRow [LWYTE LSEMI LTERM])

> Lexi a > Bit
(lexiIsSpace tok)=(setHas tok spaceToks)

> Elem > Bit
(elemIsSpace elem)=(**lexiIsSpace (**getSpanVal elem))

> List Elem > Bit
= (isEndOfCluster ls)
: l ls < listCase ls FALSE
| or (elemIsSpace l)
| and (**getSpanVal l == LRUNE)
: l ls < listCase ls TRUE
| elemIsSpace l

> List Elem > List Elem > List Clump
= (clumpLoop acc remain)
: next more
    < listCase remain
        | if acc==NIL NIL
        | listSing mkClump-(listToRowRev acc)
| if (acc==NIL && elemIsSpace next)
    | clumpLoop acc more
| if (acc/=NIL && isEndOfCluster remain)
    | **CONS mkClump-(listToRowRev acc)
    | clumpLoop ~[] remain
| clumpLoop next::acc more

> List Lexeme > Row Clump
= (clump lexemes)
| listToRow
| clumpLoop ~[]
| listMap (lexemeToElem clump) lexemes


;;; Layout Engine (Understand Structure Implied by Indentation) ;;;;;;;;;;;;;;;;

# datatype Tree
* LEAF=leaf c:Clump
* NODE=node rune:Bar sons:(Row Tree) kids:(Maybe Tree)

# datatype (Frag a)
* WOLF=wolf rune:Bar x:a
* LAMB=lamb x:a

# record Item
| I rune:Bar items:(List Tree) heir:(Maybe Tree)

> Span a > Bar
= (spanBar s@(SPAN lin off end _))
| barSlice off (sub end off) (**getLineBar lin)

> Span (Lexi a) > Frag (Span | Lexi a)
= (spanFrag s@(SPAN lin off end val))
| if (val /= LRUNE) (**LAMB s)
| **WOLF (spanBar s) s

> Clump > (Nat, Frag Clump)
= (clumpFrag c@(SPAN _ off _ es))
@ lamb | (off, **LAMB c)
@ e    | fst es
| if (len es /= 1) lamb
# datacase spanFrag-e
* LAMB-_       | lamb
* WOLF-rune-_ ++ dec (add off | barLen rune)
              ++ **WOLF rune c

x=(LN {fil} 1 b#{ ++x})
a=(SPAN x 1 3 [(SPAN x 1 2 LRUNE) (SPAN x 2 3 LWORD)])
c=(SPAN x 1 3 [(SPAN x 1 3 LRUNE)])
d=(SPAN x 2 3 [(SPAN x 2 3 LRUNE)])


> Span a > Bar
= (spanBar s@(SPAN lin off end _))
| barSlice off (sub end off) (**getLineBar lin)

lol=(SPAN (LN {file} 1 b#{ lol }) 1 4 LWORD)
lus=(SPAN (LN {file} 1 b#{ + }) 1 2 LRUNE)

> Span (Lexi a) > Frag (Span | Lexi a)
= (spanFrag s@(SPAN lin off end val))
| if (val /= LRUNE) (**LAMB s)
| **WOLF (spanBar s) s

> Clump > (Nat, Frag Clump)
= (clumpFrag c@(SPAN _ off _ es))
@ lamb | (off, **LAMB c)
@ e    | fst es
| if (len es /= 1) lamb
# datacase spanFrag-e
* LAMB-_       | lamb
* WOLF-rune-_ ++ dec (add off | barLen rune)
              ++ **WOLF rune c

> Frag Clump > Tree
= (fTree frag)
# datacase frag
* (LAMB c)   | **LEAF c
* (WOLF b _) | **NODE b [] NONE

> Item > Tree
= (iTree item@(I t x k))
| if (isZero t) ({invalid item} item)
| **NODE t (listToRowRev x) k

> (Nat, Tree) > (Nat, Item) > (Nat, Item)
= (merge [rp r] [ip i@(I t cs mHeir)])
# datacase mHeir
* SOME-k
    | (ip, I t (k::cs) (SOME r))
* NONE
    | if (rp == ip) | ( ip, I t cs    SOME-r )
    | else          | ( ip, I t r::cs NONE   )

(pairMap f [x y])=[x (f y)]

> Nat > List (Nat, Item) > List (Nat, Item)
= (close pos stk)
: i more
    < listCase stk NIL
| if (gte pos | fst i) stk
: j k
    < listCase more
        | die {indent too small.  Bug in block splitter}
| close pos
    | (merge (pairMap iTree i) j :: k)

> List (Nat, Item) > (Nat, Frag Clump) > List (Nat, Item)
= (pushOnto stk (fragPos, frag))
@ stk@[i is] (close fragPos stk)
# datacase frag
* WOLF-r-_ | (fragPos, I r ~[] NONE)::stk
* LAMB-_   | (merge (fragPos, fTree frag) i)::is

> (Nat, Item) > List (Nat, Frag Clump) > List (Nat, Item)
(pushAll pf fs)=(listFoldl pushOnto ~[pf] fs)

> (Nat, Item) > (Nat, Item) > (Nat, Item)
(forceMerge a b)=(merge (pairMap iTree a) b)

> List (Nat, Frag Clump) > List Tree
= (layout frags)
: f@[pos frag] fs < listCase frags NIL
# datacase frag
* LAMB-_   | (fTree frag :: layout fs)
* WOLF-r-_ ^ listSing | iTree | snd | listFoldl1 forceMerge _
           | pushAll (pos, I r ~[] NONE) fs

# datatype Tree
* LEAF=leaf c:Clump
* NODE=node rune:Bar sons:(Row Tree) kids:(Maybe Tree)


;;; Splitting Blocks ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

# datatype LineCat
* CVOID=VOID
* CNOTE=NOTE
* COPEN=OPEN deep:Nat
* CQUOT=QUOT deep:Nat
* CSING=SING deep:Nat

# datatype BlockBuffer
* WOODS=WOODS
* TEXTY=TEXTY ls:(List (List Lexeme)) deep:Nat
* BLOCK=BLOCK ls:(List (List Lexeme)) deep:Nat

typedef#FilePath#Str

# record BlockState
| BS pax:FilePath lino:Nat bb:BlockBuffer

> List Lexeme > LineCat
= (lineCat lexemes)
: (SPAN _ lOff lEnd x) ls
    < listCase lexemes CVOID
# datacase x
* LTERM   | CVOID
* LSEMI   | CNOTE
* LLINE-_ | **CQUOT lOff
* LRUNE   : (**SPAN _ _ _ yTok) ys < listCase ls (**CSING lOff)
          # datacase yTok
          * LTERM | **COPEN (dec lEnd)
          * LWYTE | **COPEN (dec lEnd)
          * LSEMI | **COPEN (dec lEnd)
          * _     | **CSING lOff
* LWYTE   | lineCat ls
* _       | **CSING lOff

> BlockState
> Maybe (List Lexeme)
> (BlockState, (| List | List | List Lexeme))
= (blockStep bs@(BS fn lno st) mInp)
# datacase mInp
* NONE
    ^ (BS fn lno WOODS, _)
    # datacase st
    * WOODS        | ~[]
    * (TEXTY ls _) | ~[(listRev ls)]
    * (BLOCK ls _) | ~[(listRev ls)]
* SOME-l
    @ c       | lineCat l
    @ (x s o) | (BS fn (inc lno) s, o)
    @ (fb ls)
        @ (st2, out) (blockStep (BS fn lno WOODS) mInp)
        | (st2, (listRev ls :: out))
    # datacase st
    * WOODS
        # datacase c
        * (CQUOT d)   | x (**TEXTY ~[l] d) ~[]
        * (COPEN d)   | x (**BLOCK ~[l] d)   ~[]
        * CVOID       | x WOODS ~[]
        * CNOTE       | x WOODS ~[]
        * (CSING _)   | x WOODS ~[~[l]]
    * (TEXTY ls deep)
        # datacase c
        * (CQUOT d) | - ifNot d==deep fb-ls
                      - x (**TEXTY l::ls deep) ~[]
        * _         | fb ls
    * (BLOCK ls deep)
        # datacase c
        * CNOTE     | (x (**BLOCK l::ls deep) ~[])
        * (CQUOT d) | if (lth d deep) fb-ls | else (x (**BLOCK l::ls deep) ~[])
        * (COPEN d) | if (lth d deep) fb-ls | else (x (**BLOCK l::ls deep) ~[])
        * (CSING d) | if (lth d deep) fb-ls | else (x (**BLOCK l::ls deep) ~[])
        * _         | fb-ls

> BlockState > Maybe Bar > (BlockState, List (Nat, List Tree))
= (treeStep st@(BS fil num _) mInp)
@ er@(st2, out)
    | blockStep st
    | fmapMaybe mInp (byt & lexLine (**LN fil num byt))
@ treeOut
    ^ listMap _ out
    & blockLines
    @ blockLexes (listCat blockLines)
    @ [(SPAN (LN _ firstLineNumber _) _ _ _) _] blockLexes
   ++ firstLineNumber
   ++ ^ layout | listMap clumpFrag | listFromRow | clump _
      | multiLine | listCat blockLines
| (st2, treeOut)


> FilePath > BlockState
(blockState fn)=(**BS fn 1 WOODS)


;;; Policy ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

> (a, List a) > List a
(nonEmptyToList [x xs])=(**CONS x xs)

# datatype (SubLayout a)
* PREFX=PREFX rune:Bar more:(List | Frag a)
* INFIX=INFIX befo:(a, List a) rune:Bar more:(SubLayout a)
* SEQUE=SEQUE items:(List a)

> List (Frag a) > (Maybe (Bar, List (Frag a)), (List a))
= (lambs fs)
: f more < listCase fs (NONE, ~[])
# datacase f
* LAMB-x   | pairMap (CONS x) (lambs more)
* WOLF-r-_ | (**SOME [r more], ~[])

> List (Frag a) > SubLayout a
= (subLayout frags)
: f fs
    < listCase frags (**SEQUE ~[])
# datacase f
* WOLF-r-_ | **PREFX r fs
* LAMB-x   @ [rest hed] (lambs fs)
           # datacase rest
           * NONE             | **SEQUE x::hed
           * SOME-(ryn, more) | **INFIX [x hed] ryn (subLayout more)

> Rex > Rex > Rex
= (rexAddHeir rex c)
@ heir (rexHeir rex)
^ rexSetHeir _ rex
| if isZero-heir c
| rexAddHeir heir c

= (spanQuotedStr span)
| barNat
@ bar (spanBar span)
| if (barIdx 0 bar == }_}_)
    | barSlice 2 (sub (barLen bar) 3) bar
| else
    | barSlice 1 (sub (barLen bar) 2) bar

= (lineRex acc spans)
: span spans < listCase spans acc
@ str | barNat | barDrop 2 | spanBar span
| lineRex (LINE str acc) spans

> Row Clump > Row Clump
= (onlyLambs clumps)
^ catMaybes (map _ clumps)
& clump
@ (depth, frag) (clumpFrag clump)
# datacase frag
* LAMB-x | **SOME x
* _      | NONE

typedef#(NonEmpty a)#(a, List a)

> (Clump -> Rex) > NonEmpty Clump > Rex
= (paraSeq clumpRex all@[c cs])
| if ((all /= NIL) && (cs == NIL))
    | clumpRex c
| else
    ^ NEST {|} _ 0
    | listToRow (listMap clumpRex all)

(mkInfix rune acc)=(INFX (barNat rune) (listToRowRev acc) NONE)

> (Clump -> Rex) > Bar > List (Frag Clump)
= (paraPrefix clumpRex rune frags)
^ _ rune NIL frags
? (go rune acc frags)
: f fs
    < listCase frags
        | NEST (barNat rune) (listToRowRev acc) NONE
# datacase f
* WOLF-rx-_ | go rune (go rx NIL fs :: acc) ~[]
* LAMB-cl   | go rune (clumpRex cl  :: acc) fs

= (paraInfix parenPolicy clumpRex rune initial slay)
^ _ rune ~[initial] slay
? (go rune acc slay)
# datacase slay
* (SEQUE _)       | mkInfix rune (parenPolicy clumpRex slay :: acc)
* (PREFX r xs)    | mkInfix rune (paraPrefix clumpRex r xs :: acc)
* (INFIX es r xs)
@ rx (paraSeq clumpRex es)
| if r==rune | go rune rx::acc xs
| else       | go r ~[(mkInfix rune rx::acc)] xs

> (Clump -> Rex) > SubLayout Clump > Rex
= (parenPolicy clumpRex slay)
# datacase slay
* PREFX-r-xs    | paraPrefix clumpRex r xs
* INFIX-es-r-xs | paraInfix parenPolicy clumpRex r (paraSeq clumpRex es) xs
* SEQUE-xs      | paraSeq clumpRex xs

(spanStr e)=(barNat | spanBar e)

> Elem > Rex
= (elemRex clumpRex e@(SPAN ln off end l))
# datacase l
* LWORD      | WORD (spanStr e) 0
* LFAIL      | elemRex clumpRex (**SPAN ln off end LRUNE)
* LRUNE      | NEST (spanStr e) [] 0
* LTEXT      | TEXT (spanQuotedStr e) 0
* LLINE-ts   | lineRex 0 (listSnoc ts e)
* LNEST-t-xs # datacase t
             * BRACK | NEST {,} (map clumpRex | onlyLambs xs) 0
             * PAREN ^ parenPolicy clumpRex (subLayout _)
                     | listMap compose-snd-clumpFrag (listFromRow xs)
* _          | {elemRex case not handled challenge (impossible)}
             | l

> Any > (Elem, List Elem) > Rex
= (heirSeq clumpRex wut@[x xs])
| if (isZero wut) | die {heirSeq.what}
| listFoldl rexAddHeir (elemRex clumpRex x)
| listMap (elemRex clumpRex) xs

> Bar > List Rex > Rex
= (ifix rune acc)
| **SHUT (barNat rune) (listToRowRev acc) NONE

> Bar > List Rex > SubLayout Elem
= (eatInfix clumpRex tightPolicy rune acc slay)
# datacase slay
* SEQUE-_       | ifix rune (tightPolicy clumpRex slay :: acc)
* PREFX-_-_     | die {impossible: double tight rune}
* INFIX-es-r-xs ^ eatInfix clumpRex tightPolicy r _ xs
                | if r==rune | (heirSeq clumpRex es :: acc)
                | else       | ~[(ifix rune (heirSeq clumpRex es :: acc))]


> (Clump -> Rex) > SubLayout Elem > Rex
= (tightPolicy clumpRex slay)
# datacase slay
* PREFX-r-xs    | if (xs == 0) | NEST barNat-r [] 0
                | PREF barNat-r [tightPolicy-clumpRex-(subLayout xs)] 0
* INFIX-es-r-xs | eatInfix clumpRex tightPolicy r ~[heirSeq-clumpRex-es] xs
* SEQUE-xs      | die {impossible: empty tight sequence}
* SEQUE-[x xs]  | heirSeq clumpRex [x xs]

> Clump > Rex
= (clumpRex clump@(SPAN _ _ _ elems))
| tightPolicy clumpRex | subLayout | listMap spanFrag | listFromRow elems

= (treeRex t)
# datacase t
* LEAF-c     | clumpRex c
* NODE-r-s-h | OPEN (barNat r) (map treeRex s)
             | (datacase#h)(NONE*0)(SOME x * treeRex x)

> List Tree > Rex
= (treesRex trees)
: t ts < listCase trees (die {treesRex: empty block})
| if (ts == NIL) | treeRex t
| else           | treeRex (**NODE b#{|} (listToRow trees) NONE)

= (testRex input)
@ toks
    | listCat
    | listMap ([ln bar] & lexLine (**LN {file} ln bar))
    | listIndexed (barLinesList input)
@ toks | multiLine toks
@ clmp | clump toks
| treesRex
| layout (listMap clumpFrag | listFromRow clmp)

> Row Any > b > b
= (trkEachList xs k)
: x xs < listCase xs k
| trk x (trkEachList xs k)

(simpleCog f x)=(f x, simpleCog f)

; data MaybePair a b = NoPair | SomePair a b

> Cog (MaybePair Nat Rex) o > BlockState > Cog (Maybe Bar) (List o)
= (rexCog cog st mLine)
@ (st, output)
    | treeStep st mLine
@ (output, cog)
    ^ listFoldl _ (NIL, cog) output
    & ([acc cog] [lineNum trees])
    @ (out, cog) cog-(lineNum, treesRex trees)
    | (CONS out acc, cog)
@ (output, cog)
    | if (NONE /= mLine) (output, cog)
    @ (out, cog) cog-NONE
    | if (isZero out) (output, cog)
    | (CONS out output, cog)
++ listRev output
++ rexCog cog st

listMonoid=(NIL, listWeld)


;;; Main (Entry Point) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= main
| cogMap (outs & trkEachList outs b#{})
^ lineRepl listMonoid _ b#{}
^ rexCog _ (blockState {REPL})
| simpleCog-([lineNum rex] & rex)


;;; Exports ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

^-^
^-^ LRUNE LWORD LWYTE LSEMI LLINE LTEXT LNEST LFAIL LTERM
^-^ PAREN BRACK
^-^ SPAN
^-^ LAMB WOLF
^-^ LEAF NODE
^-^ BS
^-^ WOODS TEXTY BLOCK
^-^ PREFX INFIX SEQUE
^-^
^-^ rexAddHeir
^-^ spanQuotedStr
^-^ multiLine layout subLayout clump lambs treeStep
^-^ spanBar spanFrag clumpFrag elemRex clumpRex testRex
^-^
^-^ wordy runic
^-^ LN
^-^ lexLine
^-^ simpleCog rexCog listMonoid
^-^ blockState
^-^ main
^-^
