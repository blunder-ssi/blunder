; Copyright 2023 The Plunder Authors
; Use of this source code is governed by a BSD-style license that can be
; found in the LICENSE file.

### types <- datatype

/+ boot
/+ mutrec [bloodline]
/+ switch
/+ datatype


;;; Utilities ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; TODO: Move these into 13_exp (or wherever).

= (defC sig bodyExp)
| OPEN {#=} (sigE sig, bodyExp) 0

= (defKC key sig bodyExp)
| OPEN {#=} (natE key, sigE sig, bodyExp) 0

= (defKPC key props sig bodyExp)
| OPEN {#=} (natE key, cnsE props, sigE sig, bodyExp) 0



;;; Type Values ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; {SCHEME} is the constructor for a type.  (SCHEME 3 e) means
;;; (forall a b c. e).
;;;
;;; In Hindley-Milner, the forall can only occur on the outside of a type,
;;; so there is no forall in the actual TypeExp structure, only at the
;;; onset, in SCHEME.
;;;
;;; {TCON} and {TVAR} are the constructors for type-expressions.
;;;
;;; TVAR references a type-variable (by index).
;;;
;;; TCON references a abstract type by binding-key, along with 0-or-more
;;; type parameters.
;;;
;;; For example:
;;;
;;;     forall a. List (Either a a)
;;;
;;; Is represented as:
;;;
;;;      | SCHEME 1
;;;      | TCON getBinderKey#List
;;;      ,   | TCON getBinderKey#Either
;;;         ++ TVAR 0
;;;         ++ TVAR 0

(TCON key params)=[key params]
(TVAR key)=key

(SCHEME vars typ)=[vars typ]


;;; Type Expressions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; {TExp} is a syntactic type expression.  Type expressions are first
;;; parsed into this, then name-resolved, then compiled into the above
;;; structures.

# datatype TExp
* T_FUN a:TExp b:TExp
* T_REF nam:Str val:Type params:(Row TExp)
* T_VAR sym:Str
* T_TUP exps:(Row TExp)


;;; Parsing Types ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= schemeExpected
} Scheme signatures look like:
}
}     Any
}     (Fun a b)

= (parseSchemeSig rex err ok)
@ rune (rexRune rex)
| ifNot (rune == {|})
    : lawName < readSymbol rex err
    | ok lawName []
: names < readSignature rex err
| if (lth len 2)
    | err rex schemeExpected
@ lawName  (idx 0 names)
@ varNames (drop 1 names)
| if (len varNames /= setLen (setFromRow varNames))
    | err rex {type params must be unique}
| ok lawName varNames

;; {#abstype} is used to backfill things that were earlier in the
;; bootstrapping process than the type system, and things that are
;; built using PLAN primitives (instead of typed-sire constructucts).
;;
;; Pins, Functions, Rows, Tabs, etc.
;;
;; {#abstype} simply defines a new type with no operations, and
;; operations are backfilled retroactivly using {#backfill}.  This can
;; be abused to create bindings that don't match their declared types,
;; so don't do that.
;;
;; {#abstype} is also used internally by the versions of {#record},
;; and {#datatype} that are exported by this modules.

;; TODO: Check that the type name uses the TypeNamingConvention,
;; and that the type variables use the variableNamingConvention.
;;

= absExpected
} Expected something like one of these:
}
}     abstype#Any
}     abstype#(Fun a b)

; = ({#getTypeNames} st rex err ok)
; | ok st (cnsE (tabGet p %typeName))

= ({#abstype} st rex err ok)
@ sons@[_ sigRex] (rexSons rex)
@ rune (rexRune sigRex)
;
| if (len sons /= 2)
    | err rex absExpected
;
| if (rune == {|})
    : names < readSignature sigRex err
    | if (lth len 2)
        | err rex absExpected
    @ sym      (idx 0 names)
    @ numVars  (dec | len names)
    @ varNames (drop 1 names)
    | if (len varNames /= setLen (setFromRow varNames))
        | err rex {type params must be unique}
    : st key <- generateUniqueKey st
    | ok st
    | defKPC key #[typeName=sym] [sym]
    | cnsE (SCHEME numVars | TCON key (gen numVars TVAR))
;
: sym    <- readSymbol sigRex err
: st key <- generateUniqueKey st
| ok st
| defKPC key #[typeName=sym] [sym]
| cnsE (SCHEME 0 | TCON key [])

;;; This section redefines {#record} and {#datatype} to also generate
;;; a new opaque type.
;;;
;;; TODO This is jank af, break {#record} and {#abstype} into re-usable
;;; parser + code generated and use those here (instead of just manually
;;; expanding both macros and combining the result).

oldRecord=(.{#record})
oldDataType=(.{#datatype})

= ({#record} st rex err ok)
: st tCmd <- .{#abstype} st `(abstype#($(idx 1 | rexKids rex))) err
: st rCmd <- oldRecord st rex err
| ok st
` #* $tCmd
  #* $rCmd

= ({#datatype} st rex err ok)
: st tCmd <- .{#abstype} st `(abstype#($(idx 1 | rexKids rex))) err
: st dCmd <- oldDataType st rex err
| ok st
` #* $tCmd
  #* $dCmd


;;; Declare Basic Types ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

abstype#Type
abstype#Void
abstype#Any
abstype#Nat
abstype#Pad
abstype#(Pin a)
abstype#(Fun a b)
abstype#Bar
abstype#Bit
abstype#Str
abstype#Rex
abstype#(Read a)
abstype#(Read2 a b)
abstype#(Read3 a b c)
abstype#(Read4 a b c d)
abstype#(Tab k v)
abstype#(Set k)
abstype#(Row a)
abstype#(Opt a)
abstype#(List a)
abstype#(Either a b)

* # record Unit             | UNIT
* # record (Box a)          | BOX p:a
* # record (Pair a b)       | PAIR p:a q:b
* # record (Trip a b c)     | TRIP p:a q:b r:c
* # record (Quad a b c d)   | QUAD p:a q:b r:c s:d
* # record (Pent a b c d e) | PENT p:a q:b r:c s:d t:e

abstype#TyExp

= anyKey  | getKey#Any
= funKey  | getKey#Fun
= unitKey | getKey#Unit
= boxKey  | getKey#Box
= pairKey | getKey#Pair
= tripKey | getKey#Trip
= quadKey | getKey#Quad
= pentKey | getKey#Pent

!!= Any | SCHEME 0 (TCON anyKey [])
!!= Fun | SCHEME 2 (TCON funKey [0 1])

!!= getProp#(Any.typeName) {Any}
!!= getProp#(Nat.typeName) {Nat}
!!= getProp#(Fun.typeName) {Fun}

= (lookupOr env key fallback ok)
| ifNot (tabHas key env) fallback
| ok (tabGet env key)

= (showTypeTree ss vars x)
^ _ x
? (loop x@[con par])
| if isNat-x
    | varE (idx x vars)
@ nam (getPropByKey ss con {typeName})
| if (isZero nam)
    | die [{Is not a type} con]
| if (null par)
    | if (eql con unitKey) ``()
    | varE nam
@ kids (map loop par)
| if (eql con funKey)
    @ [x y] kids
    | if ({>} == rexRune y)
        @ ySons (rexSons y)
        | rexSetSons (rowCons x ySons) y
    | `($x > $y)
| if (eql con pairKey)
    @ [p q] kids | `($p , $q)
| if (eql con tripKey)
    @ [p q r] kids | `($p , $q , $r)
| if (eql con quadKey)
    @ [p q r s] kids | `($p , $q , $r , $s)
| if (eql con pentKey)
    @ [p q r s t] kids | `($p , $q , $r , $s , $t)
| else
    ^ NEST {|} _ 0
    | rowCons (varE nam) kids

= (showType ss scheme@[arity x])
| showTypeTree ss (gen arity | add {a}) x

= (readDefinedSymbol ss rex err ok)
: sym          < readSymbol rex err
: bindKey bind < getBind sym ss rex err
| ok sym bindKey (idx 1 bind)

= ({#printType} ss rex err ok)
@ kids (rexKids rex)
| if (len kids /= 2)
    | die {Usage: printType#Type}
: symbol key scheme
    < readDefinedSymbol ss (idx 1 kids) err
| trk
    | OPEN {=} [(varE symbol)]
    | showType ss scheme
| ok ss ``(#*)

= (tyApp name scheme params err ok)
@ [arity topTy] scheme
| if (arity /= len params)
    | err (varE name) {Bad arity in type application}
^ ok (_ topTy)
? (subst x@[con para])
| if isNat-x (idx x params)
| [con (map subst para)]

= (tupleType n)
# switch n
* 0 Unit
* 1 Box
* 2 Pair
* 3 Trip
* 4 Quad
* 5 Pent
* _ ({todo support bigger tuples: } n)

= (compileType vars tExp err ok)
^ : tree <- _ tExp
  | ok (SCHEME (len vars) tree)
? (go tExp ret)
# datacase tExp
* (T_FUN a b)
    : x <- go a
    : y <- go b
    : r <- tyApp {Fun} Fun [x y] err
    | ret r
* (T_REF nam scheme args)
    : params < rowTraverse go args
    : result < tyApp nam scheme params err
    | ret result
* (T_VAR sym)
    # datacase (elemIdx sym vars NONE SOME)
    * NONE     | err varE-sym {unbound type variable}
    * (SOME i) | ret (TVAR i)
* (T_TUP exps)
    : params < rowTraverse go exps
    @ scheme | tupleType (len exps)
    : result < tyApp {TUP} scheme params err
    | ret result


;;; Parsing ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Type :=
;;;
;;;     | TyCon
;;;     | tyVar
;;;     | (Row a)
;;;     | Row-a
;;;     | (Type > Type)
;;;     | (Type > Type > Type)
;;;     | (Type > Type > Type > ...)
;;;
;;;     | ()                       ;; UNIT=0
;;;     | (,)                      ;; UNIT=0
;;;     | ,a [a]                   ;; *FORBIDDEN* (looks like list type)
;;;     | (a, b)                   ;; Pair a b
;;;     | (a, b, c)                ;; Trip a b c
;;;     | ...

= annBindExpected
} Expected something like:
}
}     > Type
}     = Binding ...

= (separateAnnotation ss topRex err ok)
^ _ NONE topRex
? (loop acc rex)
| if (isZero rex)
    | err topRex annBindExpected
@ rune (rexRune rex)
| if ((rune == {=}) || (rune == {#=}))
    @ sons    (rexSons rex)
    @ kids    (rexKids rex)
    @ typeRex (bloodline | listRev acc)
    | if (len kids == 3)
        : key    < readKey (idx 0 kids) err
        | ok ss typeRex key rex
    | if (len kids == 2)
        : ss key <- generateUniqueKey ss
        @ newRex | rexSetSons (rowCons (natE key) sons) rex
        | ok ss typeRex key newRex
    | else
        | err rex {What is this nonsense = node?}
| if (rune /= {>})
    | err topRex annBindExpected
@ acc (rexSetHeir 0 rex)::acc
| loop acc (rexHeir rex)

!!=  ++ [8]
     ++ `` > Row Nat
           > Row Nat
     ++ 7
     ++ `` = 7 (id x) x
  ^ separateAnnotation [7] _ v2 v4
 `` > Row Nat
    > Row Nat
    = (id x) x

!!=  ++ [8]
     ++ `` > Row Nat > Row Nat
     ++ 7
     ++ `` = 7 (id x) x
  ^ separateAnnotation [7] _ v2 v4
 `` > Row Nat > Row Nat
    = (id x) x

!!=  ++ [7]
     ++ `` > Row Nat > Row Nat
     ++ 32
     ++ `` = 32 (id x) x
  ^ separateAnnotation [7] _ v2 v4
 `` > Row Nat > Row Nat
    = 32 (id x) x


= (isTypeAnn rex)
@ style (rexStyle rex)
| and (rexIsNode rex)
| and (rexRune rex == {>})
      (style == {OPEN})

= (foldr1 f xs)
| if (null xs)
    | {fold1} {empty row}
@ las (dec len-xs)
| foldr f (idx las xs) (take las xs)

(bigFun args)=(**foldr1 T_FUN args)

= (parseType_ parseTypeAnnotation ss rex err ok)
^ _ rex ok
? (loop rex ok)
| if (isTypeAnn rex)
    : annRes <- parseTypeAnnotation ss rex err
    | ok annRes
| if (rexIsSymbol rex)
    : sym < readSymbol rex err
    @ fst (mod sym 256)
    | if (isUpper fst)
        : bindKey bind <- getBind sym ss rex err
        | ok (T_REF sym (idx 1 bind) [])
    | else
        | ok (T_VAR sym)
@ rune (rexRune rex)
| if (isZero rune)
    | err rex {Expected symbol or rune}
# switch rune
* {|}
    @ kids (rexKids rex)
    @ head (idx 0 kids)
    @ para (drop 1 kids)
    @ nKid (len kids)
    | if (isZero nKid) ; UNIT
        | ok | T_TUP []
    : sym < readSymbol head err
    | ifNot (isUpper | mod sym 256)
        | err head {expected: TypeName}
    : bindKey bind <- getBind sym ss rex err
    : params < rowTraverse loop para
    | ok (T_REF sym (idx 1 bind) params)
* {>}
    : kidTypes < rowTraverse loop (rexKids rex)
    | ok (bigFun kidTypes)
* {->}
    : kidTypes < rowTraverse loop (rexKids rex)
    | ok (bigFun kidTypes)
* {,}
    : kidTypes < rowTraverse loop (rexKids rex)
    | if (len kidTypes == 1)
        | err rex {Write (Row x), not [x]}
    | ok (T_TUP kidTypes)
* _
    | err rex (strWeld {invalid type rune: } rune)

= (parseTypeAnnotation ss topRex err ok)
^ _ FALSE NIL topRex & l
                     @ ty (bigFun | listToRowReversed l)
                     | ok ty
? (loop fancy acc rex ret)
| if (isZero rex) (ret acc)
| ifNot (isTypeAnn rex) (err rex {bad annotation})
@ heir      | rexHeir rex
@ sons      | rexSons rex
@ numSons   | len sons
@ lastSonIx | dec numSons
@ lastSon   | idx lastSonIx sons
| if (fancy && not (isZero heir))
    | err rex {Don't try to get fancy}
| if ((numSons /= 0) && isTypeAnn lastSon)
    @ sons | take lastSonIx sons
    | if (any isTypeAnn sons)
        | err rex {bad annotation (don't be weird)}
    @ iRex | if (len sons == 1) (idx 0 sons) (NEST {|} sons 0)
    : item < parseType_ parseTypeAnnotation ss iRex err
    @ acc  | item::acc
    : acc  < loop TRUE acc lastSon
    : acc  < loop fancy acc heir
    | ret acc
@ sons (rexSons rex)
| if (any isTypeAnn sons)
    | err rex {bad annotation (don't be weird)}
@ iRex | if (len sons == 1) (idx 0 sons) (NEST {|} sons 0)
: item < parseType_ parseTypeAnnotation ss iRex err
@ acc | item::acc
| loop fancy acc heir ret

= (parseType ss rex err ok)
| parseType_ parseTypeAnnotation ss rex err ok

= (parseTypeAnnotatedBinding ss rex err ok)
: ss annRex bindKey bindRex < separateAnnotation ss rex err
: annTy                     < parseType ss annRex err
| ok ss annTy bindKey bindRex


;;; Macros ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; {#typedef} creates a named type based on a type-expression.

= ({#typedef} ss rex err ok)
@ kids                    | rexKids rex
@ [_typedef sigRex tyRex] | kids
;
| if (len kids /= 3)
    | err rex {Usage: # typedef Type (a > b)}
;
: sym vars < parseSchemeSig sigRex err
: expr     < parseType ss tyRex err
: scheme   < compileType vars expr err
: ss key   < generateUniqueKey ss
| ok ss
| defKPC key #[typeName=sym] [sym] (cnsE scheme)

typedef#Symbol#Nat
typedef#RexKey#Nat

typedef#(Key a)#Nat

# typedef NatOp2
    (Nat > Nat > Nat)

# typedef (Foo z)
    > z > List z > Nat > Nat

# typedef (Zaz a b c d)
    > Foo (a,b)
    > Foo (c,d)
    > (a,b,c,d)

printType#NatOp2
printType#Foo
printType#Zaz
printType#Quad
printType#Pent
printType#Unit
printType#Fun


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; {txpFree} returns the set of type variables used in a type-expression,
;; For example the set of type-variables in {Either a (b, List a)}
;; is {%[a b]}.

> TyExp > Set Symbol
= (txpFree x)
# datacase x
* (T_FUN a b)    | setUnion (txpFree a) (txpFree b)
* (T_REF _ _ xs) | setCatRow (map txpFree xs)
* (T_VAR sym)    | setSing sym
* (T_TUP xs)     | setCatRow (map txpFree xs)

;; {>} is the type-annotation rune.  It is prefixed directly onto the
;; same block as the definition it annotates
;;
;;     > Nat > Nat
;;     (add3 x)=(add 3 x)
;;
;; TODO: Support separate blocks for annotation and binding.
;;
;;     \ add3 : Nat > Nat
;;
;;     (add3 x)=(add 3 x)

= ({>} ss rex err ok)
: ss tExp bindKey binding
    < parseTypeAnnotatedBinding ss rex err
@ vars | setToRow (txpFree tExp)
: type < compileType vars tExp err
@ ss (addProps ss bindKey (tabSing {type} type))
    ;
    ; TODO: property, what property?
    ;
| ok ss binding

;; {#backfill} assigns a type to an existing binding without checking it.
;;
;; This is intended as a way to retroactively assign types to things
;; that we defined before the type system was built, and to give types
;; to things that are defined directly in terms of PLAN primitives.
;;
;; (At the moment, nothing is checked at all, so this isn't actually
;; different from `>`.  In the future it will be, though.

= backfillExpected
} Expected something like:
}
} # backfill main
} > Int > Ptr Ptr-Char > IO ()

= ({#backfill} ss rex err ok)
@ kids rexKids-rex
| if (3 /= len kids) (err rex backfillExpected)
@ [_ valRex typRex] kids
: sym valKey _ < readDefinedSymbol ss valRex err
: typExp       < parseType ss typRex err
@ tyVars       | setToRow (txpFree typExp)
: scheme       < compileType tyVars typExp err
@ ss (addProps ss valKey | tabSing {type} scheme)
| ok ss ``(#*)

;; {#typeof} prints the type of a binding.  It is meant to be used
;; interactively from the REPL.

= ({#typeof} ss rex err ok)
@ kids (rexKids rex)
| if (len kids /= 2) | die {Usage: typeof#var}
: symbol < readSymbol (idx 1 kids) err
: _ bind < getBind symbol ss rex err
@ scheme | getProp ss bind {type}
| if (isZero scheme) | {untyped} symbol
| trk (NEST {\} [(varE symbol)] | showType ss scheme)
| ok ss ``(#*)


;;; Exports ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

^-^
^-^ showType
^-^
^-^ {#typedef} {#abstype} {#printType} {#typeof} {#backfill}
^-^
^-^ {#record} {#datatype} {#datacase}
^-^
^-^ {>}
^-^
^-^ SCHEME TVAR TCON
^-^
^-^ Void Any Type
^-^ Nat Pin Fun
^-^ Bit Str
^-^ Rex Read
^-^ Row List Set Tab
^-^ Opt Either
^-^ Bar
^-^
^-^ Unit Box Pair Trip Quad
^-^
