; Copyright 2023 The Plunder Authors
; Use of this source code is governed by a BSD-style license that can be
; found in the LICENSE file.

#### types <- type_syntax

:| sire
:| type_syntax
:| mutrec [bloodline]


;;; Utilities ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; TODO: Move these into sire_13_exp (or wherever).

= (defC sig bodyExp)
| OPEN {#=} (sigE sig, bodyExp) 0

= (defKC key sig bodyExp)
| OPEN {#=} (natE key, sigE sig, bodyExp) 0

= (defKPC key props sig bodyExp)
| OPEN {#=} (natE key, cnsE props, sigE sig, bodyExp) 0



;;; Type Values ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; {FORALL} is the constructor for a type.  (FORALL 3 e) means
;;; (forall a b c. e).
;;;
;;; In Hindley-Milner, the forall can only occur on the outside of a type,
;;; so there is no forall in the actual TypeExp structure, only at the
;;; onset, in FORALL.
;;;
;;; {TCON} and {TVAR} are the constructors for type-expressions.
;;;
;;; TVAR references a type-variable (by index).
;;;
;;; TCON references a abstract type by binding-key, along with 0-or-more
;;; type parameters.
;;;
;;; For example:
;;;
;;;     forall a. List (Either a a)
;;;
;;; Is represented as:
;;;
;;;      | FORALL 1
;;;      | TCON getBinderKey#List
;;;      ,   | TCON getBinderKey#Either
;;;         ++ TVAR 0
;;;         ++ TVAR 0

> Nat > Row (TNode a) > TNode a
(TCON key params)=[key params]

> a > TNode a
(TVAR key)=key

# record Type
| FORALL vars:Nat typ:(TNode Nat)


;;; Type Expressions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; {TyExp} is a syntactic type expression.  Type expressions are first
;;; parsed into this, then name-resolved, then compiled into the above
;;; structures.


;;; Parsing Types ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= schemeExpected
} Scheme signatures look like:
}
}     Any
}     (Fun a b)

= (parseSchemeSig rex err ok)
@ rune (rexRune rex)
| ifNot (rune == {|})
    : lawName < readSymbol rex err
    | ok lawName []
: names < readSignature rex err
| if (lth len 2)
    | err rex schemeExpected
@ lawName  (idx 0 names)
@ varNames (drop 1 names)
| if (len varNames /= setLen (setFromRow varNames))
    | err rex {type params must be unique}
| ok lawName varNames

;; {#abstype} is used to backfill things that were earlier in the
;; bootstrapping process than the type system, and things that are
;; built using PLAN primitives (instead of typed-sire constructucts).
;;
;; Pins, Functions, Rows, Tabs, etc.
;;
;; {#abstype} simply defines a new type with no operations, and
;; operations are backfilled retroactivly using {#backfill}.  This can
;; be abused to create bindings that don't match their declared types,
;; so don't do that.
;;
;; {#abstype} is also used internally by the versions of {#record},
;; and {#datatype} that are exported by this modules.

;; TODO: Check that the type name uses the TypeNamingConvention,
;; and that the type variables use the variableNamingConvention.

= absExpected
} Expected something like one of these:
}
}     abstype#Any
}     abstype#(Fun a b)

; = ({#getTypeNames} st rex err ok)
; | ok st (cnsE (tabGet p %typeName))

= ({#abstype} st rex err ok)
@ sons@[_ sigRex] (rexSons rex)
@ rune (rexRune sigRex)
| if (len sons /= 2)
    | err rex absExpected
| if (rune == {|})
    : names < readSignature sigRex err
    | if (lth len 2)
        | err rex absExpected
    @ sym      (idx 0 names)
    @ numVars  (dec | len names)
    @ varNames (drop 1 names)
    | if (len varNames /= setLen (setFromRow varNames))
        | err rex {type params must be unique}
    : st key < generateUniqueKey st
    | ok st
    | defKPC key #[typeName=sym] [sym]
    | cnsE (FORALL numVars | TCON key (gen numVars TVAR))
: sym    < readSymbol sigRex err
: st key < generateUniqueKey st
| ok st
| defKPC key #[typeName=sym] [sym]
| cnsE (FORALL 0 | TCON key [])

;;; This section redefines {#record} and {#datatype} to also generate
;;; a new opaque type.
;;;
;;; TODO This is jank af, break {#record} and {#abstype} into re-usable
;;; parser + code generated and use those here (instead of just manually
;;; expanding both macros and combining the result).

oldRecord=(.{#record})
oldDataType=(.{#datatype})

= ({#record} st rex err ok)
: st tCmd < .{#abstype} st `(abstype#($(idx 1 | rexKids rex))) err
: st rCmd < oldRecord st rex err
| ok st
` #* $tCmd
  #* $rCmd

= ({#datatype} st rex err ok)
: st tCmd < .{#abstype} st `(abstype#($(idx 1 | rexKids rex))) err
: st dCmd < oldDataType st rex err
| ok st
` #* $tCmd
  #* $dCmd


;;; Declare Basic Types ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

abstype#Type
abstype#TNode
abstype#Void
abstype#Any
abstype#Nat
abstype#Pad
abstype#(Pin a)
abstype#(Fun a b)
abstype#Bar
abstype#BarTree
abstype#Bit
abstype#Char
abstype#Str
abstype#Ordering
abstype#Word8
abstype#Word16
abstype#Word32
abstype#Word48
abstype#Word64
abstype#Rex
abstype#(Read a)
abstype#(Read2 a b)
abstype#(Read3 a b c)
abstype#(Read4 a b c d)
abstype#(Tab k v)
abstype#(Set k)
abstype#(Row a)
abstype#(Maybe a)
abstype#(List a)
abstype#(Either a b)

* # record Unit                   | UNIT
* # record (Sing a)               | SING p:a
* # record (Pair a b)             | PAIR p:a q:b
* # record (Trip a b c)           | TRIP p:a q:b r:c
* # record (Quad a b c d)         | QUAD p:a q:b r:c s:d
* # record (Pent a b c d e)       | PENT p:a q:b r:c s:d t:e
* # record (Octo a b c d e f g h) | OCTO p:a q:b r:c s:d t:e u:f v:g w:h

# record (Row8 a)
| ROW8 _:a _:a _:a _:a _:a _:a _:a _:a

# record (Row16 a)
| ROW16 _:a _:a _:a _:a _:a _:a _:a _:a
        _:a _:a _:a _:a _:a _:a _:a _:a

abstype#TyExp

= anyKey  | getKey#Any
= funKey  | getKey#Fun
= natKey  | getKey#Nat
= bitKey  | getKey#Bit
= unitKey | getKey#Unit
= boxKey  | getKey#Sing
= pairKey | getKey#Pair
= tripKey | getKey#Trip
= quadKey | getKey#Quad
= pentKey | getKey#Pent

=?= Any | FORALL 0 (TCON anyKey [])
=?= Fun | FORALL 2 (TCON funKey [0 1])

=?= getProp#(Any.typeName) {Any}
=?= getProp#(Nat.typeName) {Nat}
=?= getProp#(Fun.typeName) {Fun}

= (lookupOr env key fallback ok)
| ifNot (tabHas key env) fallback
| ok (tabGet env key)

= (showTypeTree ss vars x)
^ _ x
? (loop x@[con par])
| if isNat-x
    | varE (idx x vars)
@ nam (getPropByKey ss con {typeName})
| if (isZero nam)
    | trk [=ss]
    | die [{Is not a type} con]
| if (null par)
    | if (eql con unitKey) '()
    | varE nam
@ kids (map loop par)
| if (eql con funKey)
    @ [x y] kids
    | if ({>} == rexRune y)
        @ ySons (rexSons y)
        | rexSetSons (rowCons x ySons) y
    | `($x > $y)
| if (eql con pairKey)
    @ [p q] kids | `($p , $q)
| if (eql con tripKey)
    @ [p q r] kids | `($p , $q , $r)
| if (eql con quadKey)
    @ [p q r s] kids | `($p , $q , $r , $s)
| if (eql con pentKey)
    @ [p q r s t] kids | `($p , $q , $r , $s , $t)
| else
    ^ NEST {|} _ 0
    | rowCons (varE nam) kids

= (showType ss scheme@[arity x])
| showTypeTree ss (gen arity | add {a}) x

= (readDefinedSymbol ss rex err ok)
: sym    < readSymbol rex err
: _ bind < getBind sym ss rex err
| ok sym bind

= ({#printType} ss rex err ok)
@ kids (rexKids rex)
| if (len kids /= 2)
    | die {Usage: printType#Type}
: symbol bind < readDefinedSymbol ss (idx 1 kids) err
@ scheme      | get bind 1
| trk
    | OPEN {=} [(varE symbol)]
    | showType ss scheme
| ok ss '(#*)

= (tyApp name scheme params err ok)
@ [arity topTy] scheme
| if (arity /= len params)
    | err (varE name) {Bad arity in type application}
^ ok (_ topTy)
? (subst x@[con para])
| if isNat-x (idx x params)
| [con (map subst para)]

= (tupleType n)
# switch n
* 0 | Unit
* 1 | Sing
* 2 | Pair
* 3 | Trip
* 4 | Quad
* 5 | Pent
* 8 | Octo
* _ | {todo support bigger tuples: } n

> SireState > Row Str > TyExp > Read Type
= (compileType ss vars tExp err ok)
^ : tree < _ tExp
  | ok (FORALL (len vars) tree)
? (go tExp ret)
| tyExpCase tExp
* ? (onVAR sym)
    # datacase (elemIdx sym vars NONE SOME)
    * NONE     | err varE-sym {unbound type variable}
    * (SOME i) | ret (TVAR i)
* ? (onTUP exps)
    : params < rowTraverse go exps
    @ scheme | tupleType (len exps)
    : result < tyApp {TUP} scheme params err
    | ret result
* ? (onFUN a b)
    : x < go a
    : y < go b
    : r < tyApp {Fun} Fun [x y] err
    | ret r
* ? (onREF cnstr args)
    : params < rowTraverse go args
    : _ bind < getBind cnstr ss (WORD cnstr 0) err
    @ scheme (idx 1 bind)
    | if isZero-scheme (die "no scheme??")
    : result < tyApp cnstr scheme params err
    | ret result


;;; Parsing ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Type :=
;;;
;;;     | TyCon
;;;     | tyVar
;;;     | (Row a)
;;;     | Row-a
;;;     | (Type > Type)
;;;     | (Type > Type > Type)
;;;     | (Type > Type > Type > ...)
;;;
;;;     | ()                       ;; UNIT=0
;;;     | (,)                      ;; UNIT=0
;;;     | ,a [a]                   ;; *FORBIDDEN* (looks like list type)
;;;     | (a, b)                   ;; Pair a b
;;;     | (a, b, c)                ;; Trip a b c
;;;     | ...

= annBindExpected
} Expected something like:
}
}     > Type
}     = Binding ...

= (separateAnnotation ss topRex err ok)
^ _ NONE topRex
? (loop acc rex)
| if (isZero rex)
    | err topRex annBindExpected
@ rune (rexRune rex)
| if ((rune == {=}) || (rune == {#=}))
    @ sons    (rexSons rex)
    @ kids    (rexKids rex)
    @ typeRex (bloodline | listRev acc)
    | if (len kids == 3)
        : key < readKey (idx 0 kids) err
        | ok ss typeRex key rex
    | if (len kids == 2)
        : ss key < generateUniqueKey ss
        @ newRex | rexSetSons (rowCons (natE key) sons) rex
        | ok ss typeRex key newRex
    | else
        | err rex {What is this nonsense = node?}
| if (rune /= {>})
    | err topRex annBindExpected
@ acc (rexSetHeir 0 rex)::acc
| loop acc (rexHeir rex)

=?=  ++ [8]
     ++ ' > Row Nat
          > Row Nat
     ++ 7
     ++ ' = 7 (id x) x
  ^ separateAnnotation [7] _ v2 v4
  ' > Row Nat
    > Row Nat
    = (id x) x

=?=  ++ [8]
     ++ ' > Row Nat > Row Nat
     ++ 7
     ++ ' = 7 (id x) x
  ^ separateAnnotation [7] _ v2 v4
  ' > Row Nat > Row Nat
    = (id x) x

=?=  ++ [7]
     ++ ' > Row Nat > Row Nat
     ++ 32
     ++ ' = 32 (id x) x
  ^ separateAnnotation [7] _ v2 v4
  ' > Row Nat > Row Nat
    = 32 (id x) x

= (parseTypeAnnotatedBinding ss rex err ok)
: ss annRex bindKey bindRex < separateAnnotation ss rex err
: annTy                     < parseType annRex err
| ok ss annTy bindKey bindRex


;;; Macros ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; {#typedef} creates a named type based on a type-expression.

= ({#typedef} ss rex err ok)
: @(TYPEDEF sym vars expr) < parseTypeDef rex err
: scheme   < compileType ss vars expr err
: ss key   < generateUniqueKey ss
| ok ss
| defKPC key #[typeName=sym] [sym] (cnsE scheme)

typedef#Symbol#Nat
typedef#RexKey#Nat

typedef#(Key a)#Nat

# typedef NatOp2
    (Nat > Nat > Nat)

# typedef (Foo z)
    > z > List z > Nat > Nat

# typedef (Zaz a b c d)
    > Foo (a,b)
    > Foo (c,d)
    > (a,b,c,d)

printType#NatOp2
printType#Foo
printType#Zaz
printType#Quad
printType#Pent
printType#Unit
printType#Fun


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; {txpFree} returns the set of type variables used in a type-expression,
;;; For example the set of type-variables in {Either a (b, List a)}
;;; is {%[a b]}.

> TyExp > Set Symbol
= (txpFree x)
| tyExpCase x
* ? (onVAR sym)  | setSing sym
* ? (onTUP xs)   | setCatRow (map txpFree xs)
* ? (onFUN a b)  | setUnion (txpFree a) (txpFree b)
* ? (onREF _ xs) | setCatRow (map txpFree xs)

;;; {>} is the type-annotation rune.  It is prefixed directly onto the
;;; same block as the definition it annotates
;;;
;;;     > Nat > Nat
;;;     (add3 x)=(add 3 x)
;;;
;;; TODO: Support separate blocks for annotation and binding.
;;;
;;;     \ add3 : Nat > Nat
;;;
;;;     add2:(Nat > Nat)
;;;
;;;     (add3 x)=(add 3 x)
;;;
;;;     (add2 x)=(add 2 x)
;;;

= ({>} ss rex err ok)
: ss tExp bindKey binding
    < parseTypeAnnotatedBinding ss rex err
@ vars | setToRow (txpFree tExp)
: type < compileType ss vars tExp err
@ ss (addPropsToLocalBindingByKey ss bindKey (tabSing {type} type))
| ok ss binding

;;;
;;; {#backfill} assigns a type to an existing binding without checking it.
;;;
;;; This is intended as a way to retroactively assign types to things
;;; that we defined before the type system was built, and to give types
;;; to things that are defined directly in terms of PLAN primitives.
;;;
;;; (At the moment, nothing is checked at all, so this isn't actually
;;; different from `>`.  In the future it will be, though.
;;;

= backfillExpected
} Expected something like:
}
} # backfill main
} > Int > Ptr (Ptr Char) > IO ()

= ({#backfill} ss rex err ok)
@ kids rexKids-rex
| if (3 /= len kids) (err rex backfillExpected)
@ [_ valRex typRex] kids
: sym bind < readDefinedSymbol ss valRex err
: typExp   < parseType typRex err
@ tyVars   | setToRow (txpFree typExp)
: scheme   < compileType ss tyVars typExp err
@ ss (addProps ss bind | tabSing {type} scheme)
| ok ss '(#*)

;;; {#typeof} prints the type of a binding.  It is meant to be used
;;; interactively from the REPL.

= ({#typeof} ss rex err ok)
@ kids (rexKids rex)
| if (len kids /= 2) | die {Usage: typeof#var}
: symbol < readSymbol (idx 1 kids) err
: _ bind < getBind symbol ss rex err
@ scheme | getProp ss bind {type}
| if (isZero scheme) | {untyped} symbol
| trk (NEST {\} ,(varE symbol) (showType ss scheme))
| ok ss '(#*)


;;; Backfill Types ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

* # backfill TRUE  Bit
* # backfill FALSE Bit
* # backfill bit   (a > Bit)
* # backfill not   (Bit > Bit)
* # backfill inc   (Nat > Nat)
* # backfill add   (Nat > Nat > Nat)


;;; Exports ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

^-^
^-^ TNode TCON TVAR
^-^ Type FORALL
^-^
^-^ showType parseType parseTypeAnnotatedBinding compileType
^-^ txpFree addPropsToLocalBindingByKey
^-^
^-^ {#typedef} {#abstype} {#printType} {#typeof} {#backfill}
^-^
^-^ {#record} {#datatype} {#datacase}
^-^
^-^ {>}
^-^
^-^ Void Any Type
^-^ Nat Pin Fun
^-^ Ordering
^-^ Bit Pad Char Str
^-^ Word8 Word16 Word32 Word48 Word64
^-^ Rex Read Read2 Read3 Read4
^-^ Row List Set Tab
^-^ Maybe Either
^-^ Bar BarTree
^-^
^-^ Unit Sing Pair Trip Quad Octo
^-^ Row8 Row16
^-^
