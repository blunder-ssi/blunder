;;; Copyright 2023 The Plunder Authors
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.

### datatype <- mutrec

/+  boot
/+  switch  ['#switch' switchE unrollSlip2Tar]

''' {#datatype} and {#datacase} work by setting some properties on the
''' binders for each constructor:  uses the properties conTag, conAri,
''' conFun, and conHas:
'''
''' -   conTag: The numerical tag for this branch.
''' -   conFun: The function used to get the tag from a instance.
''' -   conAri: The number of values on this branch.
''' -   conHas: Does this have a tag?  Should we offset our values
'''             indecies by one when getting fields?
'''
''' This design is at "get something running" levels of polish, and
''' will eventually need to be completely ripped apart, redesigned,
''' and rebuilt.
'''
''' Furthermore, the code generated by {#datacase} is currently
''' quite inferior to the code generated the utility functions
''' `maybeCase`, `listCase`, etc.  #datacase  currently outputs a
''' switch call in all cases.  Still unclear how best to resolve this
''' issues.


""" Getting that tag from an object """"""""""""""""""""""""""""""""""""""""""""

;;; TODO: Jet this and OP1 this.
(_DataTag x)=(if isNat-x x (idx 0 x))

dataTag=_DataTag

(0     !!= dataTag 0)
(1     !!= dataTag 1)
(2     !!= dataTag 2)
('foo' !!= dataTag 'foo')
('bar' !!= dataTag ['bar' 9])
(0     !!= dataTag [0 1 2 3])


""" Opening Records """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (constrToCamel prefix constr)
| strWeld prefix
| strFromList
^ _ ('_' :: strToList (strToLower constr))
? (fixUnderscores str)
: c cs <- listCase str str
: d ds <- listCase cs  str
| if (c /= '_') (c :: fixUnderscores cs)
| fixUnderscores (toUpper d :: ds)

!!= 'openPair'     | constrToCamel %open 'PAIR'
!!= 'mkTreeConfig' | constrToCamel %mk 'TREE_CONFIG'

= (defC sig bodyExp)
| OPEN 0 "=" (sigE sig, bodyExp) 0

= (defKC key sig bodyExp)
| OPEN 0 "=" (sigKE key sig, bodyExp) 0

> (Nat, Str) > Cmd
= (mkGetterC pair)
@ ix,field | pair
@ nam      | strWeld "get" (strCapitalize field)
| defC (nam, "x")
| appE (cnsE (idx ix), varE "x")

> (Nat, Str) > Cmd
= (mkSetterC pair)
@ ix,field | pair
@ nam      | strWeld "set" (strCapitalize field)
| defC [nam 'x' 'record']
| appE (cnsE (mut ix), varE 'x', varE 'record')

> (Str, Row Str) > Cmd
= (mkNamedC constr fields)
@ nam
        | strWeld "mk"
        | strCapitalize
        | strToLower constr
| defC [nam %t]
| appE
| rowCons (varE constr)
| turn fields (f & appE (cnsE (tabIdx f), varE "t"))

= (mkConstrC constr fields)
| defC (rowCons constr fields)
| rowE (map varE fields)

= (mkOpenerC constr fields)
@ nam
    (constrToCamel "#open" constr)
``
    = ($$(txtE nam) s p e a r err ok)
        : _ expr body
               <- $rexParseKids r $[readAny readAny readAny] err
        | ok p ($inc a)
        | $destructureRowE ($gensym a) $$(rowE | map txtE fields) expr body

!!= (mkOpenerC %pair [%fst %snd])
       ``
        = ('#openPair' s p e a r err ok)
            : _ expr body
               <- $rexParseKids r $[readAny readAny readAny] err
            | ok p ($inc a)
            | $destructureRowE ($gensym a) (#| $(cow 2) 'snd' 'fst') expr body

"""
""" This example:
"""
"""     record#(Pair a b)#(PAIR fst:a snd:b)
"""
""" Expands to:
"""
"""     = (PAIR fst snd) | [fst snd]
"""     = (getFst x)     | idx 0 x
"""     = (getSnd x)     | idx 1 x
"""     = (setFst v x)   | mut 0 v x
"""     = (setSnd v x)   | mut 1 v x
"""     = (mkPair t)     | PAIR (tabGet %fst t) (tabGet %snd t)
"""
""" This input format works too:
"""
"""     # record (Pair a b)
"""     | PAIR fst:a snd:b
"""
""" And also this:
"""
"""     # record (Pair a b)
"""     | PAIR
"""     * fst : a
"""     * snd : b

= sigExpect | "Expected `x` or signature `(x y z)`"

; = (readConstructorSig rex err ok)
; ^ traverseRow _ (rexSons rex) ok
; ? (step son ret)
; | readSymbol son err
; & sym
; | ret (rexIdnt son, sym)

fieldExpect="Expected something like (field:type)"

= (parseField rex err ret)
@ sKids (rexKids rex)
@ sRune (rexRune rex)
| ifNot (":" == sRune)   | err rex fieldExpect
| ifNot (2 == len-sKids) | err rex fieldExpect
: sym <- readSymbol (idx 0 sKids) err
@ typ (idx 1 sKids)
; Ignoring the type for now.
| ret (rexIdnt rex, sym, typ)

= (parseManyFields rexes err ret)
^ traverseRow _ rexes ret
& (rex ret)
| parseField rex err ret

  = fieldItemExpect
""" * field : type
""" * field : type

= (parseItemizedFields rex err ret)
^ _ NIL rex
? (go acc rex)
| if (isZero rex)
    | ret (listToRowReversed acc)
| ifNot (rexRune rex == '*')
    | err rex fieldItemExpect
@ sons    (rexSons rex)
@ numSons (len sons)
| if (numSons == 1)
    : field <- parseField (idx 0 sons) err
    | go (field :: acc) (rexHeir rex)
| ifNot (numSons == 2)
    | err rex fieldItemExpect
: sym   < readSymbol (idx 0 sons) err
@ typ   | idx 1 sons
@ field | (rexIdnt rex, sym, typ)
| go (field :: acc) (rexHeir rex)

> Rex > Parser (Nat, Symbol, Opt Nat)
= (readSymbolMaybeWithTag rex err ok)
| ifNot (rexIsNode rex)
    : sym < readSymbol rex err
    | ok (rexIdnt rex, sym, NONE)
;
@ kids@[symRex tagRex] (rexKids rex)
;
| if ((rexRune rex /= "=") || (len kids /= 2))
    | err rex "Expecting CONSTR or CONSTR=tag"
;
@ key | rexIdnt symRex
: sym < readSymbol symRex err
: tag < readKey tagRex err
| ok (key, sym, SOME tag)

""" {readConstructorSig} accepts inputs that look like one of the
""" following:
"""
"""     CNSTR
"""     (CNSTR (field:type)*)
"""     (CNSTR (* field : type)(* field : type)
"""     (|CNSTR)(* field : type)(* field : type)
"""
"""     CNSTR="tag"
"""     (CNSTR="tag" (field:type)*)
"""     (CNSTR="tag" (* field : type)(* field : type)
"""     (|CNSTR="tag")(* field : type)(* field : type)

> Rex > Parser (Nat, Symbol, Opt Nat, Row Symbol)
= (readConstructorSig r err ok)
;
| ifNot (rexIsNode r)
    : cnstr <- readSymbol r err
    | ok (rexIdnt r, cnstr, NONE, [])
;
@ rune | rexRune r
;
| if (rune == "=")
    : (cnstrId, cnstr, oTag) < readSymbolMaybeWithTag r err
    | ok (cnstrId, cnstr, oTag, [])
;
@ kids@[cnstrRex] | rexKids r
@ numKids         | len kids
;
| if ((rune /= "|") || isZero numKids)
    | err r sigExpect
;
: (cnstrId, cnstr, oTag)
    < readSymbolMaybeWithTag cnstrRex err
;
| if (eql 1 numKids)
    | ok (cnstrId, cnstr, oTag, [])
;
@ fields     | drop 1 kids
@ firstField | idx 0 fields
;
| if (eql 2 numKids && ("*" == rexRune firstField))
    : fields <- parseItemizedFields (idx 1 kids) err
    | ok (cnstrId, cnstr, oTag, fields)
: fields <- parseManyFields (drop 1 kids) err
| ok (cnstrId, cnstr, oTag, fields)

""" {readDatatypeSig} uses an inglorious short-term hack: it simply runs
""" the record-signature parser against a fudged input.

> Rex > Parser (Nat, Symbol, Opt Nat, Row Symbol)
= (readDatatypeSig node err ok)
@ rune (rexRune node)
| if (neq "*" rune)
    | err node "Expecting something like (* CNSTR field:type ...)"
^ readConstructorSig _ err ok
| rexSetRune "|" node

= (rexToTrip rex)
@ bad
    | die [%rexToTrip %badArgument rex]
: rune sons heir
   <- **rexGetNode rex bad
| if (neq 0 heir)
    | bad
| rowCons rune sons

; '#record'/Macro
= ('#record' s p e a r err ok)
@ kids    (rexKids r)
@ numKids (len kids)
;
; We ignore the first kid, because it's the type, which we don't yet
; actually do anything with.
;
@ sigRex (idx 2 kids)
: [key constr oTag fields]
    < readConstructorSig (idx 2 kids) err
;
| if (oTag /= NONE)
    | err sigRex "Record constructors are never tagged"
;
; trk [=key =constr =fields]
| ok p a
| if (isZero len-fields)
    | bloodline
    ; ^ trk [bloodline=_] _
   ~~ defC [constr] (natE 0)
   ~~ @ nam (| strWeld "mk" | strCapitalize | strToLower constr)
      | defC [nam '_'] (natE 0)
; ^ trk [bloodline=_] _
@ fields (map (idx 1) fields)  ;;  (Row (RexId, Symbol, Type)) -> Row Symbol
| bloodline
| listCat
~~ ~~ mkConstrC constr fields
~~ ~~ mkOpenerC constr fields
~~ ~~ mkNamedC constr fields
~~ listMap mkGetterC (listIndexed (listFromRow fields))
~~ listMap mkSetterC (listIndexed (listFromRow fields))

record#Unit#UNIT
record#(Box a)#(BOX boxItem:a)

# record (Pair a b)
| PAIR fst:a snd:b

ex=(PAIR %a %b)

!!= (getFst ex)    | %a
!!= (getSnd ex)    | %b
!!= (setFst %x ex) | PAIR %x %b
!!= (setSnd %x ex) | PAIR %a %x
!!= ex             | mkPair [fst="a" snd="b"]
!!= (BOX UNIT)     | BOX (mkUnit %[])
!!= 3              | openBox#(BOX 3)#boxItem
!!= 5              | openPair#(PAIR 2 3)#(add fst snd)


""" Datatypes """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

;;;
;;; # datatype (Either a b)
;;; * LEFT x:a
;;; * RYTE x:b
;;;
;;; # datatype (List a)
;;; * NULL
;;; * CONS x:a xs:(List a)
;;;


''' readDataBranches '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

; TODO: Validate that all tags are implicit or
; explicit and that all explicit tags are unique.

> Rex > Parser (Row (Nat, Symbol, Opt Nat, Row Symbol))
= (readDataBranches r err ok)
^ _ ~[] r
? (go acc r)
@ this | rexSetHeir 0 r
@ that | rexHeir r
: sig < readDatatypeSig this err
@ !acc sig::acc
| if (isZero that)
    | ok (listToRowReversed acc)
| else
    | go acc that


!!=  ,, [0 %FOO NONE [(0, 'x', `a)]]
     ,, [0 %BAR NONE [(0, 'x', `b) (0, 'y', `c) (0, 'z', `d)]]
     ,, [0 %LOL NONE []]
  ^ readDataBranches _ v2 id
  ` * FOO x:a
    * BAR x:b y:c z:d
    * LOL

!!=  ,, [0 %FOO (SOME %f) [(0, 'x', `a)]]
     ,, [0 %BAR (SOME %b) [(0, 'x', `b) (0, 'y', `c) (0, 'z', `d)]]
     ,, [0 %LOL (SOME %l) []]
  ^ readDataBranches _ v2 id
  ` * FOO=f x:a
    * BAR=b x:b y:c z:d
    * LOL=l


''' defDataTypeC '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

> RexSources
> RexProps
> Env
> Row (Key, Str, Opt Nat, Row Str)
> (RexProps, Cmd)
= (defDataTypeC src prp env branches)
;
; ^ trk [defDataTypeC=_] _
;
^ _ 0 prp NIL (listFromRow branches)
? (loop ix prp acc remain)
;
| seq ix
; trk %loop,[=ix =prp =acc =remain]
;
: kca remain <- **listCase remain (prp, bloodline acc)
@ [key cns oTag arg] kca
;
@ ari | len arg
@ tag | fromSome ix oTag
@ prp | setProperty key 'conTag' tag      prp
@ prp | setProperty key 'conAri' ari      prp
@ prp | setProperty key 'conFun' _DataTag prp
@ prp | setProperty key 'conHas' TRUE     prp ; hasTag
;
| if (isZero ari)
    @ bod | natE tag
    @ cmd | defKC key [cns] bod
    | loop (inc ix) prp (cmd :: acc) remain
| else
    @ arg (map idx-1 arg)
    @ bod (| rowE | rowCons natE-tag | map varE arg)
    @ cmd (defKC key (rowCons cns arg) bod)
    @ acc (CONS cmd acc)
    | loop (inc ix) prp acc remain


''' #datatype ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

= datatypeExpected
  """ Expected something like
  """
  """     # datatype Type
  """     * CONSTR
  """     * CONSTR field:type ...

> Macro
= ({#datatype} s p e a r err ok)
@ kids (rexKids r)
| if (len kids /= 3) (err r datatypeExpected)
: branches < readDataBranches (idx 2 kids) err
@ [prp rex] | defDataTypeC s p e branches
| ok prp a rex

# datatype (Either a b)
* E_LEFT x:a
* E_RIGHT x:b

!!= 0        | getProp#(E_LEFT.conTag)
!!= 1        | getProp#(E_LEFT.conAri)
!!= _DataTag | getProp#(E_LEFT.conFun)
!!= 1        | getProp#(E_RIGHT.conTag)
!!= 1        | getProp#(E_RIGHT.conAri)
!!= _DataTag | getProp#(E_RIGHT.conFun)

!! eql [0 9] | E_LEFT 9
!! eql [1 8] | E_RIGHT 8

# datatype (Choice a b)
* THIS=l x:a
* THAT=r x:b

!!= 'l'      | getProp#(THIS.conTag)
!!= 1        | getProp#(THIS.conAri)
!!= _DataTag | getProp#(THIS.conFun)
!!= 'r'      | getProp#(THAT.conTag)
!!= 1        | getProp#(THAT.conAri)
!!= _DataTag | getProp#(THAT.conFun)

!! eql [%l 9] | THIS 9
!! eql [%r 8] | THAT 8


''' parseDatacase ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

> (Rex -> Parser e)
> Rex
> Parser2 (Opt e) (Row (Rex, Symb, Row Pat, e))
= (parseDatacaseBody readExp cases err ok)
;;;;;
: clauses
    < ^ unrollSlip2Tar cases _ err
      ? (onAlien x err ret)
      | err x 'Not a switch branch'
;
^ _ NONE ~[] (listFromRow clauses)
? (go oFallback acc remain)
;
: [sigRex bodyRex] remain
    < **listCase remain
        | ok oFallback (listToRowReversed acc)
;
: bodyExp <- readExp bodyRex err
;
| if (rexEql `_ sigRex)
    | ifNot (isZero oFallback)
        | err cases "Only one fallback-pattern is allowed"
    | go (SOME bodyExp) acc remain
;
: constr fields
    < & k
      | if (rexIsLeaf sigRex)
          : sym < readKey sigRex err
          | k sym []
      | else
          : c fs < readDestroyer sigRex err
          | k c fs
;
@ acc [sigRex constr fields bodyExp]::acc
| go oFallback acc remain

> (Rex -> Parser e)
> Rex
> Parser3 e (Opt e) Row-(Rex, Symb, Row Pat, e)
= (parseDatacase readExp rex err ok)
@ sons@[_ valExp] | rexSons rex
@ heir            | rexHeir rex
;
| if (isZero heir || (len sons /= 2))
    | err rex '#datacase requires one son plus an heir.'
;
: exp      < readExp valExp err
: fb cases < parseDatacaseBody readExp heir err
| ok exp fb cases


''' readDatacaseBody '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

# record (DataCase p e)
| DATA_CASE
* tag    : Nat
* arity  : Nat
* fields : Row p
* body   : e

> Map Symbol Nat
> Properties
> Rex
> Parser4 Bit (a -> Nat) Rex (Row | DataCase Rex Rex)
;
= (readDatacaseBody src prp casesRex err ok)
;
: oFallback branches < parseDatacaseBody readAny casesRex err
@ fallback (fromSome (natE 0) oFallback)
;
^ _ FALSE 0 NIL (listFromRow branches)
? (go hasTag fun acc remain)
;
: hed@[sigRex constr fields bodyRex] remain
    < **listCase remain
        | ok hasTag fun fallback (listToRowReversed acc)
;
| ifNot (tabHas constr src)
    ^ err sigRex (strWeld _ constr)
    | "Undefined Pattern: "
;
@ key (tabGet src constr)
| if (isZero key)
    ^ err sigRex (strWeld _ constr)
    | "Pattern defined without identity: "
;
| ifNot (hasProperty key 'conTag' prp)
    ^ err sigRex (strWeld _ constr)
    | "Unknown constructor(tag): "
;
| ifNot (hasProperty key 'conAri' prp)
    ^ err sigRex (strWeld _ constr)
    | "Unknown constructor(ari): "
;
| ifNot (hasProperty key 'conFun' prp)
    ^ err sigRex (strWeld _ constr)
    | "Unknown constructor(fun): "
;
| ifNot (hasProperty key 'conHas' prp)
    ^ err sigRex (strWeld _ constr)
    | "Unknown constructor(has): "
;
@ tag    | getProperty key 'conTag' prp
@ ari    | getProperty key 'conAri' prp
@ fun    | getProperty key 'conFun' prp
@ hasTag | getProperty key 'conHas' prp
;
| if (len fields /= ari)
    ^ err sigRex (strWeld _ | showNat ari)
    | 'This constructor requires arity='
;
@ acc (DATA_CASE tag ari fields bodyRex)::acc
| go hasTag fun acc remain

!!=  ,, TRUE
     ,, dataTag
     ,, (natE 0)
     ,,  ,, [0 0 []                      `[x "]"]]
         ,, [1 2 [[%v 0 '_'] [%v 0 '_']] `[x " " (go xs)]]
  ^ _ v2 v4
  @ xpr `` * LNULL       [x "]"]
           * (LCONS _ _) [x " " (go xs)]
  @ src ## =LNULL 3
        ## =LCONS 4
  @ prp ## =conTag #[3=0 4=1]
        ## =conAri #[3=0 4=2]
        ## =conFun #[3=_DataTag 4=_DataTag]
        ## =conHas #[3=TRUE 4=TRUE]
  | readDatacaseBody src prp xpr

!!=  ,, TRUE
     ,, dataTag
     ,, `[x " " (go xs)]
     ,,  ,, [0 0 [] `[x "]"]]
  ^ _ v2 v4
  @ xpr `` * LNULL [x "]"]
           * _     [x " " (go xs)]
  @ src ## =LNULL 3
        ## =LCONS 4
  @ prp ## =conTag #[3=0 4=1]
        ## =conAri #[3=0 4=2]
        ## =conFun #[3=_DataTag 4=_DataTag]
        ## =conHas #[3=TRUE 4=TRUE]
  | readDatacaseBody src prp xpr

= xpr `` * _ 0
         * _ 0

!!=  ,, xpr
     ,, "Only one fallback-pattern is allowed"
  | readDatacaseBody %[] %[] xpr v2 v4


''' makeDatacaseExpr '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

= (makeDatacaseExpr hasTag fun aft valExp fallback cases return)
@ !tmpVar (gensym aft)
@ !tmpExp (varE tmpVar)
@ !aft (inc aft)
: aft pairs
    < forRowWithState aft cases
        & (aft [tag ari params body] continue)
        @ rowPat
            | if hasTag
            * (%r, rowCons [%v 0 '_'] params)
            * (%r, params)
        @ binds [(rowPat, valExp)]
        @ [aft bSeq deps] (sequenceBinds aft binds)
        | continue aft (tag, bindSeqE bSeq body deps)
@ tagExp (appE (cnsE fun, tmpExp))
@ result
    | OPEN 0 '@' [tmpExp valExp]
    | switchE tagExp fallback
    | tabFromPairs
    | pairs
| return aft result


''' #datacase ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

= ('#datacase' s p e a r err ok)
;;;
@ nex  | a
@ sons | rexSons r
@ heir | rexHeir r
;;;
| if (neq 2 (len sons))
        | err r '#datacase requires one son plus an heir.'
| if (isZero heir)
        | err r '#datacase requires one son plus an heir.'
;;;
@ [_ valExp] sons
: hasTag fun fb cases < readDatacaseBody s p heir err
: nex exp             < makeDatacaseExpr hasTag fun nex valExp fb cases
| ok p nex exp

# datatype (List a)
* LNULL
* LCONS x:a y:(List a)

= (showList xs)
| strWeld "["
^ _ xs
? (go xs)
# datacase xs
* LNULL
    | "]"
* (LCONS x xs)
    | strCat
    # datacase xs
    * LNULL       [x "]"]
    * (LCONS _ _) [x " " (go xs)]

!!= '[a b c]'
        | showList | LCONS %a | LCONS %b | LCONS %c LNULL

!!= 'hi' # datacase (LCONS 3 4)
         * LNULL 'bye'
         * _     'hi'

!!= 'hi' # datacase (LCONS 3 4)
         * LNULL 'byte'
         * _
         | 'hi'

; TODO
; !!= 'hi' # datacase (LCONS 3 4)
;          * LNULL 'bye'
;          | 'hi'


""" Backfills """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

zero=0
one=1
two=2


''' Bit ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

setProp#(TRUE.conTag)#one
setProp#(TRUE.conAri)#zero
setProp#(TRUE.conFun)#id
setProp#(TRUE.conHas)#FALSE

setProp#(FALSE.conTag)#zero
setProp#(FALSE.conAri)#zero
setProp#(FALSE.conFun)#id
setProp#(FALSE.conHas)#FALSE

!!= 'true'
  # datacase TRUE
  * TRUE  'true'
  * FALSE 'false'


''' Opt ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

setProp#(NONE.conTag)#zero
setProp#(NONE.conAri)#zero
setProp#(NONE.conFun)#len
setProp#(NONE.conHas)#FALSE

setProp#(SOME.conTag)#one
setProp#(SOME.conAri)#one
setProp#(SOME.conFun)#len
setProp#(SOME.conHas)#FALSE

!!= ['some' %x]
  # datacase (SOME %x)
  * NONE     | 'none'
  * (SOME x) | [{some} x]


''' List '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

setProp#(CONS.conTag)#two
setProp#(CONS.conAri)#two
setProp#(CONS.conFun)#len
setProp#(CONS.conHas)#FALSE

setProp#(NIL.conTag)#zero
setProp#(NIL.conAri)#zero
setProp#(NIL.conFun)#len
setProp#(NIL.conHas)#FALSE

!!= 'xyz abcd'
  ^ _ ~[{x} {y} {z } {abcd}]
  ? (strCatList lis)
  # datacase lis
  * NIL         | ''
  * (CONS x xs) | strWeld x (strCatList xs)


''' Either '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

idx0=(idx 0)

setProp#(LEFT.conTag)#zero
setProp#(LEFT.conAri)#one
setProp#(LEFT.conFun)#idx0
setProp#(LEFT.conHas)#TRUE

setProp#(RIGHT.conTag)#one
setProp#(RIGHT.conAri)#one
setProp#(RIGHT.conFun)#idx0
setProp#(RIGHT.conHas)#TRUE

= (showEither eat)
; trk [=eat]
# datacase eat
* (LEFT x)  ['left' x]
* (RIGHT x) ['right' x]

!!= [%left  %x] | showEither | LEFT  | {x}
!!= [%right %y] | showEither | RIGHT | {y}


""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^ defKC defC ;; TODO Move this elsewhere
^-^
^-^ _DataTag
^-^ dataTag
^-^ '#datacase' parseDatacase
^-^ '#datatype'
^-^ '#record'
