;;; Copyright 2023 The Plunder Authors
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.

### stew <- kern

/+  boot
/+  datatype
/+  switch
/+  datatype [parseDatacase]

"""
""" stew.sire
""" =========
"""
""" This is a parser, printer, and compiler for Stew, the "Steward Language".
""" Stew is an interim language between Sire and Heir.  Stew is built
""" using the Sire macro system but does not itself support further
""" macro-extension, instead using the traditional parse, type-check,
""" compiler flow.
"""
""" TODO: Kill io.sire
"""
""" TODO: Parse all built-in command runes:
"""
""" - [ ] !!=
""" - [ ] =
""" - [ ] *
""" - [ ] <
""" - [ ] ###
"""
""" TODO: Parse all macro-defined commands:
"""
""" - [ ] !!
""" - [x] #mutual
""" - [ ] #record
""" - [ ] #datatype
"""
""" DONE: Parse all built-in expression runes:
"""
""" - [x] |
""" - [x] @
""" - [x] @@
""" - [x] &
""" - [x] ?
""" - [x] ??
""" - [x] **
""" - [x] ^
"""
""" TODO: Parse all macro-defined expressions:
"""
""" - [x] #p
""" - [x] #b
""" - [x] #x
""" - [x] %
""" - [x] %%
""" - [x] #  (tabs)
""" - [x] ##
""" - [x] `` (recognize but reject, too complicated)
""" - [x] `
""" - [x] &&
""" - [x] ||
""" - [x] ==
""" - [x] /=
""" - [x] , (rows)
""" - [x] , (tabs)
""" - [x] ,,
""" - [ ] :
""" - [x] ~
""" - [x] ~~
""" - [x] ::
""" - [x] # (keywords)
""" - [x] #datacase
""" - [ ] #mutrec
""" - [ ] #switch
"""
""" TODO: Parse expressions that don't exist yet.
"""
""" - [ ] / ("has type")
"""
""" Parse other commands:
"""
""" - [ ] >
""" - [ ] \
""" - [ ] #abstype
""" - [ ] #backfill
""" - [ ] #typedef
""" - [ ] #typeof
""" - [ ] #printType
""" - [ ] #getenv
""" - [ ] #getKey
""" - [ ] #getProp
""" - [ ] #setProp
""" - [ ] #hasProp
""" - [ ] #getTypeNames
"""
""" TODO: Name resolution
"""
""" TODO: Macro that takes any stew expression and compiles it to sire.
"""
""" TODO: Redefine all runes to invoke TheBigStewMacro.
"""
""" TODO: Merge switch.sire and datatype.sire
""" TODO: Implement #openrecord (#datacase on records)
""" TODO: Merge (#switch / #openrecord / #datacase) into #case
""" TODO: #case supports multiple values.
""" TODO: #case supports recursive patterns.
""" TODO: Merge #record and #datatype into #data
"""

""" Types """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

# datatype Pat
* PVAR=v k:Key n:Sym
* PSEQ=s k:Key p:Sym
* PALI=a n:Sym p:Pat
* PROW=r x:(Row Pat)
* PTAB=t x:(Tab Any Pat)

# record ConCase
| CON_CASE con:Sym params:(Row Pat) body:Exp

# record Fun
| FUN self:Sym tag:Nat args:(Row Pat) body:Exp

# datatype Cmd
* CEXP=exp e:Exp
* CMUT=mut cs:(Row Cmd)  ;;  Mutually recursive

# datatype Exp
* EBED=cns b:Any
* EREF=ref r:Str
* ENAT=nat n:Nat
* EPAD=pad n:Pad
* EBAR=bar n:Bar
* ECAB=cab n:(Cab Any)
* EOR=or   x:Exp y:Exp
* EAND=and x:Exp y:Exp
* EAPP=app x:Exp y:Exp
* EKET=ket xs:(Row Exp) v:Exp
* ELET=let n:Pat x:Exp b:Exp
* EREC=rec n:Pat x:Exp b:Exp
* ELAM=lam pin:Bit fun:(Str, Nat, Row Pat, Exp)
* ELIN=lin x:Exp
* EROW=row xs:(Row Exp)
* EUNT=unt
* ETAB=tab xs:(Tab Nat Exp)
* ECAS=cas x:Exp fb:(Opt Exp) cs:(Row ConCase)
* EREX=rex r:Rex
* ECON=con x:Exp xs:Exp
* ENIL=nil
* EEQL=eql xs:(Row Exp)
* ENEQ=neq x:Exp y:Exp


""" Printing """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

> Any > Rex
= (showKey k)
| ifNot (isNat k)
    | todo {TODO: Support non-nat keys when printing tab patterns}
@ isKey
    | and (neq 0 k)
    | barAll isAlpha (natBar k)
| WORD 0 (if isKey k | showNat k) 0

!!= `a (showKey %a)
!!= `5 (showKey 5)
!!= `0 (showKey 0)

> (v > Rex) > Tab Any v > Rex
= (showTab showVal tab)
| if (tabIsEmpty tab) `(#[])
^ NEST 0 {,} (map _ tabToPairs-tab) 0
& [key val]
| SHUT 0 {=} (showKey key, showVal val) 0

= (showCab cab)
^ PREF 0 "%" [_] 0
^ NEST 0 "," _ 0
| map showKey (cabToRow cab)

> Pat > Rex
= (showPat p)
# datacase p
* (PVAR _k v) | varE v
* (PSEQ _k v) | PREF 0 {!} ,(varE v) 0
* (PALI x y)  | SHUT 0 {@} (showPat x, showPat y) 0
* (PROW xs)   | NEST 0 {,} (map showPat xs) 0
* (PTAB xs)   | showTab showPat xs

!!= (` #[])
  | showPat | PTAB #[]

!!= `[x=x y=(!y)]
  | showPat | PTAB [x=(PVAR 0 %x) y=(PSEQ 0 %y)]

!!= ` x@[a b@[c !d]]
  | showPat | PALI (PVAR 0 %x)
            | PROW ,, PVAR 0 %a
                   ,, PALI (PVAR 0 %b)
                        | PROW (PVAR 0 "c", PSEQ 0 "d")

> Row Rex > Rex
= (showSig rexes@[first])
| if (len rexes == 1) first
| NEST 0 {|} rexes 0

> (Exp > Rex) > Bit > Fun > Rex
= (showFun showSire pin (FUN self tag args body))
| if pin
    | todo 'show pinned lambdas'
| if (self /= tag)
    | todo 'show lambdas where name is different from tag'
@ selfRex  | varE self
@ argRexes | map showPat args
| if (isZero tag)
    | INFX 0 {&} (showSig argRexes, showSire body) 0
| else
    | INFX 0 {?} (showSig (rowCons selfRex argRexes), showSire body) 0

> Sym > Row Pat > Rex
= (showCon cn pts)
| if (null pts) (varE cn)
^ NEST 0 {|} _ 0
| rowCons (varE cn)
| map showPat pts

> (Exp > Rex) > Opt Exp > Row ConCase > Rex
= (showDatacases showSire f xs)
^ _ (listFromRow xs)
? (go xs)
: (cn,pts,b) xs
    < listCase xs
    # datacase f
    * NONE      | 0
    * (SOME fb) | ``(* _ $$(showSire fb))
@ rest (go xs)
| ``((* $$(showCon cn pts) $$(showSire b))($$rest))

= (niceApp showSire e)
^ _ e ~[]
? (loop e acc)
# datacase e
* (EAPP f x) | loop f (showSire x)::acc
* _          | NEST 0 {|} (listToRow (showSire e)::acc) 0

= (showCase showSire x f cs)
| NEST 0 {#} (varE 'datacase', showSire x)
| showDatacases showSire f cs

> Exp > Rex
= (showSire exp)
@ go showSire
# datacase exp
* (EBED x)       | EMBD x
* (EREF x)       | WORD 0 x 0
* (ENAT n)       | WORD 0 showNat-n 0
* (EPAD p)       | showPadLit p
* (EBAR b)       | showBarLit b
* (ECAB ks)      | showCab ks
* (EOR x y)      | INFX 0 {||} (showSire x, showSire y) 0
* (EAND x y)     | INFX 0 {&&} (showSire x, showSire y) 0
* (EAPP x y)     | niceApp go exp
* (EKET xs v)    | NEST 0 {^} (map go xs) (go v)
* (ELET n x b)   | INFX 0 {@}  (showPat n, go x) (go b)
* (EREC n x b)   | INFX 0 {@@} (showPat n, go x) (go b)
* (ELAM pin fun) | showFun go pin fun
* (ELIN x)       | PREF 0 {**} ,(showSire x) 0
* (EROW xs)      | NEST 0 {,} (map go xs) 0
* (ETAB xs)      | showTab showSire xs
* EUNT           | `()
* (ECAS x f cs)  | showCase go x f cs
* (EREX r)       | NEST 0 "`" [r] 0
* (ECON x xs)    | INFX 0 "::" (showSire x, showSire xs) 0
* ENIL           | `(~[])
* (EEQL xs)      | INFX 0 "==" (map showSire xs) 0
* (ENEQ x y)     | INFX 0 "/=" (showSire x, showSire y) 0
* _              | {showSire: Unknown syntax} exp

!!= ` (n @ 6516329)(fanc @ **mkLaw n a b)(0 p#{111} b#{asdf} (2 fanc))
  | showSire
  | ELET (PVAR 0 "n") (ENAT %inc)
  | ELET (PVAR 0 "fanc")
      | foldl EAPP (ELIN | EREF %mkLaw)
     ,, EREF %n
     ,, EREF %a
     ,, EREF %b
  | EAPP
      | EAPP
          | EAPP (ENAT 0) (EPAD p#111)
      | EBAR b#asdf
  | EAPP (ENAT 2)
  | EREF %fanc

!!= ` [%[0 a b] %[0] %[]]
  | showSire
  | EROW (map ECAB [%[0 a b] %[0] %[]])

!!= ` [#[] [a=3] [us=[() ()]]]
  | showSire
  | EROW (map ETAB [#[] [a=(ENAT 3)] [us=(EROW [EUNT EUNT])]])

!!= ` (x y & x)
  | showSire
  | ELAM FALSE
  | FUN 0 0 (PVAR 0 %x, PVAR 0 %y) (EREF %x)

!!= ` (const x y ? x)
  | showSire
  | ELAM FALSE
  | FUN "const" "const" (PVAR 0 %x, PVAR 0 %y) (EREF %x)

!!= ` (^ f _ y)x
  | showSire
  | EKET (EREF %f, EREF %_, EREF %y)
  | EREF %x


""" Parsing """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseLet readExp rex err ok)
@ kids@[patRex expRex bodRex] (rexKids rex)
| if (len kids /= 3) (err rex 'Bad let')
: var < parseBinder patRex err
: exp < readExp expRex err
: bod < readExp bodRex err
| ok (ELET var exp bod)

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseRec readExp rex err ok)
: e <- parseLet readExp rex err
# datacase e
* (ELET v e b) | ok | EREC v e b

> (Rex > Parser Exp) > Rex > Parser Rex
= (parseCen rex err ok)
: eRes <- readCenLit rex err
# datacase eRes
* (LEFT val)  | ok (ENAT val)
* (RIGHT cab) | ok (ECAB cab)

> (Rex > Parser Exp) > Rex > Parser Rex
= (parseCenCen rex err ok)
: cab <- readTallCab rex err
| ok (ECAB cab)

= (parseOrExp readExp rex err ok)
: tree <- readInfixRight readExp "||" rex err
| ok (binTreeFold EOR tree)

= (parseAndExp readExp rex err ok)
: tree <- readInfixRight readExp "&&" rex err
| ok (binTreeFold EAND tree)

= (readHaxOutline rex err ok)
@ kids@[keywordRex] | rexKids rex
@ params            | drop 1 kids
| if (null kids)
    | err rex '# with no parameter'
: sym <- readSymbol keywordRex err
| ok keywordRex sym params

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseHaxExp readExp rex err ok)
: symRex sym params <- readHaxOutline rex err
# switch sym
* _   | err symRex 'Unknown # keyword'
* {p} | readPadLit rex err (pad & ok (EPAD pad))
* {b} | readBarLit rex err (pad & ok (EBAR pad))
* {x} | readBarLit rex err (pad & ok (EBAR pad))
* {datacase}
    : val fb cases < parseDatacase readExp rex err
    | ok ^ ECAS val fb (map _ cases)
         & [_ constr pats body]
         | CON_CASE constr pats body

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseSig readExp rex err ok)
: items <- readWideListLit readExp rex err
| ok (listFoldr ECON ENIL items)

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseSigSig readExp rex err ok)
: items <- readTallListLit readExp rex err
| ok (listFoldr ECON ENIL items)

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseColCol readExp rex err ok)
: tree <- readInfixRight readExp "::" rex err
| ok (binTreeFold ECON tree)

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseTisTis readExp rex err ok)
: items <- readEqlExp readExp rex err
| ok (EEQL items)

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseFasTis readExp rex err ok)
: x y <- readNotEqlExp readExp rex err
| ok (ENEQ x y)

> (Rex > Parser Exp) > Rex > Parser Rex
= (parseHaxHax readExp rex err ok)
: tab <- readTallTabLit readExp rex err
| ok (ETAB tab)

= (parseTik rex err ok)
@ kids (rexKids rex)
| ifNot (eql 1 | len kids)
    | err rex {Expected something like `(rex)}
| EREX (idx 0 kids)

= (readApp readExp rex err ok)
: exps <- readFancyApp readExp rex err
| ok
| if (null exps) EUNT
| foldl EAPP (idx 0 exps) (drop 1 exps)

= (readKet readExp rex err ok)
@ sons (rexSons rex)
@ heir (rexHeir rex)
| if (null sons && isZero heir)
    | err rex "Bad ^ must be:  (^ f _ y)x"
: exp <- traverseRow (x k & readExp x err k) sons
: cab <- readExp heir err
| ok | EKET exp cab

= (readPam readExp rex err ok)
@ kids (rexKids rex)
| if (len kids /= 2) (err rex 'Bad lambda')
@ [sigRex bodRex] kids
: pats <- readBindSig sigRex err
: body <- readExp bodRex err
| ok | ELAM FALSE | FUN 0 0 pats body

= (readWut readExp pinned rex err ok)
@ kids@[sigRex bodRex] (rexKids rex)
| if (len kids /= 2) (err rex 'Bad lambda.')
: func pats <- readDestroyer sigRex err
: body <- readExp bodRex err
| ok (ELAM pinned | FUN func func pats body)

= (readLin readExp rex err ok)
@ kids@[expRex]
    | rexKids rex
| if (len kids /= 1)
    | err rex "Expected something like: **x"
: exp <- readExp expRex err
| ok (ELIN exp)

= (readCom readExp rex err ok)
@ rune (rexRune rex)
@ kids (rexKids rex)
| if (and (not null-kids) (eql "=" (rexRune fst-kids)))
    : tab <- readWideTabLit readExp rex err
    | ok (ETAB tab)
| else
    : exps <- traverseRow (x k & readExp x err k) kids
    | ok (EROW exps)

= (readComCom readExp rex err ok)
: items < readOpenRow readExp rex err
| ok (EROW items)

= (readLeaf rex err ok)
@ txt (rexText rex)
# switch (rexStyle rex)
* CORD ok-(ENAT txt)
* TAPE ok-(ENAT txt)
* LINE ok-(ENAT txt)
* PAGE ok-(ENAT txt)
* CURL ok-(ENAT txt)
* WORD
; TODO: Parse nat literals
| ok (EREF txt)

> Rex > Parser Exp
= (readExp rex err ok)
# switch (rexType rex)
* "EMBD" | ok EBED-(rexGetEmbd rex)
* "LEAF" | readLeaf rex err ok
* "NODE"
# switch (rexRune rex)
* {^}   | readKet readExp rex err ok
* {|}   | readApp readExp rex err ok
* {&}   | readPam readExp rex err ok
* {?}   | readWut readExp FALSE rex err ok
* {??}  | readWut readExp TRUE rex err ok
* {**}  | readLin readExp rex err ok
* {,}   | readCom readExp rex err ok
* {,,}  | readComCom readExp rex err ok
* {@}   | parseLet readExp rex err ok
* {@@}  | parseRec readExp rex err ok
* {#}   | parseHaxExp readExp rex err ok
* {##}  | parseHaxHax readExp rex err ok
* {~}   | parseSig readExp rex err ok
* {~~}  | parseSigSig readExp rex err ok
* {::}  | parseColCol readExp rex err ok
* {==}  | parseTisTis readExp rex err ok
* {/=}  | parseFasTis readExp rex err ok
* {`}   | parseTik rex err ok
* {``}  | err rex "Stew doesn't yet support the `` rune."
* {%}   | parseCen rex err ok
* {%%}  | parseCenCen rex err ok
* {&&}  | parseAndExp readExp rex err ok
* {||}  | parseOrExp readExp rex err ok
* _     | err rex (strWeld 'Unknown Rune')

> (Rex > Parser Cmd) > (Rex > Parser Exp) > Rex > Parser Cmd
= (readHaxCmd readCmd rex err ok)
: symRex sym params <- readHaxOutline rex err
# switch sym
* {mutual}
    : cmds <- traverseRow (flip readCmd err) params
    | ok (CMUT cmds)
* _
    : exp <- parseHaxExp readExp err
    | ok (CEXP exp)

> (Rex > Parser Cmd) > (Rex > Parser Exp) > Rex > Parser Cmd
= (readCmd rex err ok)
# switch (rexRune rex)
* _
    : exp <- readExp rex err
    | ok (CEXP exp)
* {#}
    | readHaxCmd readCmd rex err

; Assumes that the input formatting matches the printers formatting.
= (sireRound rex)
@ out (readExp rex v2 showSire)
| if (rexEql rex out) 1
| out

!! sireRound ` x
!! sireRound ` 0
!! sireRound ` (f x y)
!! sireRound ` (**f x y)
!! sireRound ` [p#{101} p#{}]
!! sireRound ` (x & x)
!! sireRound ` (x y & x)
!! sireRound ` (id x ? x)
!! sireRound ` (const x y ? x)
!! sireRound ` (x @ 3)(x x x)
!! sireRound ` (x @@ 3)x
!! sireRound ` (^ f _ y)x
!! sireRound ` (x @ [1 2])[x x]
!! sireRound ` ([x y] @ [1 2])[y x]
!! sireRound ` (z@[!x y] @ [1 2])(x y z)

!!= ` (span f r ? (l @ len r)(^ _ 0)(loop i ? if (eql i l) (v2 r v0) (if (f (idx i r)) (loop (inc i)) (v2 (take i r) (drop i r)))))
  ^ readExp _ v2 showSire
  ` ? (span f r)
    @ l | len r
    ^ _ 0
    ? (loop i)
    | if (eql i l) (v2 r v0)
    | if (f (idx i r))
        | loop (inc i)
    (v2 (take i r) (drop i r))

!!= `[x=3 y=4]
  ^ readExp _ v2 showSire
  ` ## =x 3
    ## =y 4

!!= `[3 (0 1)]
  ^ readExp _ v2 showSire
  ` ,, 3
    ,, 0 1

!!= `[3 (0 1)]
  ^ readExp _ v2 showSire
  ` ,, 3
     | 0 1

!!= `((# datacase a)(* NONE 0)(* (SOME x) x))
  ^ readExp _ v2 showSire
  ` # datacase a
    * NONE     0
    * (SOME x) x

!!= ` %[0 1 2 a b c]
  ^ readExp _ v2 showSire
  ` %% a b c
    %% 0 1 2

!!= ` (3 :: (4 :: (5 :: ~[])))
  ^ readExp _ v2 showSire
  ` ~[3 4 5]

!!= ` (3 :: (4 :: (5 :: ~[])))
  ^ readExp _ v2 showSire
  ` ~~ 3
    ~~ 4
     5

!!= ` (3 :: (4 :: (5 :: 6)))
  ^ readExp _ v2 showSire
  ` (3 :: 4 :: 5 :: 6)

!!= ` (3 :: (4 :: (5 :: 6)))
  ^ readExp _ v2 showSire
  ` :: 3 4
    :: 5
    :: 6

!!= ` (3 == 4 == 5)
  ^ readExp _ v2 showSire
  ` (3 == 4 == 5)

!!= ` (3 /= 4)
  ^ readExp _ v2 showSire
  ` (3 /= 4)

!!= ` (1 && (2 && 3))
  ^ readExp _ v2 showSire
  ` (1 && 2 && 3)

!!= ` (1 || (2 || 3))
  ^ readExp _ v2 showSire
  ` (1 || 2 || 3)

!!= `((# datacase a)(* NONE 0)(* _ 1))
  ^ readExp _ v2 showSire
  ` # datacase a
    * NONE     0
    * _        1

!!= `(add (inc 2) (inc 3))
  ^ readExp _ v2 showSire
  ` | add
    * inc 2
    * inc 3


""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^ EBED EREF ENAT EAPP EKET ELET EREC ELAM ELIN ECAS
^-^
^-^ readExp showSire
