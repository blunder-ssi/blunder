;;; Copyright 2023 The Plunder Authors
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.

### stew <- kern

/+  boot
/+  datatype
/+  switch
/+  datatype [parseDatacase]
/+  mutrec   [readMutRecExp]

"""
""" stew.sire
""" =========
"""
""" This is a parser, printer, and compiler for Stew, the "Steward Language".
""" Stew is an interim language between Sire and Heir.  Stew is built
""" using the Sire macro system but does not itself support further
""" macro-extension, instead using the traditional parse, type-check,
""" compiler flow.
"""
""" TODO: Kill io.sire
"""
""" TODO: Parse all built-in command runes:
"""
""" - [ ] !!=
""" - [ ] =
""" - [ ] *
""" - [ ] <
""" - [ ] ###
"""
""" TODO: Parse all macro-defined commands:
"""
""" - [ ] !!
""" - [x] #mutual
""" - [ ] #record
""" - [ ] #datatype
"""
""" TODO: Parse all leaf-expressions:
"""
""" - [x] parse decimal literals
""" - [x] parse hex literals
""" - [x] identifiers (rejecting malformed ones)
"""
""" DONE: Parse all built-in expression runes:
"""
""" - [x] | -
""" - [x] @
""" - [x] @@
""" - [x] &
""" - [x] ?
""" - [x] ??
""" - [x] **
""" - [x] ^
"""
""" TODO: Parse all macro-defined expressions:
"""
""" - [x] #p
""" - [x] #b
""" - [x] #x
""" - [x] %
""" - [x] %%
""" - [x] #  (tabs)
""" - [x] ##
""" - [x] `` (recognize but reject, too complicated)
""" - [x] `
""" - [x] &&
""" - [x] ||
""" - [x] ==
""" - [x] /=
""" - [x] , (rows)
""" - [x] , (tabs)
""" - [x] ++
""" - [x] :
""" - [x] ~
""" - [x] ~~
""" - [x] ::
""" - [x] # (keywords)
""" - [x] #datacase
""" - [x] #mutrec
""" - [x] #switch
""" - [ ] . (non-symbolic references)
""" - [ ] Correctly print non-symbol references.
""" - [ ] Fix inline annotations on function literals.
""" - [ ] Make sure function literals support all details.
"""
""" TODO: Parse expressions that don't exist yet.
"""
""" - [ ] / ("has type")
"""
""" Parse other commands:
"""
""" - [ ] >
""" - [ ] \
""" - [ ] #abstype
""" - [ ] #backfill
""" - [ ] #typedef
""" - [ ] #typeof
""" - [ ] #printType
""" - [ ] #getenv
""" - [ ] #getKey
""" - [ ] #getProp
""" - [ ] #setProp
""" - [ ] #hasProp
""" - [ ] #getTypeNames
"""
""" - [ ] Compile stew to sire.
"""
""" - [ ] Write a macro that parses stew, compiles it to sire, and
"""       expands to that.
"""
""" - [ ] Redefine all runes to invoke TheBigStewMacro.
"""
""" - [ ] Name resolution
"""
""" - [ ] Merge switch.sire and datatype.sire
""" - [ ] Implement #openrecord (#datacase on records)
""" - [ ] Merge (#switch / #openrecord / #datacase) into #case
""" - [ ] #case supports multiple values.
""" - [ ] #case supports recursive patterns.
""" - [ ] Merge #record and #datatype into #data
"""

""" Types """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

# datatype Pat
* PVAR=v k:Key n:Sym
* PSEQ=s k:Key p:Sym
* PALI=a n:Sym p:Pat
* PROW=r x:(Row Pat)
* PTAB=t x:(Tab Any Pat)

# record ConCase
| CON_CASE con:Sym params:(Row Pat) body:Exp

# record Fun
| FUN self:Sym tag:Nat args:(Row Pat) body:Exp

# datatype Cmd
* CEXP=exp e:Exp
* CMUT=mut cs:(Row Cmd)  ;;  Mutually recursive

# datatype Exp
* EBED=cns b:Any
* EREF=ref r:Str
* ENAT=nat n:Nat
* EPAD=pad n:Pad
* EBAR=bar n:Bar
* ECAB=cab n:(Cab Any)
* EOR=or   x:Exp y:Exp
* EAND=and x:Exp y:Exp
* EAPP=app x:Exp y:Exp
* EKET=ket xs:(Row Exp) v:Exp
* ELET=let n:Pat x:Exp b:Exp
* EREC=rec n:Pat x:Exp b:Exp
* ELAM=lam pin:Bit fun:(Str, Nat, Row Pat, Exp)
* ELIN=lin x:Exp
* EROW=row xs:(Row Exp)
* EUNT=unt
* ETAB=tab xs:(Tab Nat Exp)
* ESWI=swi x:Exp fb:Exp arms:(Tab Any Exp)
* ECAS=cas x:Exp fb:(Opt Exp) cs:(Row ConCase)
* EMUT=mut tag:Nat body:Rex arms:(Row (Sym, Row Pat, Exp))
* EREX=rex r:Rex
* ECON=con x:Exp xs:Exp
* ENIL=nil
* EEQL=eql xs:(Row Exp)
* ENEQ=neq x:Exp y:Exp


""" Printing """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

> Any > Rex
= (showKey k)
| ifNot (isNat k)
    | todo {TODO: Support non-nat keys when printing tab patterns}
@ isKey
    | and (neq 0 k)
    | barAll isAlpha (natBar k)
| WORD 0 (if isKey k | showNat k) 0

!!= `a (showKey %a)
!!= `5 (showKey 5)
!!= `0 (showKey 0)

> (v > Rex) > Tab Any v > Rex
= (showTab showVal tab)
| if (tabIsEmpty tab) `(#[])
^ NEST 0 {,} (map _ tabToPairs-tab) 0
& [key val]
| SHUT 0 {=} (showKey key, showVal val) 0

= (showCab cab)
^ PREF 0 "%" [_] 0
^ NEST 0 "," _ 0
| map showKey (cabToRow cab)

> Pat > Rex
= (showPat p)
# datacase p
* (PVAR _k v) | varE v
* (PSEQ _k v) | PREF 0 {!} ,(varE v) 0
* (PALI x y)  | SHUT 0 {@} (showPat x, showPat y) 0
* (PROW xs)   | NEST 0 {,} (map showPat xs) 0
* (PTAB xs)   | showTab showPat xs

!!= (` #[])
  | showPat
  | PTAB #[]

!!= `[x=x y=(!y)]
  | showPat
  | PTAB [x=(PVAR 0 %x) y=(PSEQ 0 %y)]

!!= ` x@[a b@[c !d]]
  | showPat
  | PALI (PVAR 0 %x)
  | PROW
 ++ PVAR 0 %a
 ++ PALI (PVAR 0 %b)
      | PROW (PVAR 0 "c", PSEQ 0 "d")

> Row Rex > Rex
= (showSig rexes@[first])
| if (len rexes == 1) first
| NEST 0 {|} rexes 0

> (Exp > Rex) > Bit > Fun > Rex
= (showFun showSire pin (FUN self tag args body))
| if (self /= tag)
    | todo 'show lambdas where name is different from tag'
@ selfRex  | varE self
@ argRexes | map showPat args
| if (isZero tag)
    | NEST 0 {&}  ,(showSig argRexes)                   | showSire body
| if pin
    | NEST 0 {??} ,(showSig (rowCons selfRex argRexes)) | showSire body
| else
    | NEST 0 {?}  ,(showSig (rowCons selfRex argRexes)) | showSire body

> Sym > Row Pat > Rex
= (showCon cn pts)
| if (null pts) (varE cn)
^ NEST 0 {|} _ 0
| rowCons (varE cn)
| map showPat pts

> (Exp > Rex) > Opt Exp > Row ConCase > Rex
= (showDatacases showSire f xs)
^ _ (listFromRow xs)
? (go xs)
: (cn,pts,b) xs
    < listCase xs
    # datacase f
    * NONE      | 0
    * (SOME fb) | ``(* _ $$(showSire fb))
@ rest (go xs)
| ``((* $$(showCon cn pts) $$(showSire b))($$rest))

= (niceApp showSire e)
^ _ e ~[]
? (loop e acc)
# datacase e
* (EAPP f x) | loop f (showSire x)::acc
* _          | NEST 0 {|} (listToRow (showSire e)::acc) 0

= (showCase showSire x f cs)
| NEST 0 {#} (varE 'datacase', showSire x)
| showDatacases showSire f cs

> (Exp > Rex) > Opt Exp > Row ConCase > Rex
= (showMutRecArms showSire arms)
^ _ (listFromRow arms)
? (go arms)
: [sym pats body] arms <- listCase arms 0
@ symRex (varE sym)
^ NEST 0 "*" (_, showSire body) (go arms)
| if (null pats)
    | 'mutrec arm with no arguments'
    | ['impossible!' 'it makes no sense!']
^ NEST 0 "|" (rowCons symRex _) 0
| map showPat pats

= (showMutRec showSire tag body arms)
| NEST 0 {#}
   ++ varE 'mutrec'
   ++ showSire (ENAT tag)
   ++ showSire body
| showMutRecArms showSire arms

= (showSwitchArms showSire wild arms)
^ _ (tabToPairList arms)
? (go arms)
: [key exp] arms
    < listCase arms
    | NEST 0 "*" (varE "_", showSire wild) 0
^ NEST 0 "*" _ (go arms)
| (showKey key, showSire exp)

= (showSwitch showSire exp wild arms)
| NEST 0 {#}
   ++ varE 'switch'
   ++ showSire exp
| showSwitchArms showSire wild arms

> Exp > Rex
= (showSire exp)
@ go showSire
# datacase exp
* (EBED x)       | EMBD x
* (EREF x)       | WORD 0 x 0
* (ENAT n)       | WORD 0 showNat-n 0
* (EPAD p)       | showPadLit p
* (EBAR b)       | showBarLit b
* (ECAB ks)      | showCab ks
* (EOR x y)      | INFX 0 {||} (showSire x, showSire y) 0
* (EAND x y)     | INFX 0 {&&} (showSire x, showSire y) 0
* (EAPP x y)     | niceApp go exp
* (EKET xs v)    | NEST 0 {^} (map go xs) (go v)
* (ELET n x b)   | NEST 0 {@}  (showPat n, go x) (go b)
* (EREC n x b)   | NEST 0 {@@} (showPat n, go x) (go b)
* (ELAM pin fun) | showFun go pin fun
* (ELIN x)       | PREF 0 {**} ,(showSire x) 0
* (EROW xs)      | NEST 0 {,} (map go xs) 0
* (ETAB xs)      | showTab showSire xs
* EUNT           | `()
* (ECAS x f cs)  | showCase go x f cs
* (EMUT t b as)  | showMutRec go t b as
* (ESWI e f as)  | showSwitch go e f as
* (EREX r)       | NEST 0 "`" [r] 0
* (ECON x xs)    | INFX 0 "::" (showSire x, showSire xs) 0
* ENIL           | `(~[])
* (EEQL xs)      | INFX 0 "==" (map showSire xs) 0
* (ENEQ x y)     | INFX 0 "/=" (showSire x, showSire y) 0
* _              | {showSire: Unknown syntax} exp

!!= ` (@ n 6516329)(@ fanc (**mkLaw n a b))(0 p#{111} b#{asdf} (2 fanc))
  | showSire
  | ELET (PVAR 0 "n") (ENAT %inc)
  | ELET (PVAR 0 "fanc")
      | foldl EAPP (ELIN | EREF %mkLaw)
     ++ EREF %n
     ++ EREF %a
     ++ EREF %b
  | EAPP
      | EAPP
          | EAPP (ENAT 0) (EPAD p#111)
      | EBAR b#asdf
  | EAPP (ENAT 2)
  | EREF %fanc

!!= ` [%[0 a b] %[0] %[]]
  | showSire
  | EROW (map ECAB [%[0 a b] %[0] %[]])

!!= ` [#[] [a=3] [us=[() ()]]]
  | showSire
  | EROW (map ETAB [#[] [a=(ENAT 3)] [us=(EROW [EUNT EUNT])]])

!!= ` (& (x y))x
  | showSire
  | ELAM FALSE
  | FUN 0 0 (PVAR 0 %x, PVAR 0 %y) (EREF %x)

!!= ` (? (const x y))x
  | showSire
  | ELAM FALSE
  | FUN "const" "const" (PVAR 0 %x, PVAR 0 %y) (EREF %x)

!!= ` (^ f _ y)x
  | showSire
  | EKET (EREF %f, EREF %_, EREF %y)
  | EREF %x


""" Parsing """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseLet readExp rex err ok)
@ kids@[patRex expRex bodRex] (rexKids rex)
| if (len kids /= 3) (err rex 'Bad let')
: var < parseBinder patRex err
: exp < readExp expRex err
: bod < readExp bodRex err
| ok (ELET var exp bod)

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseRec readExp rex err ok)
: e <- parseLet readExp rex err
# datacase e
* (ELET v e b) | ok | EREC v e b

> (Rex > Parser Exp) > Rex > Parser Rex
= (parseCen rex err ok)
: eRes <- readCenLit rex err
# datacase eRes
* (LEFT val)  | ok (ENAT val)
* (RIGHT cab) | ok (ECAB cab)

> (Rex > Parser Exp) > Rex > Parser Rex
= (parseCenCen rex err ok)
: cab <- readTallCab rex err
| ok (ECAB cab)

= (parseOrExp readExp rex err ok)
: tree <- readInfixRight readExp "||" rex err
| ok (binTreeFold EOR tree)

= (parseAndExp readExp rex err ok)
: tree <- readInfixRight readExp "&&" rex err
| ok (binTreeFold EAND tree)

= (readHaxOutline rex err ok)
@ kids@[keywordRex] | rexKids rex
@ params            | drop 1 kids
| if (null kids)
    | err rex '# with no parameter'
: sym <- readSymbol keywordRex err
| ok keywordRex sym params

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseHaxExp readExp rex err ok)
: symRex sym params <- readHaxOutline rex err
# switch sym
* _   | err symRex 'Unknown # keyword'
* {p} | readPadLit rex err (pad & ok (EPAD pad))
* {b} | readBarLit rex err (pad & ok (EBAR pad))
* {x} | readBarLit rex err (pad & ok (EBAR pad))
* {mutrec}
    : tag body arms < readMutRecExp readExp rex err
    | ok (EMUT tag body arms)
* {switch}
    : exp fallback arms < readSwitchExp readExp rex err
    | ok (ESWI exp fallback arms)
* {datacase}
    : val fb cases < parseDatacase readExp rex err
    | ok ^ ECAS val fb (map _ cases)
         & [_ constr pats body]
         | CON_CASE constr pats body

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseSig readExp rex err ok)
: items <- readWideListLit readExp rex err
| ok (listFoldr ECON ENIL items)

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseSigSig readExp rex err ok)
: items <- readTallListLit readExp rex err
| ok (listFoldr ECON ENIL items)

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseColCol readExp rex err ok)
: tree <- readInfixRight readExp "::" rex err
| ok (binTreeFold ECON tree)

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseTisTis readExp rex err ok)
: items <- readEqlExp readExp rex err
| ok (EEQL items)

> (Rex > Parser Exp) > Rex > Parser Exp
= (parseFasTis readExp rex err ok)
: x y <- readNotEqlExp readExp rex err
| ok (ENEQ x y)

> (Rex > Parser Exp) > Rex > Parser Rex
= (parseHaxHax readExp rex err ok)
: tab <- readTallTabLit readExp rex err
| ok (ETAB tab)

= (parseTik rex err ok)
@ kids (rexKids rex)
| ifNot (eql 1 | len kids)
    | err rex {Expected something like `(rex)}
| EREX (idx 0 kids)

= (readApp readExp rex err ok)
: exps <- readFancyApp readExp rex err
| ok
| if (null exps) EUNT
| foldl EAPP (idx 0 exps) (drop 1 exps)

= (readKet readExp rex err ok)
@ sons (rexSons rex)
@ heir (rexHeir rex)
| if (null sons && isZero heir)
    | err rex "Bad ^ must be:  (^ f _ y)x"
: exp <- traverseRow (x k & readExp x err k) sons
: cab <- readExp heir err
| ok | EKET exp cab

= (readPam readExp rex err ok)
@ kids (rexKids rex)
| if (len kids /= 2) (err rex 'Bad lambda')
@ [sigRex bodRex] kids
: pats <- readBindSig sigRex err
: body <- readExp bodRex err
| ok | ELAM FALSE | FUN 0 0 pats body

= (readWut readExp pinned rex err ok)
@ kids@[sigRex bodRex] (rexKids rex)
| if (len kids /= 2) (err rex 'Bad lambda.')
: func pats <- readDestroyer sigRex err
: body <- readExp bodRex err
| ok (ELAM pinned | FUN func func pats body)

= (readLin readExp rex err ok)
@ kids@[expRex]
    | rexKids rex
| if (len kids /= 1)
    | err rex "Expected something like: **x"
: exp <- readExp expRex err
| ok (ELIN exp)

= (readCom readExp rex err ok)
@ rune (rexRune rex)
@ kids (rexKids rex)
| if (and (not null-kids) (eql "=" (rexRune fst-kids)))
    : tab <- readWideTabLit readExp rex err
    | ok (ETAB tab)
| else
    : exps <- traverseRow (x k & readExp x err k) kids
    | ok (EROW exps)

= (readCol readExp rex err ok)
: valExp oFunName pats bodyExp
    < readColExp parseBinder readExp rex err
| trk [=valExp =oFunName =pats =bodyExp]
@ (nam, pin)
    | fromSome (FALSE, "") oFunName
| trk [=pin =nam]
| ok
    | EAPP valExp
    | ELAM pin (nam, nam, pats, bodyExp)

> Chr > Bit
(okIdnChar c)=(eql '_' c || isAlphaNum c)

> Bar > Bit
= (okIdn bar)
@ c (barIdx 0 bar)
| rowAnd
++ not (barIsEmpty bar)
++ not (isDigit c)
++ barAll okIdnChar bar

= leafExpect
  """ Expected something like
  """
  """     foo
  """     123
  """     0xaf

= (getHexLit bar fall ret)
| if (neq b#0x | barTake 2 bar) fall
| getHexBar (barDrop 2 bar) fall ret

= (readLeaf rex err ok)
@ txt (rexText rex)
# switch (rexStyle rex)
* CORD ok-(ENAT txt)
* TAPE ok-(ENAT txt)
* LINE ok-(ENAT txt)
* PAGE ok-(ENAT txt)
* CURL ok-(ENAT txt)
* WORD
@ bar    (natBar txt)
@ natStr (barNat bar)
| trk [=bar =natStr res=(getNatStr natStr NONE SOME)]
^ getNatStr natStr _ (compose ok ENAT)
^ getHexLit bar    _ (compose ok ENAT)
| if (okIdn bar)
    | ok (EREF txt)
| else
    | err rex leafExpect

> Rex > Parser Exp
= (readExp rex err ok)
# switch (rexType rex)
* "EMBD" | ok EBED-(rexGetEmbd rex)
* "LEAF" | readLeaf rex err ok
* "NODE"
# switch (rexRune rex)
* {^}   | readKet readExp rex err ok
* {|}   | readApp readExp rex err ok
* {-}   | readApp readExp rex err ok
* {&}   | readPam readExp rex err ok
* {?}   | readWut readExp FALSE rex err ok
* {:}   | readCol readExp rex err ok
* {??}  | readWut readExp TRUE rex err ok
* {**}  | readLin readExp rex err ok
* {,}   | readCom readExp rex err ok
* {++}  | readOpenRow readExp rex err (compose ok EROW)
* {@}   | parseLet readExp rex err ok
* {@@}  | parseRec readExp rex err ok
* {#}   | parseHaxExp readExp rex err ok
* {##}  | parseHaxHax readExp rex err ok
* {~}   | parseSig readExp rex err ok
* {~~}  | parseSigSig readExp rex err ok
* {::}  | parseColCol readExp rex err ok
* {==}  | parseTisTis readExp rex err ok
* {/=}  | parseFasTis readExp rex err ok
* {`}   | parseTik rex err ok
* {``}  | err rex "Stew doesn't yet support the `` rune."
* {%}   | parseCen rex err ok
* {%%}  | parseCenCen rex err ok
* {&&}  | parseAndExp readExp rex err ok
* {||}  | parseOrExp readExp rex err ok
* _     | err rex (strWeld 'Unknown Rune')

> (Rex > Parser Cmd) > (Rex > Parser Exp) > Rex > Parser Cmd
= (readHaxCmd readCmd rex err ok)
: symRex sym params <- readHaxOutline rex err
# switch sym
* {mutual}
    : cmds <- traverseRow (flip readCmd err) params
    | ok (CMUT cmds)
* _
    : exp <- parseHaxExp readExp err
    | ok (CEXP exp)

> (Rex > Parser Cmd) > (Rex > Parser Exp) > Rex > Parser Cmd
= (readCmd rex err ok)
# switch (rexRune rex)
* _
    : exp <- readExp rex err
    | ok (CEXP exp)
* {#}
    | readHaxCmd readCmd rex err

; Assumes that the input formatting matches the printers formatting,
; except that OPEN-form example inputs will be converted to NEST-form
; inputs, to void long lines on complex examples.
= (sireRound rex)
@ expected | rexClose rex
@ out      | readExp rex v2 showSire
| if (rexEql rexClose-rex out) 1
| OPEN 0 "!=" [out expected] 0

!! sireRound ` x
!! sireRound ` 0
!! sireRound ` (f x y)
!! sireRound ` (**f x y)
!! sireRound ` [p#{101} p#{}]
!! sireRound ` (& x)x
!! sireRound ` (& (x y))x
!! sireRound ` (? (id x))x
!! sireRound ` (? (const x y))x
!! sireRound ` (@ x 3)(x x x)
!! sireRound ` (@@ x 3)x
!! sireRound ` (^ f _ y)x
!! sireRound ` (@ x [1 2])[x x]
!! sireRound ` (@ [x y] [1 2])[y x]
!! sireRound ` (@ z@[!x y] [1 2])(x y z)
!! sireRound ` (# mutrec 3 (three 5))(* (three _) 3)
!! sireRound ` (# mutrec 3 (three 5))(* (three _) 3)(* (four _ _) (inc 3))
!! sireRound ` (# switch 3)(* 3 3)(* 4 4)(* _ 9)

!!= ` (# switch 3)(* 3 3)(* 4 4)(* _ 0)
  ^ readExp _ v2 showSire
  ` # switch 3
    * 3 3
    * 4 4

!!  sireRound
 ` ? (span f r)
   @ l (len r)
   ^ _ 0
   ? (loop i)
   | if (eql i l) (v2 r v0)
     | if (f (idx i r))
         | loop (inc i)
       | v2 (take i r) (drop i r)

!!= `[x=3 y=4]
  ^ readExp _ v2 showSire
  ` ## =x 3
    ## =y 4

!!= `[3 (0 1)]
  ^ readExp _ v2 showSire
  ` ++ 3
    ++ 0 1

!!= `[3 (0 1)]
  ^ readExp _ v2 showSire
  ` ++ 3
     | 0 1

!! sireRound `((# datacase a)(* NONE 0)(* (SOME x) x))

!!= ` %[0 1 2 a b c]
  ^ readExp _ v2 showSire
  ` %% a b c
    %% 0 1 2

!!= ` (3 :: (4 :: (5 :: ~[])))
  ^ readExp _ v2 showSire
  ` ~[3 4 5]

!!= ` (3 :: (4 :: (5 :: ~[])))
  ^ readExp _ v2 showSire
  ` ~~ 3
    ~~ 4
     5

!! sireRound `(3 :: (4 :: (5 :: 6)))

!!= ` (3 :: (4 :: (5 :: 6)))
  ^ readExp _ v2 showSire
  ` :: 3 4
    :: 5
    :: 6

!!= ` (3 == 4 == 5)
  ^ readExp _ v2 showSire
  ` (3 == 4 == 5)

!!= ` (3 /= 4)
  ^ readExp _ v2 showSire
  ` (3 /= 4)

!!= ` (1 && (2 && 3))
  ^ readExp _ v2 showSire
  ` (1 && 2 && 3)

!!= ` (1 || (2 || 3))
  ^ readExp _ v2 showSire
  ` (1 || 2 || 3)

!! sireRound
 ` # datacase a
   * NONE     0
   * _        1

!!= `(add (inc 2) (inc 383))
  ^ readExp _ v2 showSire
  ` | add
    * inc 2
    * inc 0x17f

!!= `(add 2 (? (Foo x))(add x x))
  ^ readExp _ v2 showSire
  ` : ?(Foo x) <- add 2
    | add x x


""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^
^-^ ; Pat
^-^ PVAR PSEQ PALI PROW PTAB
^-^
^-^ ; ConCase
^-^ CON_CASE ; ConCase
^-^
^-^ ; Fun
^-^ FUN
^-^
^-^ ; Cmd
^-^ CEXP CMUT
^-^
^-^ ; Exp
^-^ EBED EREF ENAT EPAD EBAR ECAB EOR EAND EAPP EKET ELET EREC ELAM
^-^ ELIN EROW EUNT ETAB ESWI ECAS EMUT EREX ECON ENIL EEQL ENEQ
^-^
^-^ readExp showSire
^-^ readCmd
^-^
