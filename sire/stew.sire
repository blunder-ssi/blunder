; Copyright 2023 The Plunder Authors
; Use of this source code is governed by a BSD-style license that can be
; found in the LICENSE file.

### stew <- types

;;;; stew.sire
;;;; =========
;;;;
;;;; This is a parser, printer, and compiler for Stew, the "Steward Language".
;;;; Stew is an interim language between Sire and Heir.  Stew is built
;;;; using the Sire macro system but does not itself support further
;;;; macro-extension, instead using the traditional parse, type-check,
;;;; compiler flow.
;;;;
;;;; TODO: Kill io.sire
;;;;
;;;; TODO: Parse all built-in command runes:
;;;;
;;;; - [ ] !!=
;;;; - [ ] =
;;;; - [ ] *
;;;; - [ ] <
;;;; - [ ] ###
;;;;
;;;; TODO: Parse all macro-defined commands:
;;;;
;;;; - [ ] !!
;;;; - [x] #mutual
;;;; - [ ] #record
;;;; - [ ] #datatype
;;;;
;;;; TODO: Parse all leaf-expressions:
;;;;
;;;; - [x] parse decimal literals
;;;; - [x] parse hex literals
;;;; - [x] identifiers (rejecting malformed ones)
;;;;
;;;; DONE: Parse all built-in expression runes:
;;;;
;;;; - [x] | -
;;;; - [x] @
;;;; - [x] @@
;;;; - [x] &
;;;; - [x] ?
;;;; - [x] ??
;;;; - [x] **
;;;; - [x] ^
;;;;
;;;; TODO: Parse all macro-defined expressions:
;;;;
;;;; - [x] #p
;;;; - [x] #b
;;;; - [x] #x
;;;; - [x] %
;;;; - [x] %%
;;;; - [x] #  (tabs)
;;;; - [x] ##
;;;; - [x] @   (lambda binds)
;;;; - [x] @   (multi binds)
;;;; - [x] ``
;;;; - [x] `
;;;; - [x] &&
;;;; - [x] ||
;;;; - [x] ==
;;;; - [x] /=
;;;; - [x] , (rows)
;;;; - [x] , (tabs)
;;;; - [x] ++
;;;; - [x] :
;;;; - [x] ~
;;;; - [x] ~~
;;;; - [x] ::
;;;; - [x] # (keywords)
;;;; - [x] #datacase
;;;; - [x] #mutrec
;;;; - [x] #switch
;;;; - [x] . (non-symbolic references)
;;;; - [x] Correctly print non-symbol references.
;;;; - [ ] Fix inline annotations on function literals.
;;;; - [ ] Make sure function literals support all details.
;;;; - [x] RECORD(..) patterns
;;;;
;;;; TODO: Support non-atomic keys in tabs.
;;;;
;;;; TODO: Parse expressions that don't exist yet.
;;;;
;;;; - [ ] / ("has type")
;;;;
;;;; Parse other commands:
;;;;
;;;; - [ ] >
;;;; - [ ] \
;;;; - [ ] #abstype
;;;; - [ ] #backfill
;;;; - [ ] #typedef
;;;; - [ ] #typeof
;;;; - [ ] #printType
;;;; - [ ] #getenv
;;;; - [ ] #getKey
;;;; - [ ] #getProp
;;;; - [ ] #setProp
;;;; - [ ] #hasProp
;;;; - [ ] #getTypeNames
;;;;
;;;; - [x] Compile stew to sire.
;;;; - [x] Write a macro that parses stew, compiles it to sire, and
;;;;       expands to that.
;;;; - [x] Redefine all runes to invoke TheBigStewMacro.
;;;;
;;;; - [ ] Name resolution
;;;;
;;;; - [ ] Merge switch.sire and datatype.sire
;;;; - [ ] Implement #openrecord (#datacase on records)
;;;; - [ ] Merge (#switch / #openrecord / #datacase) into #case
;;;; - [ ] #case supports multiple values.
;;;; - [ ] #case supports recursive patterns.
;;;; - [ ] Merge #record and #datatype into #data


;;; Imports ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

/+  boot
/+  datatype
/+  switch
/+  datatype  [parseDatacase resolveDatacase]
/+  mutrec    [readMutRecExp genMutRecE]
/+  types


;;; Types ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

* # typedef Sym Nat ; TODO: newtype
* # typedef Chr Nat ; TODO: newtype

# datatype Pat
* PVAR=v n:Sym
* PSEQ=s p:Sym
* PALI=a n:Sym p:Pat
* PROW=r x:(Row Pat)
* PTAB=t x:(Tab Any Pat)
* POPN=o n:Sym
* PPIN=pin x:Pat
* PLAW=law n:Pat a:Pat b:Pat

# record ConCase
| CON_CASE con:Sym params:(Row Pat) body:Exp

# record StewFun
| FUN self:Sym tag:Nat args:(Row Pat) body:Exp

# datatype Cmd
* CEXP=exp e:Exp
* CMUT=mut cs:(Row Cmd)  ;;  Mutually recursive

# datatype Exp
* EBED=cns b:Any
* EREF=ref r:Str
* ENAT=nat n:Nat
* EPAD=pad n:Pad
* EBAR=bar n:Bar
* ESET=set n:(Set Any)
* EOR=or   x:Exp y:Exp
* EAND=and x:Exp y:Exp
* EAPP=app x:Exp y:Exp
* EKET=ket x:Exp b:Exp
* ELET=let n:Pat x:Exp b:Exp
* EREC=rec n:Pat x:Exp b:Exp
* ELAM=lam pin:Bit fun:(Str, Nat, Row Pat, Exp)
* ELIN=lin x:Exp
* EROW=row xs:(Row Exp)
* EUNT=unt
* ETAB=tab xs:(Tab Nat Exp)
* ESWI=swi x:Exp fb:Exp arms:(Tab Any Exp)
* ECAS=cas x:Exp fb:(Opt Exp) cs:(Row ConCase)
* EMUT=mut tag:Nat body:Exp arms:(Row (Sym, Row Pat, Exp))
* EREX=rex r:Rex
* EQRX=qrx r:(RexWith (Either Exp Exp))
* ECON=con x:Exp xs:Exp
* ENIL=nil
* EEQL=eql xs:(Row Exp)
* ENEQ=neq x:Exp y:Exp


;;; Printing ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

> Any > Rex
= (showKey k)
| ifNot (isNat k)
    | todo {TODO: Support non-nat keys when printing tab patterns}
@ isKey
    | and (neq 0 k)
    | barAll isAlpha (natBar k)
| WORD (if isKey k | showNat k) 0

!!= ``a (showKey %a)
!!= ``5 (showKey 5)
!!= ``0 (showKey 0)

> (v > Rex) > Tab Any v > Rex
= (showTab showVal tab)
| if (tabIsEmpty tab) ``(#[])
^ NEST {,} (map _ tabToPairs-tab) 0
& [key val]
| SHUT {=} (showKey key, showVal val) 0

= (showSet set)
^ PREF "%" [_] 0
^ NEST "," _ 0
| map showKey (setToRow set)

> Pat > Rex
= (showPat p)
# datacase p
* (PVAR v)     | varE v
* (PSEQ v)     | PREF {!} ,(varE v) 0
* (PALI x y)   | SHUT {@} (showPat x, showPat y) 0
* (PROW xs)    | NEST {,} (map showPat xs) 0
* (PTAB xs)    | showTab showPat xs
* (POPN n)     | rexSetHeir ``(..) (varE n)
* (PPIN p)     | ` @(PIN $(showPat p))
* (PLAW n a b) | ` @(LAW $(showPat n) $(showPat a) $(showPat b))
* _            | {invalid pattern} p

!!= (`` #[])
  | showPat
  | PTAB #[]

!!= ``[x=x y=(!y)]
  | showPat
  | PTAB [x=(PVAR %x) y=(PSEQ %y)]

!!= ``[x=(UNIT(..)) y=(!y)]
  | showPat
  | PTAB [x=(POPN %UNIT) y=(PSEQ %y)]

!!= `` x@[a b@[c !d]]
  | showPat
  | PALI (PVAR %x)
  | PROW
 ++ PVAR %a
 ++ PALI (PVAR %b)
      | PROW (PVAR "c", PSEQ "d")

> Row Rex > Rex
= (showSig rexes@[first])
| if (len rexes == 1) first
| NEST {|} rexes 0

> (Exp > Rex) > Bit > StewFun > Rex
= (showFun showExp pin (FUN self tag args body))
| if (self /= tag)
    | todo 'show lambdas where name is different from tag'
@ selfRex  | varE self
@ argRexes | map showPat args
| if (isZero tag)
    | NEST {&}  ,(showSig argRexes)                   | showExp body
| if pin
    | NEST {??} ,(showSig (rowCons selfRex argRexes)) | showExp body
| else
    | NEST {?}  ,(showSig (rowCons selfRex argRexes)) | showExp body

> Sym > Row Pat > Rex
= (showCon cn pts)
| if (null pts) (varE cn)
^ NEST {|} _ 0
| rowCons (varE cn)
| map showPat pts

> (Exp > Rex) > Opt Exp > Row ConCase > Rex
= (showDatacases showExp f xs)
^ _ (listFromRow xs)
? (go xs)
: (cn,pts,b) xs
    < listCase xs
    # datacase f
    * NONE      | 0
    * (SOME fb) | `(* _ $(showExp fb))
@ rest (go xs)
| `((* $(showCon cn pts) $(showExp b))($rest))

= (niceApp showExp e)
^ _ e ~[]
? (loop e acc)
# datacase e
* (EAPP f x) | loop f (showExp x)::acc
* _          | NEST {|} (listToRow (showExp e)::acc) 0

= (showCase showExp x f cs)
| NEST {#} (varE 'datacase', showExp x)
| showDatacases showExp f cs

> (Exp > Rex) > Opt Exp > Row ConCase > Rex
= (showMutRecArms showExp arms)
^ _ (listFromRow arms)
? (go arms)
: [sym pats body] arms <- listCase arms 0
@ symRex (varE sym)
^ NEST "*" (_, showExp body) (go arms)
| if (null pats)
    | 'mutrec arm with no arguments'
    | ['impossible!' 'it makes no sense!']
^ NEST "|" (rowCons symRex _) 0
| map showPat pats

= (showMutRec showExp tag body arms)
| NEST {#}
   ++ varE 'mutrec'
   ++ showExp (ENAT tag)
   ++ showExp body
| showMutRecArms showExp arms

= (showSwitchArms showExp wild arms)
^ _ (tabToPairList arms)
? (go arms)
: [key exp] arms
    < listCase arms
    | NEST "*" (varE "_", showExp wild) 0
^ NEST "*" _ (go arms)
| (showKey key, showExp exp)

= (showSwitch showExp exp wild arms)
| NEST {#}
   ++ varE 'switch'
   ++ showExp exp
| showSwitchArms showExp wild arms

= (rexSplice f rex)
| if (isZero rex)    | rex
| if (rexIsEmbd rex) | f | rexEmbd rex
| rexSetSons | map (rexSplice f) (rexSons rex)
| rexSetHeir | rexSplice f (rexHeir rex)
| rex

= (showQuasiQuotedRex showExp rex)
^ rexSplice _ rex
& val
# datacase val
* (LEFT l)  | PREF "$$" [showExp-l] 0
* (RIGHT r) | PREF "$"  [showExp-r] 0

> Chr > Bit
(okIdnChar c)=(eql '_' c || isAlphaNum c)

> Bar > Bit
= (okIdn bar)
@ c (barIdx 0 bar)
| rowAnd
++ not (barIsEmpty bar)
++ not (isDigit c)
++ barAll okIdnChar bar

(okIdnStr str)=(okIdn | natBar str)

= (showRef dot str)
@ bar (natBar str)
| if (okIdn bar)
    | WORD str 0
| if (not (barIsEmpty bar) && barAll isPrint bar)
    ^ PREF dot [_] 0
    | CURL str 0
| else
    ^ PREF dot [_] 0
    | WORD (showNat str) 0

; TODO: Fix loot printing for {...\{...}.
; TODO: Fix vim highlighting for {...\{...}.

!!= ``abc      | showRef {.} 'abc'
!!= ``(.0)     | showRef {.} ''
!!= ``(.1)     | showRef {.} 1
!!= ``(.{a c}) | showRef {.} 'a c'
!!= ``(.{\{})  | showRef {.} '{'

= (mkApp row)
| if (null row)
    | die 'mkApp: function application with no function'
| foldl EAPP (idx 0 row) (drop 1 row)

!!= 1                            | mkApp [1]
!!= (EAPP 1 2)                   | mkApp [1 2]
!!= (EAPP (EAPP 1 2) 3)          | mkApp [1 2 3]
!!= (EAPP (EAPP (EAPP 1 2) 3) 4) | mkApp [1 2 3 4]

> Exp > Rex
= (showExp exp)
@ go showExp
# datacase exp
* (EBED x)       | EMBD x
* (EREF x)       | showRef {.} x
* (ENAT n)       | WORD showNat-n 0
* (EPAD p)       | showPadLit p
* (EBAR b)       | showBarLit b
* (ESET ks)      | showSet ks
* (EOR x y)      | INFX {||} (showExp x, showExp y) 0
* (EAND x y)     | INFX {&&} (showExp x, showExp y) 0
* (EAPP x y)     | niceApp go exp
* (EKET b v)     | NEST {^} [(go b)] (go v)
* (ELET n x b)   | NEST {@}  (showPat n, go x) (go b)
* (EREC n x b)   | NEST {@@} (showPat n, go x) (go b)
* (ELAM pin fun) | showFun go pin fun
* (ELIN x)       | PREF {**} ,(showExp x) 0
* (EROW xs)      | NEST {,} (map go xs) 0
* (ETAB xs)      | showTab showExp xs
* EUNT           | ``()
* (ECAS x f cs)  | showCase go x f cs
* (EMUT t b as)  | showMutRec go t b as
* (ESWI e f as)  | showSwitch go e f as
* (EREX r)       | NEST {``} [r] 0
* (EQRX r)       | NEST {`} [(showQuasiQuotedRex go r)] 0
* (ECON x xs)    | INFX "::" (showExp x, showExp xs) 0
* ENIL           | ``(~[])
* (EEQL xs)      | INFX "==" (map showExp xs) 0
* (ENEQ x y)     | INFX "/=" (showExp x, showExp y) 0
* _              | {showExp: Unknown syntax} exp


!!= `` (@ n 6516329)(@ fanc (**mkLaw n a b))(0 p#{111} b#{asdf} (2 fanc))
  | showExp
  | ELET (PVAR "n") (ENAT %inc)
  | ELET (PVAR "fanc")
      | foldl EAPP (ELIN | EREF %mkLaw)
     ++ EREF %n
     ++ EREF %a
     ++ EREF %b
  | EAPP
      | EAPP
          | EAPP (ENAT 0) (EPAD p#111)
      | EBAR b#asdf
  | EAPP (ENAT 2)
  | EREF %fanc

!!= `` [%[0 a b] %[0] %[]]
  | showExp
  | EROW (map ESET [%[0 a b] %[0] %[]])

!!= `` [#[] [a=3] [us=[() ()]]]
  | showExp
  | EROW (map ETAB [#[] [a=(ENAT 3)] [us=(EROW [EUNT EUNT])]])

!!= `` (& (x y))x
  | showExp
  | ELAM FALSE
  | FUN 0 0 (PVAR %x, PVAR %y) (EREF %x)

!!= `` (? (const x y))x
  | showExp
  | ELAM FALSE
  | FUN "const" "const" (PVAR %x, PVAR %y) (EREF %x)

!!= `` (^ (f _ y))x
  | showExp
  | EKET (mkApp (EREF %f, EREF %_, EREF %y))
  | EREF %x


;;; Parsing ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

> (Rex > Read Exp) > Rex > Read Exp
= (parseLet readExp rex err ok)
: binds body < readLet readExp rex err
| ok
^ foldr _ body binds
& (sweetBind body)
# datacase sweetBind
* (LEFT [lawName argPats lawBody])
    ^ ELET (PVAR lawName) _ body
    | ELAM FALSE
    | FUN lawName lawName argPats lawBody
* (RIGHT [bind valExp])
    | ELET bind valExp body

> (Rex > Read Exp) > Rex > Read Exp
= (parseRec readExp rex err ok)
: e <- parseLet readExp rex err
# datacase e
* (ELET v e b) | ok | EREC v e b

> (Rex > Read Exp) > Rex > Read Rex
= (parseCen rex err ok)
: eRes <- readCenLit rex err
# datacase eRes
* (LEFT val)  | ok (ENAT val)
* (RIGHT set) | ok (ESET set)

> (Rex > Read Exp) > Rex > Read Rex
= (parseCenCen rex err ok)
: set <- readTallSet rex err
| ok (ESET set)

= (parseOrExp readExp rex err ok)
: tree <- readInfixRight readExp "||" rex err
| ok (binTreeFold EOR tree)

= (parseAndExp readExp rex err ok)
: tree <- readInfixRight readExp "&&" rex err
| ok (binTreeFold EAND tree)

= (readCom readExp rex err ok)
@ rune (rexRune rex)
@ kids (rexKids rex)
| if (and (not null-kids) (eql "=" (rexRune fst-kids)))
    : tab <- readWideTabLit readExp rex err
    | ok (ETAB tab)
| else
    : exps <- rowTraverse (x k & readExp x err k) kids
    | ok (EROW exps)

= (readHaxOutline rex err ok)
@ kids@[keywordRex] | rexKids rex
@ params            | drop 1 kids
| if (null kids)
    | err rex '# with no parameter'
: sym <- readSymbol keywordRex err
| ok keywordRex sym params

> (Rex > Read Exp) > Rex > Read Exp
= (parseHaxExp readExp rex err ok)
@ kids (rexKids rex)
@ rune (rexRune rex)
| if ((1 == len kids) && (',' == rexRune fst-kids))
    : tab <- readWideTabLit readExp fst-kids err
    | ok (ETAB tab)
;
: symRex sym params
    < readHaxOutline rex err
;
# switch sym
* _   | err symRex 'Unknown # keyword'
* {p} | readPadLit rex err (pad & ok (EPAD pad))
* {b} | readBarLit rex err (pad & ok (EBAR pad))
* {x} | readBarLit rex err (pad & ok (EBAR pad))
* {mutrec}
    : tag body arms < readMutRecExp readExp rex err
    | ok (EMUT tag body arms)
* {switch}
    : exp fallback arms < readSwitchExp readExp rex err
    | ok (ESWI exp fallback arms)
* {datacase}
    : val fb cases < parseDatacase readExp rex err
    | ok ^ ECAS val fb (map _ cases)
         & [_ constr pats body]
         | CON_CASE constr pats body

> (Rex > Read Exp) > Rex > Read Exp
= (parseSig readExp rex err ok)
: items <- readWideListLit readExp rex err
| ok (listFoldr ECON ENIL items)

> (Rex > Read Exp) > Rex > Read Exp
= (parseSigSig readExp rex err ok)
: items <- readTallListLit readExp rex err
| ok (listFoldr ECON ENIL items)

> (Rex > Read Exp) > Rex > Read Exp
= (parseColCol readExp rex err ok)
: tree <- readInfixRight readExp "::" rex err
| ok (binTreeFold ECON tree)

> (Rex > Read Exp) > Rex > Read Exp
= (parseTisTis readExp rex err ok)
: items <- readEqlExp readExp rex err
| ok (EEQL items)

> (Rex > Read Exp) > Rex > Read Exp
= (parseFasTis readExp rex err ok)
: x y <- readNotEqlExp readExp rex err
| ok (ENEQ x y)

> (Rex > Read Exp) > Rex > Read Rex
= (parseHaxHax readExp rex err ok)
: tab <- readTallTabLit readExp rex err
| ok (ETAB tab)

= (parseTikTik rex err ok)
@ kids (rexKids rex)
| ifNot (eql 1 | len kids)
    | err rex {Expected something like ``(rex)}
| ok
| EREX (idx 0 kids)

= (parseTik readExp rex err ok)
;
@ (readValLeft rex err ok)
    : exp < readExp rex err
    | ok (LEFT exp)
;
@ (readExpRight rex err ok)
    : exp < readExp rex err
    | ok (RIGHT exp)
;
: quoted
    < readQuasiQuotedRex readValLeft readExpRight rex err
;
| ok (EQRX quoted)

= (readApp readExp rex err ok)
: exps <- readFancyApp readExp rex err
| ok
| if (null exps) EUNT
| foldl EAPP (idx 0 exps) (drop 1 exps)

= (readKet readExp rex err ok)
@ kids (rexKids rex)
@ nKid (len kids)
| if (lth nKid 2)
    | err rex "Expected something like (^ exp exp...)body"
@ bodyRex  | get kids (dec nKid)
@ expRexes | take (dec nKid) kids
: bodyExps < rowTraverse (x k & readExp x err k) expRexes
: valExp   < readExp bodyRex err
| ok | EKET (mkApp bodyExps) valExp

= (readPam readExp rex err ok)
@ kids (rexKids rex)
| if (len kids /= 2) (err rex 'Bad lambda')
@ [sigRex bodRex] kids
: pats <- readBindSig sigRex err
: body <- readExp bodRex err
| ok | ELAM FALSE | FUN 0 0 pats body

= (readWut readExp pinned rex err ok)
@ kids@[sigRex bodRex] (rexKids rex)
| if (len kids /= 2) (err rex 'Bad lambda.')
: func pats <- readDestroyer sigRex err
: body <- readExp bodRex err
| ok (ELAM pinned | FUN func func pats body)

= (readLin readExp rex err ok)
@ kids@[expRex]
    | rexKids rex
| if (len kids /= 1)
    | err rex "Expected something like: **x"
: exp <- readExp expRex err
| ok (ELIN exp)

= (readDot rex err ok)
@ kids (rexKids rex)
| if (len kids /= 1)
    | err rex 'expected .key'
: key <- readKey (fst kids) err
| ok (EREF key)

= (readCol readExp rex err ok)
: valExp oFunName pats bodyExp
    < readColExp parseBinder readExp rex err
@ (nam, pin)
    | fromSome (FALSE, "") oFunName
| ok
    | EAPP valExp
    | ELAM pin (nam, nam, pats, bodyExp)

= leafExpect
  """ Expected something like
  """
  """     foo
  """     123
  """     0xAF

= (getHexLit bar fall ret)
| if (neq b#0x | barTake 2 bar) fall
| getHexBar (barDrop 2 bar) fall ret

= (readLeaf rex err ok)
@ txt | rexText rex
@ bar | natBar txt
;
# switch (rexStyle rex)
* {CORD} | ok | ENAT txt
* {TAPE} | ok | ENAT txt
* {LINE} | ok | ENAT txt
* {PAGE} | ok | ENAT txt
* {CURL} | ok | ENAT txt
* {WORD} | if (okIdn bar) (ok (EREF txt))
         @ bar (barFilter (neq '_') bar)
         ^ getNatStr (barNat bar) _ (compose ok ENAT)
         ^ getHexLit bar          _ (compose ok ENAT)
         | err rex leafExpect

> Rex > Read Exp
= (readExp rex err ok)
# switch (rexType rex)
* "EMBD" | ok EBED-(rexGetEmbd rex)
* "LEAF" | readLeaf rex err ok
* "NODE"
# switch (rexRune rex)
* {^}   | readKet readExp rex err ok
* {|}   | readApp readExp rex err ok
* {-}   | readApp readExp rex err ok
* {&}   | readPam readExp rex err ok
* {?}   | readWut readExp FALSE rex err ok
* {:}   | readCol readExp rex err ok
* {??}  | readWut readExp TRUE rex err ok
* {**}  | readLin readExp rex err ok
* {,}   | readCom readExp rex err ok
* {++}  | readOpenRow readExp rex err (compose ok EROW)
* {.}   | readDot rex err ok
* {@}   | parseLet readExp rex err ok
* {@@}  | parseRec readExp rex err ok
* {#}   | parseHaxExp readExp rex err ok
* {##}  | parseHaxHax readExp rex err ok
* {~}   | parseSig readExp rex err ok
* {~~}  | parseSigSig readExp rex err ok
* {::}  | parseColCol readExp rex err ok
* {==}  | parseTisTis readExp rex err ok
* {/=}  | parseFasTis readExp rex err ok
* {``}  | parseTikTik rex err ok
* {`}   | parseTik readExp rex err ok
* {%}   | parseCen rex err ok
* {%%}  | parseCenCen rex err ok
* {&&}  | parseAndExp readExp rex err ok
* {||}  | parseOrExp readExp rex err ok
* _     | err rex (strWeld 'Unknown Rune: ' | rexRune rex)

> (Rex > Read Cmd) > (Rex > Read Exp) > Rex > Read Cmd
= (readHaxCmd readCmd rex err ok)
: symRex sym params <- readHaxOutline rex err
# switch sym
* {mutual}
    : cmds <- rowTraverse (flip readCmd err) params
    | ok (CMUT cmds)
* _
    : exp <- parseHaxExp readExp err
    | ok (CEXP exp)

> (Rex > Read Cmd) > (Rex > Read Exp) > Rex > Read Cmd
= (readCmd rex err ok)
# switch (rexRune rex)
* _
    : exp <- readExp rex err
    | ok (CEXP exp)
* {#}
    | readHaxCmd readCmd rex err

; Assumes that the input formatting matches the printers formatting,
; except that OPEN-form example inputs will be converted to NEST-form
; inputs, to void long lines on complex examples.
= (expRound rex)
@ expected | rexClose rex
@ out      | readExp rex v2 showExp
| if (expected == out) 1
| OPEN '/=' []
| OPEN '*' [out]
| OPEN '*' [expected]
| 0

!! expRound `` x
!! expRound `` .{||}
!! expRound `` .0
!! expRound `` .3
!! expRound `` 0
!! expRound `` (f x y)
!! expRound `` (**f x y)
!! expRound `` [p#{101} p#{}]
!! expRound `` (& x)x
!! expRound `` (& (x y))x
!! expRound `` (? (id x))x
!! expRound `` (? (const x y))x
!! expRound `` (@ x 3)(x x x)
!! expRound `` (@@ x 3)x
!! expRound `` (^ (f _ y))x
!! expRound `` (@ x [1 2])[x x]
!! expRound `` (@ [x y] [1 2])[y x]
!! expRound `` (@ z@[!x y] [1 2])(x y z)
!! expRound `` (# mutrec 3 (three 5))(* (three _) 3)
!! expRound `` (# mutrec 3 (three 5))(* (three _) 3)(* (four _ _) (inc 3))
!! expRound `` (# switch 3)(* 3 3)(* 4 4)(* _ 9)

!!= ``[x=3 y=4]
  ^ readExp _ v2 showExp
 `` #[x=3 y=4]

!!= ``[x=3 y=4]
  ^ readExp _ v2 showExp
  `` #["x"=3 {y}=4]

!!= `` (@ f (? (f x))[x x])x
  ^ readExp _ v2 showExp
 `` @ (f x) [x x]
    | x

!!= `` (@ x 3)(@ y 4)(@ z 5)[x y z]
  ^ readExp _ v2 showExp
 `` @   = x 3
        = y 4
        = z 5
    | [x y z]

!!= `` (# switch 3)(* 3 3)(* 4 4)(* _ 0)
  ^ readExp _ v2 showExp
 `` # switch 3
    * 3 3
    * 4 4

!!  expRound
`` ? (span f r)
   @ l (len r)
   ^ (_ 0)
   ? (loop i)
   | if (eql i l) (v2 r v0)
     | if (f (idx i r))
         | loop (inc i)
       | v2 (take i r) (drop i r)

!!= ``[x=3 y=4]
  ^ readExp _ v2 showExp
 `` ## =x 3
    ## =y 4

!!= ``[300000 (0 57005)]
  ^ readExp _ v2 showExp
 `` ++ 300_000
    ++ 0 0xD_E_A_D

!!= ``[3 (0 1)]
  ^ readExp _ v2 showExp
 `` ++ 3
     | 0 1

!! expRound ``((# datacase a)(* NONE 0)(* (SOME x) x))

!!= `` %[0 1 2 a b c]
  ^ readExp _ v2 showExp
 `` %% a b c
    %% 0 1 2

!!= `` (3 :: (4 :: (5 :: ~[])))
  ^ readExp _ v2 showExp
 `` ~[3 4 5]

!!= `` (3 :: (4 :: (5 :: ~[])))
  ^ readExp _ v2 showExp
 `` ~~ 3
    ~~ 4
     5

!! expRound ``(3 :: (4 :: (5 :: 6)))

!!= `` (3 :: (4 :: (5 :: 6)))
  ^ readExp _ v2 showExp
 `` :: 3 4
    :: 5
    :: 6

!!= `` (3 == 4 == 5)
  ^ readExp _ v2 showExp
 `` (3 == 4 == 5)

!!= `` (3 /= 4)
  ^ readExp _ v2 showExp
 `` (3 /= 4)

!!= `` (1 && (2 && 3))
  ^ readExp _ v2 showExp
 `` (1 && 2 && 3)

!!= `` (1 || (2 || 3))
  ^ readExp _ v2 showExp
 `` (1 || 2 || 3)

!! expRound
`` # datacase a
   * NONE     0
   * _        1

!!= ``(add (inc 2) (inc 383))
  ^ readExp _ v2 showExp
 `` | add
    * inc 2
    * inc 0x17f

!!= ``(add 2 (? (Foo x))(add x x))
  ^ readExp _ v2 showExp
 `` : ?(Foo x) <- add 2
    | add x x

!!= `` (^ (_ 3))(0 0)
  ^ readExp _ v2 showExp
 `` ^ _ 3
    | 0 0

!!= ``asdf
  ^ readExp _ v2 showExp
 `` .{asdf}


;;; Traversal ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; TODO: Move these into the bootstrapping process?  Maybe into 12_tab.sire?

= (tabTraverseState ss f tab ok)
@ keys (tabKeysRow tab)
@ vals (tabValsRow tab)
: ss rexes < rowTraverseState ss f vals
| ok ss (_MkTab keys rexes)

= (traverseTab f tab ok)
@ keys (tabKeysRow tab)
@ vals (tabValsRow tab)
: rexes < rowTraverse f vals
| ok (_MkTab keys rexes)

= (rexTraverseState ss f rex ok)
| if (isZero rex)
    | ok ss rex
| if (rexIsEmbd rex)
    : ss newVal < f ss (rexEmbd rex)
    | ok ss (EMBD newVal)
: ss heir < rexTraverseState ss f (rexHeir rex)
| if (rexIsLeaf rex)
    | ok ss (rexSetHeir heir rex)
: ss sons
  < ^ rowTraverseState ss _ (rexSons rex)
    & (ss son ret)
    | rexTraverseState ss f son ret
| ok ss
| rexSetHeir heir
| rexSetSons sons
| rex


= (traverseRex f rex ok)
: _ res
    < ^ rexTraverseState 0 _ rex
      & (ss rex ok)
      : rex < f rex
      | ok 0 rex
| ok res


= (traverseExp f exp ok)
@ go (traverseExp f)
# datacase exp
* ENIL               | f exp ok
* EUNT               | f exp ok
* (EBED _)           | f exp ok
* (EREF _)           | f exp ok
* (ENAT _)           | f exp ok
* (EPAD _)           | f exp ok
* (EBAR _)           | f exp ok
* (ESET _)           | f exp ok
* (EREX r)           | f exp ok
* (EOR  x y)         | rowTraverse go [x y] & [x y] | f (EOR x y)    ok
* (EAND x y)         | rowTraverse go [x y] & [x y] | f (EAND x y)   ok
* (EAPP x y)         | rowTraverse go [x y] & [x y] | f (EAPP x y)   ok
* (EKET x y)         | rowTraverse go [x y] & [x y] | f (EKET x y)   ok
* (ELET n x b)       | rowTraverse go [x b] & [x b] | f (ELET n x b) ok
* (EREC n x b)       | rowTraverse go [x b] & [x b] | f (EREC n x b) ok
* (ENEQ x y)         | rowTraverse go [x y] & [x y] | f (ENEQ x y)   ok
* (ECON x z)         | rowTraverse go [x z] & [x z] | f (ECON x z)   ok
* (EROW xs)          | rowTraverse go xs    & xs    | f (EROW xs)    ok
* (EEQL xs)          | rowTraverse go xs    & xs    | f (EEQL xs)    ok
* (ETAB kv)          | traverseTab go kv    & kv    | f (ETAB kv)    ok
* (ELAM p (n,t,a,b)) | go b & b | f (ELAM p (n,t,a,b)) ok
* (ELIN x)           | go x & x | f (ELIN x)           ok
* (ECAS x fb cases)
    : x < go x
    : fb
        < & ok
          # datacase fb
          * NONE     | ok NONE
          * (SOME e) | go e (compose ok SOME)
    : cases
        < ^ rowTraverse _ cases
          & ([con params body] ok)
          : body < go body
          | ok [con params body]
    | f (ECAS x fb cases) ok
* (EMUT tab body arms)
    : body < go body
    : arms
        < ^ rowTraverse _ arms
          & ([sym pats armBody] ok)
          : armBody < go armBody
          | ok [sym pats armBody]
    | ok (EMUT tab body arms)
* (ESWI x fb arms)
    : x    < go x
    : fb   < go fb
    : arms < traverseTab go arms
    | f (ESWI x fb arms) ok
* (EQRX rex)
    : rex
        < ^ traverseRex _ rex
          & (embed ok)
          # datacase embed
          * (LEFT cns)
              : cns < go cns
              | ok (LEFT cns)
          * (RIGHT splice)
              : splice < go splice
              | ok (RIGHT splice)
    | f (EQRX rex) ok


= (traversePat f pat ok)
# datacase pat
* (POPN _)   | f pat ok
* (PVAR _)   | f pat ok
* (PSEQ _)   | f pat ok
* (PALI n p)
    : p <- traversePat f p
    | f (PALI n p) ok
* (PROW xs)
    : xs < rowTraverse (traversePat f) xs
    | f (PROW xs) ok
* (PTAB kv)
    : kv < traverseTab (traversePat f) kv
    | f (PTAB kv) ok
* (PPIN p)
    : p <- traversePat f p
    | f (PPIN p) ok
* (PLAW n a b)
    : n <- traversePat f n
    : a <- traversePat f a
    : b <- traversePat f b
    | f (PLAW n a b) ok
* _
    | {invalid pattern} pat



;;; Resolution ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= (resolvePat ss err pat ok)
^ traversePat _ pat ok
& (pat ok)
; trk 'hi',[=pat]
# datacase pat
* _
    | ok pat
* (POPN constr)
    @ rex (showPat pat)
    : _ bind <- getBind constr ss rex err
    @ fieldNames (getProp ss bind 'fieldNames')
    | if (isZero fieldNames)
        | err rex (strWeld "Unknown record constructor: " constr)
    | ok (PROW | map PVAR fieldNames)

= (resolve ss exp err ok)
; trk 'resolve',[=exp]
@ goPat (resolvePat ss err)
^ traverseExp _ exp ok
& (exp ok)
# datacase exp
* (ELET n x b)
    : n <- goPat n
    | ok (ELET n x b)
* (ELAM p (n,t,as,b))
    : as <- rowTraverse goPat as
    | ok | ELAM p (n, t, as, b)
* (EMUT tag body arms)
    : arms < ^ rowTraverse _ arms
             & ([sym pats exp] ret)
             : pats < rowTraverse goPat pats
             | ret [sym pats exp]
    | ok (EMUT tag body arms)
* (ECAS x fb cases)
    : cases
        < ^ rowTraverse _ cases
          & ([con params body] ok)
          : params < rowTraverse goPat params
          | ok (CON_CASE con params body)
    | ok (ECAS x fb cases)
* _
    | ok exp


;;; Compiler ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


= (cQrx go st rex ok)
: st rexWithSplices
  < ^ rexTraverseState st _ rex
    & (st embd ret)
    # datacase embd
    * (LEFT cns)
        : st rex < go st cns
        | ret st (LEFT rex)
    * (RIGHT val)
        : st rex < go st val
        | ret st (RIGHT rex)
| ok st
| splicedE rexWithSplices

= (cApp go st exps ok)
: st rexes < rowTraverseState st go exps
| ok st (appE rexes)

= (cRow go st exps ok)
: st rexes < rowTraverseState st go exps
| ok st (rowE rexes)

= (cTab go st exps ok)
: st rexesTab < tabTraverseState st go exps
| ok st (tabE rexesTab)

= (cEql go st exps ok)
: st rexes  < rowTraverseState st go exps
@ (st, rex) | multiEqlE st rexes
| ok st rex

= (cKet go st bodyExp valExp ok)
: st bodyRex <- go st bodyExp
: st valRex  <- go st valExp
| ok st (letE '_' valRex bodyRex)

= (cSwi go st x fb arms ok)
: st xRex     <- go st x
: st fbRex    <- go st fb
: st patRexes <- tabTraverseState st go arms
| ok st (switchE xRex fbRex patRexes)

= (cLam go st pin (nam, tag, pats, bodyExp) ok)
: st bodyRex     <- go st bodyExp
: st sig bodyRex <- makeDestroyer st pats bodyRex
;
@ bodyRex bodyRex
;
| if (nam /= tag)
    | todo {support mis-match between name and tag}
;
| if (pin && isZero tag)
    | todo {support pinned, anonymous lambdas}
;
| ok st
| if (isZero tag)
    | lamE sig bodyRex
| if pin
    | wutWutE (rowCons nam sig) bodyRex
| else
    | wutE (rowCons nam sig) bodyRex

= (cLet go st pat valExp bodExp ok)
: st valRex < go st valExp
: st bodRex < go st bodExp
;
@ (st, bSeq, deps) | sequenceBinds st [[pat valRex]]
;
| ok st
| bindSeqE bSeq bodRex deps

= (cRec go st pat valExp bodExp ok)
: st valRex < go st valExp
: st bodRex < go st bodExp
;
@ var # datacase pat
      * _          | todo 'support pattern matching in letrec bindings'
      * (PVAR var) | var
;
| ok st (recE var valRex bodRex)


= (cMut go st coreTag bodExp arms ok)
: st bodRex
    < go st bodExp
: st armSpecs
  < ^ rowTraverseState st _ arms
    & (st [funName pats funBodExp] ok)
    : st funBodRex < go st funBodExp
    | ok st [funName pats funBodRex]
: st resultRex
    < genMutRecE st coreTag bodRex armSpecs
| ok st
| rexClose  ; todo: all macros expand to closed forms
| resultRex

= (cCas go ss valExp oWildExp arms ok)
@ rex (showExp | ECAS valExp oWildExp arms)
;
; This on is extra tricky because we need to lookup information from
; the environment, but we don't have that information here.
;
; I guess that needs to be passed in?
;
; Should this be resolved during type-checking?  If so, where should
; the information be stored?
;
; Should the information be included in the datatype and filled in by
; another pass?
;
: ss valRex <- go ss valExp
: ss oWildRex
  < & ret
    # datacase oWildExp
    * NONE           | ret ss NONE
    * (SOME wildExp) : ss wildRex < go ss wildExp
                     | ret ss (SOME wildRex)
;
: ss branches
  < & ret
    ^ rowTraverseState ss _ arms ret
    & (ss (CON_CASE constr pats armExp) ret)
    : ss armRex <- go ss armExp
    ;
    | ret ss [armRex constr pats armRex]
;
: hasTag fun fbRex caseSpecs
    < resolveDatacase rex ss oWildRex branches (curry die)
: ss exp
    < makeDatacaseExpr hasTag fun ss valRex fbRex caseSpecs
;
| ok ss (rexClose exp) ; TODO: no open rune output

; | CON_CASE con:Sym params:(Row Pat) body:Exp
; * ECAS=cas x:Exp fb:(Opt Exp) cs:(Row ConCase)

> Tab Sym Nat > Tab Nat Any > Nat > Exp > (Nat, Exp)
= (compile ss exp)
^   : ss rex <- _ ss exp
    | (ss, rexClose rex)
? (go ss exp ok)
# datacase exp
* ENIL             | ok ss (cnsE 0)
* EUNT             | ok ss (cnsE 0)
* (EBED b)         | ok ss (cnsE b)
* (EREF r)         | ok ss (showRef {#.} r)
* (ENAT n)         | ok ss (cnsE n)
* (EPAD n)         | ok ss (cnsE n)
* (EBAR n)         | ok ss (cnsE n)
* (ESET n)         | ok ss (cnsE n)
* (EREX r)         | ok ss (cnsE r)
* (EQRX r)         | cQrx go ss r ok
* (EOR x y)        | cApp go ss (EBED or, x, y)    ok
* (EAND x y)       | cApp go ss (EBED and, x, y)   ok
* (EAPP x y)       | cApp go ss (x, y)             ok
* (ECON x xs)      | cApp go ss (EBED CONS, x, xs) ok
* (ENEQ x y)       | cApp go ss (EBED neq, x, y)   ok
* (EEQL xs)        | cEql go ss xs                 ok
* (EROW xs)        | cRow go ss xs ok
* (ETAB xs)        | cTab go ss xs ok
* (EKET b x)       | cKet go ss b x ok
* (ESWI x fb arms) | cSwi go ss x fb arms ok
* (ELAM p f)       | cLam go ss p f ok
* (ELET p v b)     | cLet go ss p v b ok
* (EREC p v b)     | cRec go ss p v b ok
* (EMUT t b as)    | cMut go ss t b as ok
* (ECAS v w as)    | cCas go ss v w as ok
* (ELIN x)
    : ss rex < go ss x
    | ok ss (NEST "#**" [rex] 0)


;;; Compiler Testing ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= (comp ss exp)
| compile ss exp

!!= (comp [5] (ENAT 0))
  | [[5] `($$0)]

!!= (comp [5] (EAPP ENAT-0 ENAT-1))
  | [[5] `(#| $$0 $$1)]

!!= (comp [5] (EEQL (ENAT 0, ENAT 1)))
  | [[5] `(#| $$eql $$0 $$1)]

!!=   | comp [5] (EEQL (ENAT 0, ENAT 1, ENAT 2))
 ++ [6]
 ++ `((#@ _g5 $$0)(#| $$and (#| $$eql _g5 $$1) (#| $$eql _g5 $$2)))

!!=   | comp [5] (ELIN (EAPP ELIN-(EREF 'id') (ENAT 1)))
 ++ [5]
 ++ ` (#** (#| (#** id) $$1))

!!= [[5] `(#| $$(%[a b c]) (#| $$(cow 3) (#| $$0 $$3) $$2 $$1))]
  | comp [5]
  | ETAB
 ## =a (ENAT 1)
 ## =b (ENAT 2)
 ## =c (EAPP ENAT-0 ENAT-3)

!!=  ++ [5]
     ++ ` (#| $$tabSwitch foo z (#| $$(%[a b]) (#| $$(cow 2) y x)))
  ^ readExp _ (curry die) (comp [5])
 `` (# switch foo)(* {a} x)(* {b} y)z

!!=  ++ [5]
     ++ ` (#| $$tabSwitch foo $$0 (#| $$(%[a]) (#| $$(cow 1) x)))
  ^ readExp _ (curry die) (comp [5])
 `` (# switch foo)(* {a} x)

; TODO Can these single-item switches be compiled to an if expression?

!!= [[5] ``((#?? (id x))x)]
  | comp [5]
  | ELAM TRUE
  | (%id, %id, [(PVAR %x)], EREF 'x')

!!= [[5] ``((#& x)x)]
  | comp [5]
  | ELAM FALSE
  | (0, 0, [(PVAR %x)], EREF 'x')

!!= [[5] ``((#? (f x z))z)]
  | comp [5]
  | ELAM FALSE
  | ('f', 'f', (PVAR %x, PVAR %z), EREF 'z')

!!=  ++ [7]
     ++ ` (#& _g5)(#@ _g6 _g5)(#@ x (#| $$(idx 0) _g6))(#@ z (#| $$(idx 1) _g6))z
  | comp [5]
  | ELAM FALSE
  | (0, 0, [(PROW (PVAR %x, PVAR %z))], EREF 'z')

!!=  ++ [6]
     ++ ` (#@ _g5 (#| $$(cow 2) $$2 $$1))(#@ x (#| $$(idx 0) _g5))x
  | comp [5]
  | ELET (PROW [(PVAR %x)])
      | EROW (ENAT 1, ENAT 2)
  | EREF 'x'

!!=  ++ [5]
     ++ ` (#@ _ (#| $$0 $$1))(#| _ _)
  | comp [5]
  | EKET (EAPP EREF-'_' EREF-'_')
  | EAPP ENAT-0 ENAT-1

!!=  ++ [5]
     ++ ` (#@@ x (#| $$(cow 2) x $$1))(#| car x)
  | comp [5]
  | EREC (PVAR 'x')
      | EROW (ENAT 1, EREF 'x')
  | EAPP (EREF 'car')
  | EREF 'x'

; gross
!!=  ++ [8] ;; TODO: This is wrong!!!  _tag9 is used, so state should be at 10.
     ++ rexClose
         `  #@ _core5
                #? 'lol' (_core5 _tag7 _arg6)
                #@ even
                    #? (**even x)
                    #| _core5 $$0 x
                #| $$switch _tag7 $$0
                #| $$(cow 1) (#@ x _arg6)x
            #@ even
                #? (**even x)
                #| _core5 $$0 x
             even
  | comp [5]
  | EMUT 'lol' (EREF 'even')
 ++ (%even, [(PVAR %x)], EREF 'x')

= scope
    [SOME=(PIN [3 0 0 'REPL' 'SOME']) NONE=(PIN [4 0 0 'REPL' 'NONE'])]

= props
    ## =3 ## =conTag 1
          ## =conAri 1
          ## =conFun len
          ## =conHas FALSE
          ## =conRaw FALSE
    ## =4 ## =conTag 0
          ## =conAri 0
          ## =conFun len
          ## =conHas FALSE
          ## =conRaw FALSE

= ssEx [5 'REPL' scope #[] props]

; such a beauty
!!=  ++ put ssEx 0 8
     ++ rexClose
        ` #@ _g5 x
          #| $$switch (#| $$len _g5) $$1
              #| $$(cow 2)
                    #@ _g6 x
                    #@ x (#| $$(idx 0) _g6)
                     x
                #@ _g7 x
                 ($$0)
  | comp ssEx
  | ECAS EREF-'x' (SOME | ENAT 1)
 ++ CON_CASE 'SOME' [(PVAR 'x')] EREF-'x'
 ++ CON_CASE 'NONE' []             ENAT-0

!!=  ++ put ssEx 0 7
     ++ rexClose
        ` #@ _g5 sx
          #| $$tabSwitch (#| $$len _g5) $$0
              #| $$(%[1])
                 #| $$(cow 1)
                    #@ _g6 sx
                    #@ x (#| $$(idx 0) _g6)
                     x
  | comp ssEx
  | ECAS (EREF 'sx') NONE
 ++ CON_CASE 'SOME' ,(PVAR 'x') EREF-'x'


;;; Exports ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= (macaroniStew ss rex err ok)
: stewExp  < readExp rex err
: stewExp  < resolve ss stewExp err
@ [ss rex] | compile ss stewExp
| ok ss rex

( {^}   #= macaroniStew )
( {|}   #= macaroniStew )
( {-}   #= macaroniStew )
( {&}   #= macaroniStew )
( {?}   #= macaroniStew )
( {:}   #= macaroniStew )
( {??}  #= macaroniStew )
( {**}  #= macaroniStew )
( {,}   #= macaroniStew )
( {++}  #= macaroniStew )
( {.}   #= macaroniStew )
( {@}   #= macaroniStew )
( {@@}  #= macaroniStew )
( {#}   #= macaroniStew )
( {##}  #= macaroniStew )
( {~}   #= macaroniStew )
( {~~}  #= macaroniStew )
( {::}  #= macaroniStew )
( {==}  #= macaroniStew )
( {/=}  #= macaroniStew )
( {``}  #= macaroniStew )
( {%}   #= macaroniStew )
( {%%}  #= macaroniStew )
( {&&}  #= macaroniStew )
( {||}  #= macaroniStew )
( {`}   #= macaroniStew )

!!= 6 (@ a 3)(add a a)
!!= 0 (3 == 4)
!!= 1 (3 == 3)
!!= 0 (3 == 3 == 4)


;;; Exports ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

^-^
^-^ Pat
^-^ PVAR PSEQ PALI PROW PTAB
^-^
^-^ ConCase
^-^ CON_CASE
^-^
^-^ StewFun
^-^ FUN
^-^
^-^ Cmd
^-^ CEXP CMUT
^-^
^-^ Exp
^-^ EBED EREF ENAT EPAD EBAR ESET EOR EAND EAPP EKET ELET EREC ELAM
^-^ ELIN EROW EUNT ETAB ESWI ECAS EMUT EQRX EREX ECON ENIL EEQL ENEQ
^-^
^-^ showPat
^-^ readExp showExp
^-^ readCmd
^-^ compile
^-^
^-^ ; MAKE.  EVERYTHING.  STEW.
^-^
^-^ {^} {|}  {-}  {&}  {?}  {:}  {??} {**} {,}  {++} {.} {@} {@@} {##}
^-^ {~} {~~} {::} {==} {/=} {``} {%}  {%%} {&&} {||} {`}
^-^
