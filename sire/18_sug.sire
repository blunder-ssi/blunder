;;; Copyright 2023 The Plunder Authors
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.

### 18_sug <- 17_bar

"""
""" Syntactic Sugar
""" ===============
"""
""" This module is a collection of convenience macros.
"""
""" - `:` is convenient syntax for continuation-passing.
"""
""" - `~` and `~~` implement list-literals.
"""
"""
""" The Col Macro
""" -------------
"""
""" `:` is a shorthand for a function call where the last argument is
""" a callback lambda.
"""
""" This pattern comes up quite a lot since we don't have do notation.
"""
""" You write something like:
"""
"""     : (x y z) <- foo x y
"""     | add x
"""     | add y z
"""
""" And that expands to:
"""
"""     - foo x y
"""     & (x y z)
"""     | add x
"""     | add y z
"""
""" (Remember that `-` is function application, just like `|`)
"""
"""
""" List Literals
""" -------------
"""
""" Wide form:
"""
"""     ~[3 4 5]
"""
""" Tall form:
"""
"""    ~~ 3
"""    ~~ 4
"""    ~~ 5
"""


""" Imports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

/+  01_fan
/+  02_bit  [if ifNot and or not else]
/+  03_nat  [add div inc dec isZero lthNat]
/+  04_app  [idx len]
/+  05_cmp  [eql neq lth]
/+  06_row  [weld map foldr null v1 v2 v3 v4 fst snd]
/+  07_rex  [rexConstr rexIdnt rexRune rexSons rexHeir rexKids]
/+  07_rex  [rexIsNode rexIsEmbd rexIsLeaf]
/+  07_rex  [rexGetNode rexEmbd rexVal {`}]
/+  07_rex  [R PREF NEST EMBD OPEN WORD CORD]
/+  07_rex  [rexGetNodeWithRune]
/+  07_rex  [rexStyle rexText rexEql]
/+  07_rex  [rexSetRune rexSetHeir rexSetSons]
/+  08_dat  [{,} {,,} {>} take drop switch]
/+  08_dat  [CONS NIL listToRowReversed listCase listFromRow]
/+  08_dat  [LEFT RIGHT eitherCase]
/+  08_dat  [traverseRow listMap listFoldr]
/+  08_dat  [readRex]
/+  09_sci  []
/+  10_chr  []
/+  11_str  [strWeld strIsCapitalized]
/+  12_cab  [{%}]
/+  13_tab  [{#}]
/+  14_exp  [readSymbol rexParseKids]
/+  14_exp  [rowE natE letE cnsE txtE appE varE gensym]
/+  14_exp  [bloodline]
/+  15_hax  []
/+  16_pad  []
/+  17_bar  []


""" Parsing Signatures """""""""""""""""""""""""""""""""""""""""""""""""""""""""

= sigExpect | "Expected `x` or signature `(x y z)`"
= sigNoHeir | "name-sequence cannot have an heir"

= (readKeySignature rex err ok)
| ifNot (isZero rexHeir-rex)
        | err rex sigNoHeir
| if (rexIsNode rex)
        | if (neq "|" rexRune-rex)
                | (err rex sigExpect)
        ^ traverseRow _ (rexSons rex) ok
        ? (step son ret)
        | readSymbol son err
        & sym
        | ret (rexIdnt son, sym)
| readSymbol rex err
& sym
| ok [(rexIdnt rex, sym)]

= (readSignature rex err ok)
| readKeySignature rex err
& bindings
| ok (map idx-1 bindings)

!!= [%a %b %c]          | readSignature `(a b c) v2 id
!!= [%a]                | readSignature `(a)     v2 id
!!= [%a]                | readSignature `a       v2 id
!!= [`[a b] sigExpect]  | readSignature `[a b]   v2 id
!!= [`([][]) sigNoHeir] | readSignature `([][])  v2 id

!!= [[0 %a] [0 %b] [0 %c]] | readKeySignature `(a b c) v2 id


""" The Col Macro """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= cbExpect | "Expected a <- (or <) node in : binder"

= (readColBinder rex err ok)
| rexGetNode rex (err rex cbExpect)
& (rune sons heir)
| if (eql rune "<-")
        | ok (rexKids rex)
| if (eql rune "<")
        | ok (rexKids rex)
| else
        | err rex cbExpect

= (rexIsCapsSymbol rex)
| and (neq 0 rex)
| and (eql %WORD rexStyle-rex)
      (strIsCapitalized rexText-rex)

!!= 1 | rexIsCapsSymbol `Foo
!!= 0 | rexIsCapsSymbol `foo
!!= 0 | rexIsCapsSymbol `"Foo"
!!= 0 | rexIsCapsSymbol `0
!!= 0 | rexIsCapsSymbol `(hi there)

; ?(f x y) | ??(f x y) | (x y) | .*
= (readColSig rex err ok)
@ ryn (rexRune rex)
;
| if (eql '&' ryn)
    | ifNot | and (isZero rexHeir-rex) (eql 1 | len rexSons-rex)
        | err rex '?(form .{:} signature)  <- has strange shape'
    | ok ['&' (idx 0 rexSons-rex)]
;
| if (eql '?' ryn)
    | ifNot | and (isZero rexHeir-rex) (eql 1 | len rexSons-rex)
        | err rex '?(form .{:} signature)  <- has strange shape'
    | ok ['?' (idx 0 rexSons-rex)]
;
| if (eql '??' ryn)
    | ifNot | and (isZero rexHeir-rex) (eql 1 | len rexSons-rex)
        | err rex '??(form .{:} signature)  <- has strange shape'
    | ok ['??' (idx 0 rexSons-rex)]
;
| ok ['&' (NEST 0 "|" [rex] 0)]

!!= ['&' `(| (Foo x))] (readColSig `(Foo x) id id)

!!= ['&' `(Foo x)] (readColSig `(&(Foo x)) id id)

!!= ['?' `(Foo x)] (readColSig `(?(Foo x)) id id)

!!= ['??' `(Foo x)] (readColSig `(??(Foo x)) id id)

= colNeedsHeir | "Heir is required"
= colTwoSons   | "Expected at least two sons"

; TODO: This expands to `&` instead of `#&`.  This is a bit of a hack,
; since we generally use the approach of expanding only to primitive runes
; (avoiding repeated macro-expansion).  However, it is currently too
; cumbersome for such a simple little sugar-macro.  Re-architect the
; destructuring code so that it's easy to do this the right way.
;
; As a consequence of this hack, we get error messages in the expansion,
; instead of directly from this macro, which is a worse user experience.
= (":" s p e a r err ok)
@ sons    (rexSons r)
@ heir    (rexHeir r)
@ numSons (len sons)
| if (isZero heir)      | err r colNeedsHeir
| if (lthNat numSons 2) | err r colTwoSons
@ firstSons (take dec-numSons sons)
@ lastSon   (idx dec-numSons sons)
@ signature | if (eql 2 numSons) (idx 0 firstSons)
            | (PREF 0 "&" [(NEST 0 "|" firstSons 0)] 0)
; trk ['signature' signature]
| readColSig signature err
& sig
@ sigRune | idx 0 sig
@ sigExp  | idx 1 sig
| readColBinder lastSon err
& kids
| ok p a
; ^ trk [output=_] _
| OPEN 0 "#|" kids
| OPEN 0 sigRune [sigExp]
| heir

= (rexGetRune rex fall ok)
: rune kids heir <- rexGetNode rex fall
| **ok rune

!!= ["+" "+"]
        : rune <- **rexGetRune `(3 + 4) 99
        , rune rune

!!= [`(<* f) cbExpect]
        (.{:} 0 0 0 0 `((: x <* f)(, 3)) v2 v3)


""" Fancy Function Application """""""""""""""""""""""""""""""""""""""""""""""""

= (unwrapTarSeq rex err ok)
^ _ NIL rex
? (loop acc rex)
| if (isZero rex)
    | ok | listToRowReversed acc
| if (neq {*} | rexRune rex)
    | ok | listToRowReversed (CONS rex acc)
| ifNot (len (rexSons rex))
    | err rex "Empty * item (not okay)"
@ item
    | rexSetRune {#|}
    | rexSetHeir 0
    | rex
| loop (CONS item acc) (rexHeir rex)

!!=     ^ unwrapTarSeq _ v2 v1
        ` * add
          * 2
          * 3
    ,
   ,, ` #| add
   ,, ` #| 2
   ,, ` #| 3

= ({|} s p e a r err ok)
@ sons (rexSons r)
@ heir (rexHeir r)
@ kids (rexKids r)
| ifNot len-kids
    | ok p a `0
| if | and (not (isZero heir))
           (eql {*} (rexRune heir))
    | if (isZero len-sons)
        | err r {* heir, but no sons}
    : orphans < unwrapTarSeq heir err
    @ r | rexSetHeir 0 r
    @ r | rexSetSons (weld sons orphans) r
    @ r | rexSetRune {#|} r
    | ok p a r
^ ok p a _
| rexSetRune {#|} r

!!= 3                 | (| add)(* 2)(* 1)
!!= 3                 | (| add)(* 2)(| add 0 1)
!!= [2 7]             | (| v2)(* 2)(| add 3)(* 4)
!!= [1,2 1,2 1,2 1,2] | (| v4)(* v2 1 2)(* v2 1 2)(* v2 1 2)(| v2 1)(| 2)



""" Closed List Literals """""""""""""""""""""""""""""""""""""""""""""""""""""""

(consE x xs)=(rowE [x xs])
nilE=(cnsE NIL)

> List Rex > Rex
(listE xs)=(listFoldr consE nilE xs)

sigExpect={~ expects to be wrapped around a tuple literal: `~[3 4 5]`}

= (readWideListLit readExp rex err ok)
@ fail      | err rex sigExpect
@ kids      | rexKids rex
@ firstKid  | idx 0 kids
@ itemRexes | rexKids firstKid
;
| if (neq 1 | len kids) fail
| if (neq "~" | rexRune rex) fail
| if (neq "," | rexRune firstKid) fail
;
| traverseRow (flip readExp err) itemRexes
& items
| ok (listFromRow items)

= ({~} s p e a r err ok)
| readWideListLit readRex r err
& items
| ok p a (listE items)

!!= ~[3 4 5] | [3 [4 [5 0]]]
!!= ~[3]     | [3 0]
!!= ~[]      | 0


""" Open List Literals """""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (readItemized rune readItem readUnmatchingHeir rex err ok)
^ _ rex ok
? (go rex ret)
| trk 'go',rex
| if (isZero rex)
    | ret NIL
| if (neq rune | rexRune rex)
    : final < readUnmatchingHeir rex err
    | ret (CONS final NIL)
@ sons (rexSons rex)
@ itemRex
    | if (eql 1 | len sons) (idx 0 sons)
    | OPEN 0 {|} sons 0
| if (null sons)
    | err (rexSetHeir 0 rex) "Expected non-empty line"
: item < readItem itemRex err
| trk #[=item]
: tail < go (rexHeir rex)
| ret (CONS item tail)

= (readTallListLit readItem rex err ok)
| readItemized {~~} readItem readItem rex err ok

= ({~~} s p e a r err ok)
: items <- readTallListLit readRex r err
| trk 'items',items,'->',(listE items)
| ok p a (listE items)

!!= ~[3 4 5] | [3 [4 [5 0]]]
!!= ~[3]     | ~~ 3
!!= ~[3 4 5]
       ~~ 3
       ~~ 4
       ~~ 5


""" Quasi Quotation """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""

; {readQuasiTree} reads a quasi-quoted rex input and returns a Rex
; node with the quasi-quoted parts stored as embedded values.
;
; There are two types of splices, $$(expression splices) and $valueSlices.
;
; The details of how that is stored is left up to `readVal` and `readExp`,
; but the point is this reads a rex tree (without embeded values and with
; splices) into a rex tree (with embeded values).
;
; It's slightly confusing, but works out cleanly.  It's simpler than
; building our own representation for the same structure.

= (readQuasiTree readVal readExp rex err ok)
@ rune | rexRune rex
@ heir | rexHeir rex
@ kids | rexKids rex
@ nKid | len kids
| if (rexIsEmbd rex)
    | err rex {quasi-quotation contains unexpected PLAN embed}
| if (eql {$} rune)
    | if (neq 1 nKid)
        | err rex {Too many/few sons for $ in `` macro}
    | readVal (fst kids) err ok
| if (eql {$$} rune)
    | if (neq 1 nKid)
        | err rex 'Too many/few sons for $$ in `` macro'
    | readExp (fst kids) err ok
: heir
    < & ret
      | if (isZero heir) (ret 0)
      | readQuasiTree readVal readExp heir err ret
| if (rexIsLeaf rex)
    | ok (R | rexConstr rex 0 (rexText rex) heir)
| else
    : sons
        < ^ traverseRow _ (rexSons rex)
          & (r k)
          | readQuasiTree readVal readExp r err k
    | ok (R | rexConstr rex 0 rune sons heir)

quasiExpected={Expected something like: ``rex}

> (Rex > Read Rex) ; val
> (Rex > Read Rex) ; exp
> Rex
> Read Rex
= (readQuasiQuotedRex readVal readExp rex err ok)
@ rune | rexRune rex
@ kids | rexKids rex
@ tree | fst kids
| if (or (neq "``" rune) (neq 1 | len kids))
    | err rex quasiExpected
| readQuasiTree readVal readExp tree err ok

four=(WORD 0 {4} 0)

; {splicedE} takes a rex whose embded values represent splices.
; Each splice is either a expression that should be interpreted as
; constant value or an expressions that should be evaluated to a rex tree.
;
; We take that rex input, and we produce rex *output* that is a sire
; expression that *evalutes to* the final rex tree.
;
; This is all very confusing, but it can be worked through, and the
; resulting interface is intuitive.

> RexEmbed (Either Rex Rex) > Rex
= (splicedE rex)
@ sons | rexSons rex
@ heir | rexHeir rex
@ rune | rexRune rex
@ text | rexText rex
| if (rexIsEmbd rex)
    | eitherCase (rexEmbd rex)
        (l & appE (cnsE EMBD, l))
        (r & r)
| if (rexIsLeaf rex)
    ^ appE (cnsE R, appE _)
   ,, cnsE (rexConstr rex 0 text)
   ,, if (isZero heir) (cnsE 0) (splicedE heir)
| else
    ^ appE (cnsE R, appE _)
   ,, cnsE (rexConstr rex 0 rune)
   ,, rowE (map splicedE sons)
   ,, if (isZero heir) (cnsE 0) (splicedE heir)

; $ splices in a constant value
; $$ splices in an expression
;
; TODO: Reverse these runes?

= ({``} s p e a r err ok)
@ readVal (rex err ok & ok (EMBD | LEFT rex))
@ readExp (rex err ok & ok (EMBD | RIGHT rex))
: quoted < readQuasiQuotedRex readVal readExp r err
| ok p a (splicedE quoted)

four=(WORD 0 {4} 0)

!!= `(3 4 5) | ``(3 4 5)
!!= `(3 4 5) | ``($$(WORD 0 {3} 0) 4 5)

!!= ``(3 $$(cnsE four) 5)
     ``(3 $four 5)

(**NODE x y)=[x y]
(**LEAF x)=[x]

> (a > a > a) > BinTree a > a
= (binTreeFold f node)
| if (eql 1 len-node) (idx 0 node)
| f
* binTreeFold f (fst node)
* binTreeFold f (snd node)

= (**readInfixValidate rune rex err ok)
@ kids (rexKids rex)
@ nKid (len kids)
| if (neq rune rexRune-rex)
    | err rex | strWeld {expected rune: } rune
| if (isZero nKid)
    | err rex {binary operator requries 2+ args}
| **ok kids nKid

= (readInfixLeft readExp rune rex err ok)
: kids nKid <- readInfixValidate rune rex err
^ _ nKid kids
? (go nKid kids)
: lastItem < readExp (idx (dec nKid) kids) err
| if (eql nKid 1)
    | ok (LEAF lastItem)
| else
    @ nKid (dec nKid)
    : head <- go nKid (take nKid kids)
    | ok (NODE head (LEAF lastItem))

= (readInfixRight readExp rune rex err ok)
: kids nKid <- readInfixValidate rune rex err
^ _ nKid kids ok
? (go nKid kids ok)
: fstItem < readExp (idx 0 kids) err
| if (eql nKid 1)
    | ok (LEAF fstItem)
| else
    @ nKid (dec nKid)
    : rest <- go nKid (drop 1 kids)
    | ok (NODE (LEAF fstItem) rest)

= (andE x y) | ``($and $$x $$y)
= (orE x y)  | ``($or $$x $$y)

= ({&&} s p e a r err ok)
: tree < readInfixRight readRex "&&" r err
| ok p a (binTreeFold andE tree)

= ({||} s p e a r err ok)
: tree < readInfixRight readRex "||" r err
| ok p a (binTreeFold orE tree)

= ({::} s p e a r err ok)
: tree < readInfixRight readRex "::" r err
| ok p a (binTreeFold consE tree)

!!= ~[3 4]   (3 :: 4 :: ~[])
!!= ~[3 4 5] (3 :: 4 :: ~[5])
!!= ~[3 4]   (:: 3)(:: 4)(:: ~[])

!!= 1 | (@ one 1)(@ zero 0)(one && not zero)
!!= 1 | not (1 && 0)
!!= 1 | not (0 && 1)
!!= 1 | not (0 && 0)
!!= 1 | ((0 && 1) || (1 && 1))
!!= 3 | ||3
!!= 3 | &&3

!!= 1 | (1 && 1 && 1)
!!= 0 | (0 && die 3 && die 4)
!!= 0 | (1 && 0 && die 4)

!!= 1 | (1 || die 0 || 0)
!!= 1 | (0 || 1 || die 0)
!!= 1 | (0 || 0 || 1)
!!= 0 | (0 || 0 || 0)


""" Short-Hand Assertion """""""""""""""""""""""""""""""""""""""""""""""""""""""

= (readAssert more rex err ok)
@ kids (rexKids rex)
| if (null kids) (ok more)
| ok (appE kids :: more)

= (assertE exps)
| if (isZero exps) `(#*)
| bloodline
^ listMap _ exps
& exp (OPEN 0 {#!!=} (natE 1, exp) 0)

!!=   | assertE
     ~~ `(eql 3 (add 1 2))
     ~~ `(eql 4 (add 3 1))
  `
  #!!= 1 (eql 3 (add 1 2))
  #!!= 1 (eql 4 (add 3 1))

= ({!!} s p e a r err ok)
^ : exps <- _ r
  | ok p a (assertE exps)
? (loop r ret)
@ heir     | rexHeir r
@ heirRune | rexRune heir
| if (isZero heir || neq {!!} heirRune)
    : exps <- readAssert NIL r err
    | ret exps
: more <- loop heir
: exps <- readAssert more (rexSetHeir 0 r) err
| ret exps

!! add 0 1
!!
!! add 1 0
!!
!! not (add 0 0)

!! eql 3
 | 3


""" Equality """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

= (readBinOpRow expectMsg rune readExp rex err ok)
@ fail | err rex expectMsg
@ kids | rexKids rex
@ nKid | len kids
| if (neq rune | rexRune rex) fail
| if (lth kids 2) fail
: vals <- traverseRow (flip readExp err) kids
| ok vals

> (Rex > Read a) > Rex > Read (Row a)
= (readEqlExp readExp rex err ok)
@ eqlExpect {Expected something like (x==y), (x==y==z), etc}
| readBinOpRow eqlExpect {==} readExp rex err ok

> (Rex > Read a) > Rex > Read2 a a
= (readNotEqlExp readExp rex err ok)
@ fail | err rex {Expected something like (x /= y)}
@ kids | rexKids rex
@ nKid | len kids
| if (neq nKid 2) fail
| if (neq {/=} | rexRune rex) fail
: x <- readExp (fst kids) err
: y <- readExp (snd kids) err
| ok x y

(notEqlE x y)=(appE (cnsE neq, x, y))

> Nat > Row Rex > (Nat, Rex)
= (multiEqlE n exps)
@ numExps (len exps)
| if (lth numExps 2)
    | 'multiEqlE needs 2+ expressions' exps
| if (eql numExps 2)
    | (n, appE (cnsE eql, fst exps, snd exps))
@ tmpVar | gensym n
@ tmpRef | varE tmpVar
@ fstExp   | fst exps
@ restExps | drop 1 exps
^ (inc n, _)
^ | letE tmpVar fstExp
  | _ (listFromRow restExps)
? (loop more)
: x xs <- **listCase more (die "impossible")
: y ys <- **listCase xs (appE (cnsE eql, tmpRef, x))
^ appE (cnsE and, _, loop xs)
| appE (cnsE eql, tmpRef, x)

= ({==} s p e a r err ok)
: items < readEqlExp readRex r err
@ ar | multiEqlE a items
| ok p (fst ar) (snd ar)

= ({/=} s p e a r err ok)
: x y <- readNotEqlExp readRex r err
| ok p a (notEqlE x y)

!!= 1 (3 /= 4)
!!= 0 (3 /= 3)
!!= 1 (3 == 3)
!!= 1 (3 == 3 == 3)
!!= 0 (4 == 3 == 3)
!!= 0 (3 == 4 == 3)
!!= 0 (3 == 3 == 4)


""" Exports """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

^-^
^-^ rexGetRune
^-^ readKeySignature readSignature
^-^ readItemized
^-^ readTallListLit readWideListLit
^-^ readNotEqlExp readEqlExp
^-^ readQuasiQuotedRex splicedE
^-^ NODE LEAF binTreeFold
^-^ readInfixRight readInfixLeft
^-^
^-^ {|}
^-^ {:}
^-^ {~} {~~} {::}
^-^ {``}
^-^ {&&} {||}
^-^ {==} {/=}
^-^ {!!}
^-^
